import * as D from "react";
import We, { createContext as Ls, forwardRef as Is, useState as Ue, useImperativeHandle as Ds, useEffect as Fe, useContext as qo, useRef as Go, useCallback as Ms, Children as Fs, cloneElement as Bs, useLayoutEffect as Ca, useMemo as $r } from "react";
import * as ka from "react-dom";
var No = { exports: {} }, jn = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var di;
function Us() {
  if (di) return jn;
  di = 1;
  var e = We, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function s(l, c, u) {
    var f, d = {}, p = null, h = null;
    u !== void 0 && (p = "" + u), c.key !== void 0 && (p = "" + c.key), c.ref !== void 0 && (h = c.ref);
    for (f in c) r.call(c, f) && !i.hasOwnProperty(f) && (d[f] = c[f]);
    if (l && l.defaultProps) for (f in c = l.defaultProps, c) d[f] === void 0 && (d[f] = c[f]);
    return { $$typeof: t, type: l, key: p, ref: h, props: d, _owner: o.current };
  }
  return jn.Fragment = n, jn.jsx = s, jn.jsxs = s, jn;
}
var Nn = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var fi;
function Vs() {
  return fi || (fi = 1, process.env.NODE_ENV !== "production" && function() {
    var e = We, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), l = Symbol.for("react.context"), c = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), f = Symbol.for("react.suspense_list"), d = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), h = Symbol.for("react.offscreen"), m = Symbol.iterator, v = "@@iterator";
    function w(a) {
      if (a === null || typeof a != "object")
        return null;
      var y = m && a[m] || a[v];
      return typeof y == "function" ? y : null;
    }
    var b = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function g(a) {
      {
        for (var y = arguments.length, E = new Array(y > 1 ? y - 1 : 0), k = 1; k < y; k++)
          E[k - 1] = arguments[k];
        x("error", a, E);
      }
    }
    function x(a, y, E) {
      {
        var k = b.ReactDebugCurrentFrame, U = k.getStackAddendum();
        U !== "" && (y += "%s", E = E.concat([U]));
        var V = E.map(function(I) {
          return String(I);
        });
        V.unshift("Warning: " + y), Function.prototype.apply.call(console[a], console, V);
      }
    }
    var R = !1, A = !1, P = !1, _ = !1, C = !1, M;
    M = Symbol.for("react.module.reference");
    function O(a) {
      return !!(typeof a == "string" || typeof a == "function" || a === r || a === i || C || a === o || a === u || a === f || _ || a === h || R || A || P || typeof a == "object" && a !== null && (a.$$typeof === p || a.$$typeof === d || a.$$typeof === s || a.$$typeof === l || a.$$typeof === c || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      a.$$typeof === M || a.getModuleId !== void 0));
    }
    function S(a, y, E) {
      var k = a.displayName;
      if (k)
        return k;
      var U = y.displayName || y.name || "";
      return U !== "" ? E + "(" + U + ")" : E;
    }
    function $(a) {
      return a.displayName || "Context";
    }
    function T(a) {
      if (a == null)
        return null;
      if (typeof a.tag == "number" && g("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof a == "function")
        return a.displayName || a.name || null;
      if (typeof a == "string")
        return a;
      switch (a) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case f:
          return "SuspenseList";
      }
      if (typeof a == "object")
        switch (a.$$typeof) {
          case l:
            var y = a;
            return $(y) + ".Consumer";
          case s:
            var E = a;
            return $(E._context) + ".Provider";
          case c:
            return S(a, a.render, "ForwardRef");
          case d:
            var k = a.displayName || null;
            return k !== null ? k : T(a.type) || "Memo";
          case p: {
            var U = a, V = U._payload, I = U._init;
            try {
              return T(I(V));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var j = Object.assign, L = 0, Y, z, K, W, te, J, ce;
    function Ee() {
    }
    Ee.__reactDisabledLog = !0;
    function Se() {
      {
        if (L === 0) {
          Y = console.log, z = console.info, K = console.warn, W = console.error, te = console.group, J = console.groupCollapsed, ce = console.groupEnd;
          var a = {
            configurable: !0,
            enumerable: !0,
            value: Ee,
            writable: !0
          };
          Object.defineProperties(console, {
            info: a,
            log: a,
            warn: a,
            error: a,
            group: a,
            groupCollapsed: a,
            groupEnd: a
          });
        }
        L++;
      }
    }
    function ie() {
      {
        if (L--, L === 0) {
          var a = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: j({}, a, {
              value: Y
            }),
            info: j({}, a, {
              value: z
            }),
            warn: j({}, a, {
              value: K
            }),
            error: j({}, a, {
              value: W
            }),
            group: j({}, a, {
              value: te
            }),
            groupCollapsed: j({}, a, {
              value: J
            }),
            groupEnd: j({}, a, {
              value: ce
            })
          });
        }
        L < 0 && g("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var ue = b.ReactCurrentDispatcher, pe;
    function G(a, y, E) {
      {
        if (pe === void 0)
          try {
            throw Error();
          } catch (U) {
            var k = U.stack.trim().match(/\n( *(at )?)/);
            pe = k && k[1] || "";
          }
        return `
` + pe + a;
      }
    }
    var H = !1, Z;
    {
      var ne = typeof WeakMap == "function" ? WeakMap : Map;
      Z = new ne();
    }
    function Q(a, y) {
      if (!a || H)
        return "";
      {
        var E = Z.get(a);
        if (E !== void 0)
          return E;
      }
      var k;
      H = !0;
      var U = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var V;
      V = ue.current, ue.current = null, Se();
      try {
        if (y) {
          var I = function() {
            throw Error();
          };
          if (Object.defineProperty(I.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(I, []);
            } catch (re) {
              k = re;
            }
            Reflect.construct(a, [], I);
          } else {
            try {
              I.call();
            } catch (re) {
              k = re;
            }
            a.call(I.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (re) {
            k = re;
          }
          a();
        }
      } catch (re) {
        if (re && k && typeof re.stack == "string") {
          for (var N = re.stack.split(`
`), ee = k.stack.split(`
`), X = N.length - 1, q = ee.length - 1; X >= 1 && q >= 0 && N[X] !== ee[q]; )
            q--;
          for (; X >= 1 && q >= 0; X--, q--)
            if (N[X] !== ee[q]) {
              if (X !== 1 || q !== 1)
                do
                  if (X--, q--, q < 0 || N[X] !== ee[q]) {
                    var se = `
` + N[X].replace(" at new ", " at ");
                    return a.displayName && se.includes("<anonymous>") && (se = se.replace("<anonymous>", a.displayName)), typeof a == "function" && Z.set(a, se), se;
                  }
                while (X >= 1 && q >= 0);
              break;
            }
        }
      } finally {
        H = !1, ue.current = V, ie(), Error.prepareStackTrace = U;
      }
      var Re = a ? a.displayName || a.name : "", ye = Re ? G(Re) : "";
      return typeof a == "function" && Z.set(a, ye), ye;
    }
    function oe(a, y, E) {
      return Q(a, !1);
    }
    function fe(a) {
      var y = a.prototype;
      return !!(y && y.isReactComponent);
    }
    function le(a, y, E) {
      if (a == null)
        return "";
      if (typeof a == "function")
        return Q(a, fe(a));
      if (typeof a == "string")
        return G(a);
      switch (a) {
        case u:
          return G("Suspense");
        case f:
          return G("SuspenseList");
      }
      if (typeof a == "object")
        switch (a.$$typeof) {
          case c:
            return oe(a.render);
          case d:
            return le(a.type, y, E);
          case p: {
            var k = a, U = k._payload, V = k._init;
            try {
              return le(V(U), y, E);
            } catch {
            }
          }
        }
      return "";
    }
    var ae = Object.prototype.hasOwnProperty, Oe = {}, ke = b.ReactDebugCurrentFrame;
    function Te(a) {
      if (a) {
        var y = a._owner, E = le(a.type, a._source, y ? y.type : null);
        ke.setExtraStackFrame(E);
      } else
        ke.setExtraStackFrame(null);
    }
    function at(a, y, E, k, U) {
      {
        var V = Function.call.bind(ae);
        for (var I in a)
          if (V(a, I)) {
            var N = void 0;
            try {
              if (typeof a[I] != "function") {
                var ee = Error((k || "React class") + ": " + E + " type `" + I + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof a[I] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw ee.name = "Invariant Violation", ee;
              }
              N = a[I](y, I, k, E, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (X) {
              N = X;
            }
            N && !(N instanceof Error) && (Te(U), g("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", k || "React class", E, I, typeof N), Te(null)), N instanceof Error && !(N.message in Oe) && (Oe[N.message] = !0, Te(U), g("Failed %s type: %s", E, N.message), Te(null));
          }
      }
    }
    var ze = Array.isArray;
    function Ce(a) {
      return ze(a);
    }
    function St(a) {
      {
        var y = typeof Symbol == "function" && Symbol.toStringTag, E = y && a[Symbol.toStringTag] || a.constructor.name || "Object";
        return E;
      }
    }
    function hn(a) {
      try {
        return Ot(a), !1;
      } catch {
        return !0;
      }
    }
    function Ot(a) {
      return "" + a;
    }
    function Tt(a) {
      if (hn(a))
        return g("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", St(a)), Ot(a);
    }
    var _e = b.ReactCurrentOwner, gn = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Ct, kt, Ze;
    Ze = {};
    function mn(a) {
      if (ae.call(a, "ref")) {
        var y = Object.getOwnPropertyDescriptor(a, "ref").get;
        if (y && y.isReactWarning)
          return !1;
      }
      return a.ref !== void 0;
    }
    function vn(a) {
      if (ae.call(a, "key")) {
        var y = Object.getOwnPropertyDescriptor(a, "key").get;
        if (y && y.isReactWarning)
          return !1;
      }
      return a.key !== void 0;
    }
    function yn(a, y) {
      if (typeof a.ref == "string" && _e.current && y && _e.current.stateNode !== y) {
        var E = T(_e.current.type);
        Ze[E] || (g('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', T(_e.current.type), a.ref), Ze[E] = !0);
      }
    }
    function bn(a, y) {
      {
        var E = function() {
          Ct || (Ct = !0, g("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", y));
        };
        E.isReactWarning = !0, Object.defineProperty(a, "key", {
          get: E,
          configurable: !0
        });
      }
    }
    function wn(a, y) {
      {
        var E = function() {
          kt || (kt = !0, g("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", y));
        };
        E.isReactWarning = !0, Object.defineProperty(a, "ref", {
          get: E,
          configurable: !0
        });
      }
    }
    var xn = function(a, y, E, k, U, V, I) {
      var N = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: a,
        key: y,
        ref: E,
        props: I,
        // Record the component responsible for creating this element.
        _owner: V
      };
      return N._store = {}, Object.defineProperty(N._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(N, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: k
      }), Object.defineProperty(N, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: U
      }), Object.freeze && (Object.freeze(N.props), Object.freeze(N)), N;
    };
    function En(a, y, E, k, U) {
      {
        var V, I = {}, N = null, ee = null;
        E !== void 0 && (Tt(E), N = "" + E), vn(y) && (Tt(y.key), N = "" + y.key), mn(y) && (ee = y.ref, yn(y, U));
        for (V in y)
          ae.call(y, V) && !gn.hasOwnProperty(V) && (I[V] = y[V]);
        if (a && a.defaultProps) {
          var X = a.defaultProps;
          for (V in X)
            I[V] === void 0 && (I[V] = X[V]);
        }
        if (N || ee) {
          var q = typeof a == "function" ? a.displayName || a.name || "Unknown" : a;
          N && bn(I, q), ee && wn(I, q);
        }
        return xn(a, N, ee, U, k, _e.current, I);
      }
    }
    var Qe = b.ReactCurrentOwner, $t = b.ReactDebugCurrentFrame;
    function Ae(a) {
      if (a) {
        var y = a._owner, E = le(a.type, a._source, y ? y.type : null);
        $t.setExtraStackFrame(E);
      } else
        $t.setExtraStackFrame(null);
    }
    var et;
    et = !1;
    function tt(a) {
      return typeof a == "object" && a !== null && a.$$typeof === t;
    }
    function _t() {
      {
        if (Qe.current) {
          var a = T(Qe.current.type);
          if (a)
            return `

Check the render method of \`` + a + "`.";
        }
        return "";
      }
    }
    function An(a) {
      return "";
    }
    var Pt = {};
    function Rn(a) {
      {
        var y = _t();
        if (!y) {
          var E = typeof a == "string" ? a : a.displayName || a.name;
          E && (y = `

Check the top-level render call using <` + E + ">.");
        }
        return y;
      }
    }
    function jt(a, y) {
      {
        if (!a._store || a._store.validated || a.key != null)
          return;
        a._store.validated = !0;
        var E = Rn(y);
        if (Pt[E])
          return;
        Pt[E] = !0;
        var k = "";
        a && a._owner && a._owner !== Qe.current && (k = " It was passed a child from " + T(a._owner.type) + "."), Ae(a), g('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', E, k), Ae(null);
      }
    }
    function Nt(a, y) {
      {
        if (typeof a != "object")
          return;
        if (Ce(a))
          for (var E = 0; E < a.length; E++) {
            var k = a[E];
            tt(k) && jt(k, y);
          }
        else if (tt(a))
          a._store && (a._store.validated = !0);
        else if (a) {
          var U = w(a);
          if (typeof U == "function" && U !== a.entries)
            for (var V = U.call(a), I; !(I = V.next()).done; )
              tt(I.value) && jt(I.value, y);
        }
      }
    }
    function Sn(a) {
      {
        var y = a.type;
        if (y == null || typeof y == "string")
          return;
        var E;
        if (typeof y == "function")
          E = y.propTypes;
        else if (typeof y == "object" && (y.$$typeof === c || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        y.$$typeof === d))
          E = y.propTypes;
        else
          return;
        if (E) {
          var k = T(y);
          at(E, a.props, "prop", k, a);
        } else if (y.PropTypes !== void 0 && !et) {
          et = !0;
          var U = T(y);
          g("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", U || "Unknown");
        }
        typeof y.getDefaultProps == "function" && !y.getDefaultProps.isReactClassApproved && g("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function On(a) {
      {
        for (var y = Object.keys(a.props), E = 0; E < y.length; E++) {
          var k = y[E];
          if (k !== "children" && k !== "key") {
            Ae(a), g("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", k), Ae(null);
            break;
          }
        }
        a.ref !== null && (Ae(a), g("Invalid attribute `ref` supplied to `React.Fragment`."), Ae(null));
      }
    }
    var Lt = {};
    function It(a, y, E, k, U, V) {
      {
        var I = O(a);
        if (!I) {
          var N = "";
          (a === void 0 || typeof a == "object" && a !== null && Object.keys(a).length === 0) && (N += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var ee = An();
          ee ? N += ee : N += _t();
          var X;
          a === null ? X = "null" : Ce(a) ? X = "array" : a !== void 0 && a.$$typeof === t ? (X = "<" + (T(a.type) || "Unknown") + " />", N = " Did you accidentally export a JSX literal instead of a component?") : X = typeof a, g("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", X, N);
        }
        var q = En(a, y, E, U, V);
        if (q == null)
          return q;
        if (I) {
          var se = y.children;
          if (se !== void 0)
            if (k)
              if (Ce(se)) {
                for (var Re = 0; Re < se.length; Re++)
                  Nt(se[Re], a);
                Object.freeze && Object.freeze(se);
              } else
                g("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Nt(se, a);
        }
        if (ae.call(y, "key")) {
          var ye = T(a), re = Object.keys(y).filter(function(Pn) {
            return Pn !== "key";
          }), nt = re.length > 0 ? "{key: someKey, " + re.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Lt[ye + nt]) {
            var _n = re.length > 0 ? "{" + re.join(": ..., ") + ": ...}" : "{}";
            g(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, nt, ye, _n, ye), Lt[ye + nt] = !0;
          }
        }
        return a === r ? On(q) : Sn(q), q;
      }
    }
    function Tn(a, y, E) {
      return It(a, y, E, !0);
    }
    function Cn(a, y, E) {
      return It(a, y, E, !1);
    }
    var kn = Cn, $n = Tn;
    Nn.Fragment = r, Nn.jsx = kn, Nn.jsxs = $n;
  }()), Nn;
}
process.env.NODE_ENV === "production" ? No.exports = Us() : No.exports = Vs();
var F = No.exports, Lo = { exports: {} }, Ln = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var pi;
function Ys() {
  if (pi) return Ln;
  pi = 1;
  var e = We, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function s(l, c, u) {
    var f, d = {}, p = null, h = null;
    u !== void 0 && (p = "" + u), c.key !== void 0 && (p = "" + c.key), c.ref !== void 0 && (h = c.ref);
    for (f in c) r.call(c, f) && !i.hasOwnProperty(f) && (d[f] = c[f]);
    if (l && l.defaultProps) for (f in c = l.defaultProps, c) d[f] === void 0 && (d[f] = c[f]);
    return { $$typeof: t, type: l, key: p, ref: h, props: d, _owner: o.current };
  }
  return Ln.Fragment = n, Ln.jsx = s, Ln.jsxs = s, Ln;
}
var In = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hi;
function Hs() {
  return hi || (hi = 1, process.env.NODE_ENV !== "production" && function() {
    var e = We, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), l = Symbol.for("react.context"), c = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), f = Symbol.for("react.suspense_list"), d = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), h = Symbol.for("react.offscreen"), m = Symbol.iterator, v = "@@iterator";
    function w(a) {
      if (a === null || typeof a != "object")
        return null;
      var y = m && a[m] || a[v];
      return typeof y == "function" ? y : null;
    }
    var b = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function g(a) {
      {
        for (var y = arguments.length, E = new Array(y > 1 ? y - 1 : 0), k = 1; k < y; k++)
          E[k - 1] = arguments[k];
        x("error", a, E);
      }
    }
    function x(a, y, E) {
      {
        var k = b.ReactDebugCurrentFrame, U = k.getStackAddendum();
        U !== "" && (y += "%s", E = E.concat([U]));
        var V = E.map(function(I) {
          return String(I);
        });
        V.unshift("Warning: " + y), Function.prototype.apply.call(console[a], console, V);
      }
    }
    var R = !1, A = !1, P = !1, _ = !1, C = !1, M;
    M = Symbol.for("react.module.reference");
    function O(a) {
      return !!(typeof a == "string" || typeof a == "function" || a === r || a === i || C || a === o || a === u || a === f || _ || a === h || R || A || P || typeof a == "object" && a !== null && (a.$$typeof === p || a.$$typeof === d || a.$$typeof === s || a.$$typeof === l || a.$$typeof === c || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      a.$$typeof === M || a.getModuleId !== void 0));
    }
    function S(a, y, E) {
      var k = a.displayName;
      if (k)
        return k;
      var U = y.displayName || y.name || "";
      return U !== "" ? E + "(" + U + ")" : E;
    }
    function $(a) {
      return a.displayName || "Context";
    }
    function T(a) {
      if (a == null)
        return null;
      if (typeof a.tag == "number" && g("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof a == "function")
        return a.displayName || a.name || null;
      if (typeof a == "string")
        return a;
      switch (a) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case f:
          return "SuspenseList";
      }
      if (typeof a == "object")
        switch (a.$$typeof) {
          case l:
            var y = a;
            return $(y) + ".Consumer";
          case s:
            var E = a;
            return $(E._context) + ".Provider";
          case c:
            return S(a, a.render, "ForwardRef");
          case d:
            var k = a.displayName || null;
            return k !== null ? k : T(a.type) || "Memo";
          case p: {
            var U = a, V = U._payload, I = U._init;
            try {
              return T(I(V));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var j = Object.assign, L = 0, Y, z, K, W, te, J, ce;
    function Ee() {
    }
    Ee.__reactDisabledLog = !0;
    function Se() {
      {
        if (L === 0) {
          Y = console.log, z = console.info, K = console.warn, W = console.error, te = console.group, J = console.groupCollapsed, ce = console.groupEnd;
          var a = {
            configurable: !0,
            enumerable: !0,
            value: Ee,
            writable: !0
          };
          Object.defineProperties(console, {
            info: a,
            log: a,
            warn: a,
            error: a,
            group: a,
            groupCollapsed: a,
            groupEnd: a
          });
        }
        L++;
      }
    }
    function ie() {
      {
        if (L--, L === 0) {
          var a = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: j({}, a, {
              value: Y
            }),
            info: j({}, a, {
              value: z
            }),
            warn: j({}, a, {
              value: K
            }),
            error: j({}, a, {
              value: W
            }),
            group: j({}, a, {
              value: te
            }),
            groupCollapsed: j({}, a, {
              value: J
            }),
            groupEnd: j({}, a, {
              value: ce
            })
          });
        }
        L < 0 && g("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var ue = b.ReactCurrentDispatcher, pe;
    function G(a, y, E) {
      {
        if (pe === void 0)
          try {
            throw Error();
          } catch (U) {
            var k = U.stack.trim().match(/\n( *(at )?)/);
            pe = k && k[1] || "";
          }
        return `
` + pe + a;
      }
    }
    var H = !1, Z;
    {
      var ne = typeof WeakMap == "function" ? WeakMap : Map;
      Z = new ne();
    }
    function Q(a, y) {
      if (!a || H)
        return "";
      {
        var E = Z.get(a);
        if (E !== void 0)
          return E;
      }
      var k;
      H = !0;
      var U = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var V;
      V = ue.current, ue.current = null, Se();
      try {
        if (y) {
          var I = function() {
            throw Error();
          };
          if (Object.defineProperty(I.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(I, []);
            } catch (re) {
              k = re;
            }
            Reflect.construct(a, [], I);
          } else {
            try {
              I.call();
            } catch (re) {
              k = re;
            }
            a.call(I.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (re) {
            k = re;
          }
          a();
        }
      } catch (re) {
        if (re && k && typeof re.stack == "string") {
          for (var N = re.stack.split(`
`), ee = k.stack.split(`
`), X = N.length - 1, q = ee.length - 1; X >= 1 && q >= 0 && N[X] !== ee[q]; )
            q--;
          for (; X >= 1 && q >= 0; X--, q--)
            if (N[X] !== ee[q]) {
              if (X !== 1 || q !== 1)
                do
                  if (X--, q--, q < 0 || N[X] !== ee[q]) {
                    var se = `
` + N[X].replace(" at new ", " at ");
                    return a.displayName && se.includes("<anonymous>") && (se = se.replace("<anonymous>", a.displayName)), typeof a == "function" && Z.set(a, se), se;
                  }
                while (X >= 1 && q >= 0);
              break;
            }
        }
      } finally {
        H = !1, ue.current = V, ie(), Error.prepareStackTrace = U;
      }
      var Re = a ? a.displayName || a.name : "", ye = Re ? G(Re) : "";
      return typeof a == "function" && Z.set(a, ye), ye;
    }
    function oe(a, y, E) {
      return Q(a, !1);
    }
    function fe(a) {
      var y = a.prototype;
      return !!(y && y.isReactComponent);
    }
    function le(a, y, E) {
      if (a == null)
        return "";
      if (typeof a == "function")
        return Q(a, fe(a));
      if (typeof a == "string")
        return G(a);
      switch (a) {
        case u:
          return G("Suspense");
        case f:
          return G("SuspenseList");
      }
      if (typeof a == "object")
        switch (a.$$typeof) {
          case c:
            return oe(a.render);
          case d:
            return le(a.type, y, E);
          case p: {
            var k = a, U = k._payload, V = k._init;
            try {
              return le(V(U), y, E);
            } catch {
            }
          }
        }
      return "";
    }
    var ae = Object.prototype.hasOwnProperty, Oe = {}, ke = b.ReactDebugCurrentFrame;
    function Te(a) {
      if (a) {
        var y = a._owner, E = le(a.type, a._source, y ? y.type : null);
        ke.setExtraStackFrame(E);
      } else
        ke.setExtraStackFrame(null);
    }
    function at(a, y, E, k, U) {
      {
        var V = Function.call.bind(ae);
        for (var I in a)
          if (V(a, I)) {
            var N = void 0;
            try {
              if (typeof a[I] != "function") {
                var ee = Error((k || "React class") + ": " + E + " type `" + I + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof a[I] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw ee.name = "Invariant Violation", ee;
              }
              N = a[I](y, I, k, E, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (X) {
              N = X;
            }
            N && !(N instanceof Error) && (Te(U), g("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", k || "React class", E, I, typeof N), Te(null)), N instanceof Error && !(N.message in Oe) && (Oe[N.message] = !0, Te(U), g("Failed %s type: %s", E, N.message), Te(null));
          }
      }
    }
    var ze = Array.isArray;
    function Ce(a) {
      return ze(a);
    }
    function St(a) {
      {
        var y = typeof Symbol == "function" && Symbol.toStringTag, E = y && a[Symbol.toStringTag] || a.constructor.name || "Object";
        return E;
      }
    }
    function hn(a) {
      try {
        return Ot(a), !1;
      } catch {
        return !0;
      }
    }
    function Ot(a) {
      return "" + a;
    }
    function Tt(a) {
      if (hn(a))
        return g("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", St(a)), Ot(a);
    }
    var _e = b.ReactCurrentOwner, gn = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Ct, kt, Ze;
    Ze = {};
    function mn(a) {
      if (ae.call(a, "ref")) {
        var y = Object.getOwnPropertyDescriptor(a, "ref").get;
        if (y && y.isReactWarning)
          return !1;
      }
      return a.ref !== void 0;
    }
    function vn(a) {
      if (ae.call(a, "key")) {
        var y = Object.getOwnPropertyDescriptor(a, "key").get;
        if (y && y.isReactWarning)
          return !1;
      }
      return a.key !== void 0;
    }
    function yn(a, y) {
      if (typeof a.ref == "string" && _e.current && y && _e.current.stateNode !== y) {
        var E = T(_e.current.type);
        Ze[E] || (g('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', T(_e.current.type), a.ref), Ze[E] = !0);
      }
    }
    function bn(a, y) {
      {
        var E = function() {
          Ct || (Ct = !0, g("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", y));
        };
        E.isReactWarning = !0, Object.defineProperty(a, "key", {
          get: E,
          configurable: !0
        });
      }
    }
    function wn(a, y) {
      {
        var E = function() {
          kt || (kt = !0, g("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", y));
        };
        E.isReactWarning = !0, Object.defineProperty(a, "ref", {
          get: E,
          configurable: !0
        });
      }
    }
    var xn = function(a, y, E, k, U, V, I) {
      var N = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: a,
        key: y,
        ref: E,
        props: I,
        // Record the component responsible for creating this element.
        _owner: V
      };
      return N._store = {}, Object.defineProperty(N._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(N, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: k
      }), Object.defineProperty(N, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: U
      }), Object.freeze && (Object.freeze(N.props), Object.freeze(N)), N;
    };
    function En(a, y, E, k, U) {
      {
        var V, I = {}, N = null, ee = null;
        E !== void 0 && (Tt(E), N = "" + E), vn(y) && (Tt(y.key), N = "" + y.key), mn(y) && (ee = y.ref, yn(y, U));
        for (V in y)
          ae.call(y, V) && !gn.hasOwnProperty(V) && (I[V] = y[V]);
        if (a && a.defaultProps) {
          var X = a.defaultProps;
          for (V in X)
            I[V] === void 0 && (I[V] = X[V]);
        }
        if (N || ee) {
          var q = typeof a == "function" ? a.displayName || a.name || "Unknown" : a;
          N && bn(I, q), ee && wn(I, q);
        }
        return xn(a, N, ee, U, k, _e.current, I);
      }
    }
    var Qe = b.ReactCurrentOwner, $t = b.ReactDebugCurrentFrame;
    function Ae(a) {
      if (a) {
        var y = a._owner, E = le(a.type, a._source, y ? y.type : null);
        $t.setExtraStackFrame(E);
      } else
        $t.setExtraStackFrame(null);
    }
    var et;
    et = !1;
    function tt(a) {
      return typeof a == "object" && a !== null && a.$$typeof === t;
    }
    function _t() {
      {
        if (Qe.current) {
          var a = T(Qe.current.type);
          if (a)
            return `

Check the render method of \`` + a + "`.";
        }
        return "";
      }
    }
    function An(a) {
      return "";
    }
    var Pt = {};
    function Rn(a) {
      {
        var y = _t();
        if (!y) {
          var E = typeof a == "string" ? a : a.displayName || a.name;
          E && (y = `

Check the top-level render call using <` + E + ">.");
        }
        return y;
      }
    }
    function jt(a, y) {
      {
        if (!a._store || a._store.validated || a.key != null)
          return;
        a._store.validated = !0;
        var E = Rn(y);
        if (Pt[E])
          return;
        Pt[E] = !0;
        var k = "";
        a && a._owner && a._owner !== Qe.current && (k = " It was passed a child from " + T(a._owner.type) + "."), Ae(a), g('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', E, k), Ae(null);
      }
    }
    function Nt(a, y) {
      {
        if (typeof a != "object")
          return;
        if (Ce(a))
          for (var E = 0; E < a.length; E++) {
            var k = a[E];
            tt(k) && jt(k, y);
          }
        else if (tt(a))
          a._store && (a._store.validated = !0);
        else if (a) {
          var U = w(a);
          if (typeof U == "function" && U !== a.entries)
            for (var V = U.call(a), I; !(I = V.next()).done; )
              tt(I.value) && jt(I.value, y);
        }
      }
    }
    function Sn(a) {
      {
        var y = a.type;
        if (y == null || typeof y == "string")
          return;
        var E;
        if (typeof y == "function")
          E = y.propTypes;
        else if (typeof y == "object" && (y.$$typeof === c || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        y.$$typeof === d))
          E = y.propTypes;
        else
          return;
        if (E) {
          var k = T(y);
          at(E, a.props, "prop", k, a);
        } else if (y.PropTypes !== void 0 && !et) {
          et = !0;
          var U = T(y);
          g("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", U || "Unknown");
        }
        typeof y.getDefaultProps == "function" && !y.getDefaultProps.isReactClassApproved && g("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function On(a) {
      {
        for (var y = Object.keys(a.props), E = 0; E < y.length; E++) {
          var k = y[E];
          if (k !== "children" && k !== "key") {
            Ae(a), g("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", k), Ae(null);
            break;
          }
        }
        a.ref !== null && (Ae(a), g("Invalid attribute `ref` supplied to `React.Fragment`."), Ae(null));
      }
    }
    var Lt = {};
    function It(a, y, E, k, U, V) {
      {
        var I = O(a);
        if (!I) {
          var N = "";
          (a === void 0 || typeof a == "object" && a !== null && Object.keys(a).length === 0) && (N += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var ee = An();
          ee ? N += ee : N += _t();
          var X;
          a === null ? X = "null" : Ce(a) ? X = "array" : a !== void 0 && a.$$typeof === t ? (X = "<" + (T(a.type) || "Unknown") + " />", N = " Did you accidentally export a JSX literal instead of a component?") : X = typeof a, g("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", X, N);
        }
        var q = En(a, y, E, U, V);
        if (q == null)
          return q;
        if (I) {
          var se = y.children;
          if (se !== void 0)
            if (k)
              if (Ce(se)) {
                for (var Re = 0; Re < se.length; Re++)
                  Nt(se[Re], a);
                Object.freeze && Object.freeze(se);
              } else
                g("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Nt(se, a);
        }
        if (ae.call(y, "key")) {
          var ye = T(a), re = Object.keys(y).filter(function(Pn) {
            return Pn !== "key";
          }), nt = re.length > 0 ? "{key: someKey, " + re.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Lt[ye + nt]) {
            var _n = re.length > 0 ? "{" + re.join(": ..., ") + ": ...}" : "{}";
            g(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, nt, ye, _n, ye), Lt[ye + nt] = !0;
          }
        }
        return a === r ? On(q) : Sn(q), q;
      }
    }
    function Tn(a, y, E) {
      return It(a, y, E, !0);
    }
    function Cn(a, y, E) {
      return It(a, y, E, !1);
    }
    var kn = Cn, $n = Tn;
    In.Fragment = r, In.jsx = kn, In.jsxs = $n;
  }()), In;
}
process.env.NODE_ENV === "production" ? Lo.exports = Ys() : Lo.exports = Hs();
var Ws = Lo.exports;
const Ks = [];
for (let e = 0; e < 256; ++e)
  Ks.push((e + 256).toString(16).slice(1));
typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
const Xs = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
let zs = (e = 21) => {
  let t = "", n = crypto.getRandomValues(new Uint8Array(e));
  for (; e--; )
    t += Xs[n[e] & 63];
  return t;
};
zs();
const Wr = Ls({
  anno: void 0,
  setAnno: void 0,
  annotations: [],
  selection: { selected: [] }
}), qs = Is((e, t) => {
  const [n, r] = Ue(null), [o, i] = Ue([]), [s, l] = Ue({ selected: [] });
  return Ds(t, () => n), Fe(() => {
    if (n) {
      const { selection: c, store: u, hover: f } = n.state;
      u.all().length > 0 && i(u.all());
      const d = () => i(() => u.all());
      u.observe(d);
      let p;
      const h = c.subscribe(({ selected: m, ...v }) => {
        p && u.unobserve(p);
        const w = (m || []).map(({ id: b, editable: g }) => ({ annotation: u.getAnnotation(b), editable: g }));
        l({ selected: w, ...v }), p = (b) => {
          const { updated: g } = b.changes;
          l((x) => ({
            ...x,
            selected: x.selected.map(({ annotation: R, editable: A }) => {
              const P = g.find((_) => _.oldValue.id === R.id);
              return P ? { annotation: P.newValue, editable: A } : { annotation: R, editable: A };
            })
          }));
        }, u.observe(p, { annotations: m.map(({ id: b }) => b) });
      });
      return () => {
        u.unobserve(d), h();
      };
    }
  }, [n]), /* @__PURE__ */ Ws.jsx(Wr.Provider, { value: {
    anno: n,
    setAnno: r,
    annotations: o,
    selection: s
  }, children: e.children });
}), $a = () => {
  const { anno: e } = qo(Wr);
  return e;
}, _a = () => {
  const { selection: e } = qo(Wr);
  return e;
};
var Gs = Object.defineProperty, Js = (e, t, n) => t in e ? Gs(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, gi = (e, t, n) => Js(e, typeof t != "symbol" ? t + "" : t, n);
function er() {
}
function Io(e, t) {
  for (const n in t) e[n] = t[n];
  return (
    /** @type {T & S} */
    e
  );
}
function Pa(e) {
  return e();
}
function mi() {
  return /* @__PURE__ */ Object.create(null);
}
function At(e) {
  e.forEach(Pa);
}
function Be(e) {
  return typeof e == "function";
}
function Kr(e, t) {
  return e != e ? t == t : e !== t || e && typeof e == "object" || typeof e == "function";
}
function Zs(e) {
  return Object.keys(e).length === 0;
}
function Qs(e, t, n, r) {
  if (e) {
    const o = ja(e, t, n, r);
    return e[0](o);
  }
}
function ja(e, t, n, r) {
  return e[1] && r ? Io(n.ctx.slice(), e[1](r(t))) : n.ctx;
}
function el(e, t, n, r) {
  if (e[2] && r) {
    const o = e[2](r(n));
    if (t.dirty === void 0)
      return o;
    if (typeof o == "object") {
      const i = [], s = Math.max(t.dirty.length, o.length);
      for (let l = 0; l < s; l += 1)
        i[l] = t.dirty[l] | o[l];
      return i;
    }
    return t.dirty | o;
  }
  return t.dirty;
}
function tl(e, t, n, r, o, i) {
  if (o) {
    const s = ja(t, n, r, i);
    e.p(s, o);
  }
}
function nl(e) {
  if (e.ctx.length > 32) {
    const t = [], n = e.ctx.length / 32;
    for (let r = 0; r < n; r++)
      t[r] = -1;
    return t;
  }
  return -1;
}
function vi(e) {
  const t = {};
  for (const n in e) n[0] !== "$" && (t[n] = e[n]);
  return t;
}
function _r(e) {
  return e ?? "";
}
function yi(e, t) {
  e.appendChild(t);
}
function ge(e, t, n) {
  e.insertBefore(t, n || null);
}
function he(e) {
  e.parentNode && e.parentNode.removeChild(e);
}
function rl(e, t) {
  for (let n = 0; n < e.length; n += 1)
    e[n] && e[n].d(t);
}
function Ye(e) {
  return document.createElementNS("http://www.w3.org/2000/svg", e);
}
function Na(e) {
  return document.createTextNode(e);
}
function rt() {
  return Na(" ");
}
function La() {
  return Na("");
}
function De(e, t, n, r) {
  return e.addEventListener(t, n, r), () => e.removeEventListener(t, n, r);
}
function B(e, t, n) {
  n == null ? e.removeAttribute(t) : e.getAttribute(t) !== n && e.setAttribute(t, n);
}
function ol(e) {
  return Array.from(e.childNodes);
}
function bi(e, t, n) {
  e.classList.toggle(t, !!n);
}
function il(e, t, { bubbles: n = !1, cancelable: r = !1 } = {}) {
  return new CustomEvent(e, { detail: t, bubbles: n, cancelable: r });
}
let tr;
function zn(e) {
  tr = e;
}
function al() {
  if (!tr) throw new Error("Function called outside component initialization");
  return tr;
}
function sl() {
  const e = al();
  return (t, n, { cancelable: r = !1 } = {}) => {
    const o = e.$$.callbacks[t];
    if (o) {
      const i = il(
        /** @type {string} */
        t,
        n,
        { cancelable: r }
      );
      return o.slice().forEach((s) => {
        s.call(e, i);
      }), !i.defaultPrevented;
    }
    return !0;
  };
}
function yt(e, t) {
  const n = e.$$.callbacks[t.type];
  n && n.slice().forEach((r) => r.call(this, t));
}
const rn = [], wi = [];
let an = [];
const xi = [], ll = /* @__PURE__ */ Promise.resolve();
let Do = !1;
function cl() {
  Do || (Do = !0, ll.then(Ia));
}
function Mo(e) {
  an.push(e);
}
const ro = /* @__PURE__ */ new Set();
let Zt = 0;
function Ia() {
  if (Zt !== 0)
    return;
  const e = tr;
  do {
    try {
      for (; Zt < rn.length; ) {
        const t = rn[Zt];
        Zt++, zn(t), ul(t.$$);
      }
    } catch (t) {
      throw rn.length = 0, Zt = 0, t;
    }
    for (zn(null), rn.length = 0, Zt = 0; wi.length; ) wi.pop()();
    for (let t = 0; t < an.length; t += 1) {
      const n = an[t];
      ro.has(n) || (ro.add(n), n());
    }
    an.length = 0;
  } while (rn.length);
  for (; xi.length; )
    xi.pop()();
  Do = !1, ro.clear(), zn(e);
}
function ul(e) {
  if (e.fragment !== null) {
    e.update(), At(e.before_update);
    const t = e.dirty;
    e.dirty = [-1], e.fragment && e.fragment.p(e.ctx, t), e.after_update.forEach(Mo);
  }
}
function dl(e) {
  const t = [], n = [];
  an.forEach((r) => e.indexOf(r) === -1 ? t.push(r) : n.push(r)), n.forEach((r) => r()), an = t;
}
const Sr = /* @__PURE__ */ new Set();
let Xt;
function fl() {
  Xt = {
    r: 0,
    c: [],
    p: Xt
    // parent group
  };
}
function pl() {
  Xt.r || At(Xt.c), Xt = Xt.p;
}
function qe(e, t) {
  e && e.i && (Sr.delete(e), e.i(t));
}
function st(e, t, n, r) {
  if (e && e.o) {
    if (Sr.has(e)) return;
    Sr.add(e), Xt.c.push(() => {
      Sr.delete(e), r && (n && e.d(1), r());
    }), e.o(t);
  } else r && r();
}
function Ei(e) {
  return (e == null ? void 0 : e.length) !== void 0 ? e : Array.from(e);
}
function zt(e) {
  e && e.c();
}
function Mt(e, t, n) {
  const { fragment: r, after_update: o } = e.$$;
  r && r.m(t, n), Mo(() => {
    const i = e.$$.on_mount.map(Pa).filter(Be);
    e.$$.on_destroy ? e.$$.on_destroy.push(...i) : At(i), e.$$.on_mount = [];
  }), o.forEach(Mo);
}
function Ft(e, t) {
  const n = e.$$;
  n.fragment !== null && (dl(n.after_update), At(n.on_destroy), n.fragment && n.fragment.d(t), n.on_destroy = n.fragment = null, n.ctx = []);
}
function hl(e, t) {
  e.$$.dirty[0] === -1 && (rn.push(e), cl(), e.$$.dirty.fill(0)), e.$$.dirty[t / 31 | 0] |= 1 << t % 31;
}
function Xr(e, t, n, r, o, i, s = null, l = [-1]) {
  const c = tr;
  zn(e);
  const u = e.$$ = {
    fragment: null,
    ctx: [],
    // state
    props: i,
    update: er,
    not_equal: o,
    bound: mi(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(t.context || (c ? c.$$.context : [])),
    // everything else
    callbacks: mi(),
    dirty: l,
    skip_bound: !1,
    root: t.target || c.$$.root
  };
  s && s(u.root);
  let f = !1;
  if (u.ctx = n ? n(e, t.props || {}, (d, p, ...h) => {
    const m = h.length ? h[0] : p;
    return u.ctx && o(u.ctx[d], u.ctx[d] = m) && (!u.skip_bound && u.bound[d] && u.bound[d](m), f && hl(e, d)), p;
  }) : [], u.update(), f = !0, At(u.before_update), u.fragment = r ? r(u.ctx) : !1, t.target) {
    if (t.hydrate) {
      const d = ol(t.target);
      u.fragment && u.fragment.l(d), d.forEach(he);
    } else
      u.fragment && u.fragment.c();
    t.intro && qe(e.$$.fragment), Mt(e, t.target, t.anchor), Ia();
  }
  zn(c);
}
let zr = class {
  constructor() {
    gi(this, "$$"), gi(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    Ft(this, 1), this.$destroy = er;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(t, n) {
    if (!Be(n))
      return er;
    const r = this.$$.callbacks[t] || (this.$$.callbacks[t] = []);
    return r.push(n), () => {
      const o = r.indexOf(n);
      o !== -1 && r.splice(o, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(t) {
    this.$$set && !Zs(t) && (this.$$.skip_bound = !0, this.$$set(t), this.$$.skip_bound = !1);
  }
};
const gl = "4";
typeof window < "u" && (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(gl);
var cn = /* @__PURE__ */ ((e) => (e.ELLIPSE = "ELLIPSE", e.POLYGON = "POLYGON", e.RECTANGLE = "RECTANGLE", e))(cn || {});
const Jo = (e, t) => t, ml = (e) => {
  let t = 1 / 0, n = 1 / 0, r = -1 / 0, o = -1 / 0;
  return e.forEach(([i, s]) => {
    t = Math.min(t, i), n = Math.min(n, s), r = Math.max(r, i), o = Math.max(o, s);
  }), { minX: t, minY: n, maxX: r, maxY: o };
}, vl = {
  area: (e) => Math.PI * e.geometry.rx * e.geometry.ry,
  intersects: (e, t, n) => {
    const { cx: r, cy: o, rx: i, ry: s } = e.geometry, l = 0, c = Math.cos(l), u = Math.sin(l), f = t - r, d = n - o, p = c * f + u * d, h = u * f - c * d;
    return p * p / (i * i) + h * h / (s * s) <= 1;
  }
};
Jo(cn.ELLIPSE, vl);
const yl = {
  area: (e) => {
    const { points: t } = e.geometry;
    let n = 0, r = t.length - 1;
    for (let o = 0; o < t.length; o++)
      n += (t[r][0] + t[o][0]) * (t[r][1] - t[o][1]), r = o;
    return Math.abs(0.5 * n);
  },
  intersects: (e, t, n) => {
    const { points: r } = e.geometry;
    let o = !1;
    for (let i = 0, s = r.length - 1; i < r.length; s = i++) {
      const l = r[i][0], c = r[i][1], u = r[s][0], f = r[s][1];
      c > n != f > n && t < (u - l) * (n - c) / (f - c) + l && (o = !o);
    }
    return o;
  }
};
Jo(cn.POLYGON, yl);
const bl = {
  area: (e) => e.geometry.w * e.geometry.h,
  intersects: (e, t, n) => t >= e.geometry.x && t <= e.geometry.x + e.geometry.w && n >= e.geometry.y && n <= e.geometry.y + e.geometry.h
};
Jo(cn.RECTANGLE, bl);
const wl = [];
for (let e = 0; e < 256; ++e)
  wl.push((e + 256).toString(16).slice(1));
typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
const xl = [];
for (let e = 0; e < 256; ++e)
  xl.push((e + 256).toString(16).slice(1));
typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
const El = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
let Al = (e = 21) => {
  let t = "", n = crypto.getRandomValues(new Uint8Array(e));
  for (; e--; )
    t += El[n[e] & 63];
  return t;
};
Al();
function Ai(e, t, n) {
  const r = e.slice();
  return r[10] = t[n], r[12] = n, r;
}
function Ri(e) {
  let t, n;
  return t = new Yn({
    props: {
      x: (
        /*point*/
        e[10][0]
      ),
      y: (
        /*point*/
        e[10][1]
      ),
      scale: (
        /*viewportScale*/
        e[3]
      )
    }
  }), t.$on("pointerdown", function() {
    Be(
      /*grab*/
      e[9](`HANDLE-${/*idx*/
      e[12]}`)
    ) && e[9](`HANDLE-${/*idx*/
    e[12]}`).apply(this, arguments);
  }), {
    c() {
      zt(t.$$.fragment);
    },
    m(r, o) {
      Mt(t, r, o), n = !0;
    },
    p(r, o) {
      e = r;
      const i = {};
      o & /*geom*/
      16 && (i.x = /*point*/
      e[10][0]), o & /*geom*/
      16 && (i.y = /*point*/
      e[10][1]), o & /*viewportScale*/
      8 && (i.scale = /*viewportScale*/
      e[3]), t.$set(i);
    },
    i(r) {
      n || (qe(t.$$.fragment, r), n = !0);
    },
    o(r) {
      st(t.$$.fragment, r), n = !1;
    },
    d(r) {
      Ft(t, r);
    }
  };
}
function Rl(e) {
  let t, n, r, o, i, s, l, c, u, f, d, p = Ei(
    /*geom*/
    e[4].points
  ), h = [];
  for (let v = 0; v < p.length; v += 1)
    h[v] = Ri(Ai(e, p, v));
  const m = (v) => st(h[v], 1, 1, () => {
    h[v] = null;
  });
  return {
    c() {
      t = Ye("polygon"), o = rt(), i = Ye("polygon"), l = rt();
      for (let v = 0; v < h.length; v += 1)
        h[v].c();
      c = La(), B(t, "class", "a9s-outer"), B(t, "style", n = /*computedStyle*/
      e[1] ? "display:none;" : void 0), B(t, "points", r = /*geom*/
      e[4].points.map(Si).join(" ")), B(i, "class", "a9s-inner a9s-shape-handle"), B(
        i,
        "style",
        /*computedStyle*/
        e[1]
      ), B(i, "points", s = /*geom*/
      e[4].points.map(Oi).join(" "));
    },
    m(v, w) {
      ge(v, t, w), ge(v, o, w), ge(v, i, w), ge(v, l, w);
      for (let b = 0; b < h.length; b += 1)
        h[b] && h[b].m(v, w);
      ge(v, c, w), u = !0, f || (d = [
        De(t, "pointerdown", function() {
          Be(
            /*grab*/
            e[9]("SHAPE")
          ) && e[9]("SHAPE").apply(this, arguments);
        }),
        De(i, "pointerdown", function() {
          Be(
            /*grab*/
            e[9]("SHAPE")
          ) && e[9]("SHAPE").apply(this, arguments);
        })
      ], f = !0);
    },
    p(v, w) {
      if (e = v, (!u || w & /*computedStyle*/
      2 && n !== (n = /*computedStyle*/
      e[1] ? "display:none;" : void 0)) && B(t, "style", n), (!u || w & /*geom*/
      16 && r !== (r = /*geom*/
      e[4].points.map(Si).join(" "))) && B(t, "points", r), (!u || w & /*computedStyle*/
      2) && B(
        i,
        "style",
        /*computedStyle*/
        e[1]
      ), (!u || w & /*geom*/
      16 && s !== (s = /*geom*/
      e[4].points.map(Oi).join(" "))) && B(i, "points", s), w & /*geom, viewportScale, grab*/
      536) {
        p = Ei(
          /*geom*/
          e[4].points
        );
        let b;
        for (b = 0; b < p.length; b += 1) {
          const g = Ai(e, p, b);
          h[b] ? (h[b].p(g, w), qe(h[b], 1)) : (h[b] = Ri(g), h[b].c(), qe(h[b], 1), h[b].m(c.parentNode, c));
        }
        for (fl(), b = p.length; b < h.length; b += 1)
          m(b);
        pl();
      }
    },
    i(v) {
      if (!u) {
        for (let w = 0; w < p.length; w += 1)
          qe(h[w]);
        u = !0;
      }
    },
    o(v) {
      h = h.filter(Boolean);
      for (let w = 0; w < h.length; w += 1)
        st(h[w]);
      u = !1;
    },
    d(v) {
      v && (he(t), he(o), he(i), he(l), he(c)), rl(h, v), f = !1, At(d);
    }
  };
}
function Sl(e) {
  let t, n;
  return t = new Da({
    props: {
      shape: (
        /*shape*/
        e[0]
      ),
      transform: (
        /*transform*/
        e[2]
      ),
      editor: (
        /*editor*/
        e[5]
      ),
      $$slots: {
        default: [
          Rl,
          ({ grab: r }) => ({ 9: r }),
          ({ grab: r }) => r ? 512 : 0
        ]
      },
      $$scope: { ctx: e }
    }
  }), t.$on(
    "change",
    /*change_handler*/
    e[6]
  ), t.$on(
    "grab",
    /*grab_handler*/
    e[7]
  ), t.$on(
    "release",
    /*release_handler*/
    e[8]
  ), {
    c() {
      zt(t.$$.fragment);
    },
    m(r, o) {
      Mt(t, r, o), n = !0;
    },
    p(r, [o]) {
      const i = {};
      o & /*shape*/
      1 && (i.shape = /*shape*/
      r[0]), o & /*transform*/
      4 && (i.transform = /*transform*/
      r[2]), o & /*$$scope, geom, viewportScale, grab, computedStyle*/
      8730 && (i.$$scope = { dirty: o, ctx: r }), t.$set(i);
    },
    i(r) {
      n || (qe(t.$$.fragment, r), n = !0);
    },
    o(r) {
      st(t.$$.fragment, r), n = !1;
    },
    d(r) {
      Ft(t, r);
    }
  };
}
const Si = (e) => e.join(","), Oi = (e) => e.join(",");
function Ol(e, t, n) {
  let r, { shape: o } = t, { computedStyle: i } = t, { transform: s } = t, { viewportScale: l = 1 } = t;
  const c = (p, h, m) => {
    let v;
    const w = p.geometry;
    h === "SHAPE" ? v = w.points.map(([g, x]) => [g + m[0], x + m[1]]) : v = w.points.map(([g, x], R) => h === `HANDLE-${R}` ? [g + m[0], x + m[1]] : [g, x]);
    const b = ml(v);
    return { ...p, geometry: { points: v, bounds: b } };
  };
  function u(p) {
    yt.call(this, e, p);
  }
  function f(p) {
    yt.call(this, e, p);
  }
  function d(p) {
    yt.call(this, e, p);
  }
  return e.$$set = (p) => {
    "shape" in p && n(0, o = p.shape), "computedStyle" in p && n(1, i = p.computedStyle), "transform" in p && n(2, s = p.transform), "viewportScale" in p && n(3, l = p.viewportScale);
  }, e.$$.update = () => {
    e.$$.dirty & /*shape*/
    1 && n(4, r = o.geometry);
  }, [
    o,
    i,
    s,
    l,
    r,
    c,
    u,
    f,
    d
  ];
}
class Tl extends zr {
  constructor(t) {
    super(), Xr(this, t, Ol, Sl, Kr, {
      shape: 0,
      computedStyle: 1,
      transform: 2,
      viewportScale: 3
    });
  }
}
const Cl = typeof window > "u" || typeof navigator > "u" ? !1 : "ontouchstart" in window || navigator.maxTouchPoints > 0 || // @ts-ignore
navigator.msMaxTouchPoints > 0;
function kl(e) {
  let t, n, r, o, i, s;
  return {
    c() {
      t = Ye("rect"), B(t, "class", n = _r(`a9s-handle ${/*$$props*/
      e[8].class || ""}`.trim()) + " svelte-1sgkh33"), B(t, "x", r = /*x*/
      e[0] - /*handleSize*/
      e[5] / 2), B(t, "y", o = /*y*/
      e[1] - /*handleSize*/
      e[5] / 2), B(
        t,
        "width",
        /*handleSize*/
        e[5]
      ), B(
        t,
        "height",
        /*handleSize*/
        e[5]
      );
    },
    m(l, c) {
      ge(l, t, c), i || (s = De(
        t,
        "pointerdown",
        /*pointerdown_handler_2*/
        e[11]
      ), i = !0);
    },
    p(l, c) {
      c & /*$$props*/
      256 && n !== (n = _r(`a9s-handle ${/*$$props*/
      l[8].class || ""}`.trim()) + " svelte-1sgkh33") && B(t, "class", n), c & /*x, handleSize*/
      33 && r !== (r = /*x*/
      l[0] - /*handleSize*/
      l[5] / 2) && B(t, "x", r), c & /*y, handleSize*/
      34 && o !== (o = /*y*/
      l[1] - /*handleSize*/
      l[5] / 2) && B(t, "y", o), c & /*handleSize*/
      32 && B(
        t,
        "width",
        /*handleSize*/
        l[5]
      ), c & /*handleSize*/
      32 && B(
        t,
        "height",
        /*handleSize*/
        l[5]
      );
    },
    d(l) {
      l && he(t), i = !1, s();
    }
  };
}
function $l(e) {
  let t, n, r, o, i, s, l, c, u;
  return {
    c() {
      t = Ye("g"), n = Ye("circle"), o = Ye("rect"), B(
        n,
        "cx",
        /*x*/
        e[0]
      ), B(
        n,
        "cy",
        /*y*/
        e[1]
      ), B(n, "r", r = /*radius*/
      e[3] / /*scale*/
      e[2]), B(n, "class", "a9s-touch-halo svelte-1sgkh33"), bi(
        n,
        "touched",
        /*touched*/
        e[4]
      ), B(o, "class", i = _r(`a9s-handle ${/*$$props*/
      e[8].class || ""}`.trim()) + " svelte-1sgkh33"), B(o, "x", s = /*x*/
      e[0] - /*handleSize*/
      e[5] / 2), B(o, "y", l = /*y*/
      e[1] - /*handleSize*/
      e[5] / 2), B(
        o,
        "width",
        /*handleSize*/
        e[5]
      ), B(
        o,
        "height",
        /*handleSize*/
        e[5]
      ), B(t, "class", "a9s-touch-handle");
    },
    m(f, d) {
      ge(f, t, d), yi(t, n), yi(t, o), c || (u = [
        De(
          n,
          "pointerdown",
          /*pointerdown_handler*/
          e[10]
        ),
        De(
          n,
          "pointerdown",
          /*onPointerDown*/
          e[6]
        ),
        De(
          n,
          "pointerup",
          /*onPointerUp*/
          e[7]
        ),
        De(
          o,
          "pointerdown",
          /*pointerdown_handler_1*/
          e[9]
        ),
        De(
          o,
          "pointerdown",
          /*onPointerDown*/
          e[6]
        ),
        De(
          o,
          "pointerup",
          /*onPointerUp*/
          e[7]
        )
      ], c = !0);
    },
    p(f, d) {
      d & /*x*/
      1 && B(
        n,
        "cx",
        /*x*/
        f[0]
      ), d & /*y*/
      2 && B(
        n,
        "cy",
        /*y*/
        f[1]
      ), d & /*radius, scale*/
      12 && r !== (r = /*radius*/
      f[3] / /*scale*/
      f[2]) && B(n, "r", r), d & /*touched*/
      16 && bi(
        n,
        "touched",
        /*touched*/
        f[4]
      ), d & /*$$props*/
      256 && i !== (i = _r(`a9s-handle ${/*$$props*/
      f[8].class || ""}`.trim()) + " svelte-1sgkh33") && B(o, "class", i), d & /*x, handleSize*/
      33 && s !== (s = /*x*/
      f[0] - /*handleSize*/
      f[5] / 2) && B(o, "x", s), d & /*y, handleSize*/
      34 && l !== (l = /*y*/
      f[1] - /*handleSize*/
      f[5] / 2) && B(o, "y", l), d & /*handleSize*/
      32 && B(
        o,
        "width",
        /*handleSize*/
        f[5]
      ), d & /*handleSize*/
      32 && B(
        o,
        "height",
        /*handleSize*/
        f[5]
      );
    },
    d(f) {
      f && he(t), c = !1, At(u);
    }
  };
}
function _l(e) {
  let t;
  function n(o, i) {
    return Cl ? $l : kl;
  }
  let r = n()(e);
  return {
    c() {
      r.c(), t = La();
    },
    m(o, i) {
      r.m(o, i), ge(o, t, i);
    },
    p(o, [i]) {
      r.p(o, i);
    },
    i: er,
    o: er,
    d(o) {
      o && he(t), r.d(o);
    }
  };
}
function Pl(e, t, n) {
  let r, { x: o } = t, { y: i } = t, { scale: s } = t, { radius: l = 30 } = t, c = !1;
  const u = (m) => {
    m.pointerType === "touch" && n(4, c = !0);
  }, f = () => n(4, c = !1);
  function d(m) {
    yt.call(this, e, m);
  }
  function p(m) {
    yt.call(this, e, m);
  }
  function h(m) {
    yt.call(this, e, m);
  }
  return e.$$set = (m) => {
    n(8, t = Io(Io({}, t), vi(m))), "x" in m && n(0, o = m.x), "y" in m && n(1, i = m.y), "scale" in m && n(2, s = m.scale), "radius" in m && n(3, l = m.radius);
  }, e.$$.update = () => {
    e.$$.dirty & /*scale*/
    4 && n(5, r = 10 / s);
  }, t = vi(t), [
    o,
    i,
    s,
    l,
    c,
    r,
    u,
    f,
    t,
    d,
    p,
    h
  ];
}
let Yn = class extends zr {
  constructor(t) {
    super(), Xr(this, t, Pl, _l, Kr, { x: 0, y: 1, scale: 2, radius: 3 });
  }
};
function jl(e) {
  let t, n, r, o, i, s, l, c, u, f, d, p, h, m, v, w, b, g, x, R, A, P, _, C, M, O, S, $, T, j, L, Y, z, K, W, te, J, ce, Ee, Se, ie, ue, pe;
  return K = new Yn({
    props: {
      class: "a9s-corner-handle-topleft",
      x: (
        /*geom*/
        e[4].x
      ),
      y: (
        /*geom*/
        e[4].y
      ),
      scale: (
        /*viewportScale*/
        e[3]
      )
    }
  }), K.$on("pointerdown", function() {
    Be(
      /*grab*/
      e[9]("TOP_LEFT")
    ) && e[9]("TOP_LEFT").apply(this, arguments);
  }), te = new Yn({
    props: {
      class: "a9s-corner-handle-topright",
      x: (
        /*geom*/
        e[4].x + /*geom*/
        e[4].w
      ),
      y: (
        /*geom*/
        e[4].y
      ),
      scale: (
        /*viewportScale*/
        e[3]
      )
    }
  }), te.$on("pointerdown", function() {
    Be(
      /*grab*/
      e[9]("TOP_RIGHT")
    ) && e[9]("TOP_RIGHT").apply(this, arguments);
  }), ce = new Yn({
    props: {
      class: "a9s-corner-handle-bottomright",
      x: (
        /*geom*/
        e[4].x + /*geom*/
        e[4].w
      ),
      y: (
        /*geom*/
        e[4].y + /*geom*/
        e[4].h
      ),
      scale: (
        /*viewportScale*/
        e[3]
      )
    }
  }), ce.$on("pointerdown", function() {
    Be(
      /*grab*/
      e[9]("BOTTOM_RIGHT")
    ) && e[9]("BOTTOM_RIGHT").apply(this, arguments);
  }), Se = new Yn({
    props: {
      class: "a9s-corner-handle-bottomleft",
      x: (
        /*geom*/
        e[4].x
      ),
      y: (
        /*geom*/
        e[4].y + /*geom*/
        e[4].h
      ),
      scale: (
        /*viewportScale*/
        e[3]
      )
    }
  }), Se.$on("pointerdown", function() {
    Be(
      /*grab*/
      e[9]("BOTTOM_LEFT")
    ) && e[9]("BOTTOM_LEFT").apply(this, arguments);
  }), {
    c() {
      t = Ye("rect"), l = rt(), c = Ye("rect"), h = rt(), m = Ye("rect"), g = rt(), x = Ye("rect"), _ = rt(), C = Ye("rect"), $ = rt(), T = Ye("rect"), z = rt(), zt(K.$$.fragment), W = rt(), zt(te.$$.fragment), J = rt(), zt(ce.$$.fragment), Ee = rt(), zt(Se.$$.fragment), B(t, "class", "a9s-outer"), B(t, "style", n = /*computedStyle*/
      e[1] ? "display:none;" : void 0), B(t, "x", r = /*geom*/
      e[4].x), B(t, "y", o = /*geom*/
      e[4].y), B(t, "width", i = /*geom*/
      e[4].w), B(t, "height", s = /*geom*/
      e[4].h), B(c, "class", "a9s-inner a9s-shape-handle"), B(
        c,
        "style",
        /*computedStyle*/
        e[1]
      ), B(c, "x", u = /*geom*/
      e[4].x), B(c, "y", f = /*geom*/
      e[4].y), B(c, "width", d = /*geom*/
      e[4].w), B(c, "height", p = /*geom*/
      e[4].h), B(m, "class", "a9s-edge-handle a9s-edge-handle-top"), B(m, "x", v = /*geom*/
      e[4].x), B(m, "y", w = /*geom*/
      e[4].y), B(m, "height", 1), B(m, "width", b = /*geom*/
      e[4].w), B(x, "class", "a9s-edge-handle a9s-edge-handle-right"), B(x, "x", R = /*geom*/
      e[4].x + /*geom*/
      e[4].w), B(x, "y", A = /*geom*/
      e[4].y), B(x, "height", P = /*geom*/
      e[4].h), B(x, "width", 1), B(C, "class", "a9s-edge-handle a9s-edge-handle-bottom"), B(C, "x", M = /*geom*/
      e[4].x), B(C, "y", O = /*geom*/
      e[4].y + /*geom*/
      e[4].h), B(C, "height", 1), B(C, "width", S = /*geom*/
      e[4].w), B(T, "class", "a9s-edge-handle a9s-edge-handle-left"), B(T, "x", j = /*geom*/
      e[4].x), B(T, "y", L = /*geom*/
      e[4].y), B(T, "height", Y = /*geom*/
      e[4].h), B(T, "width", 1);
    },
    m(G, H) {
      ge(G, t, H), ge(G, l, H), ge(G, c, H), ge(G, h, H), ge(G, m, H), ge(G, g, H), ge(G, x, H), ge(G, _, H), ge(G, C, H), ge(G, $, H), ge(G, T, H), ge(G, z, H), Mt(K, G, H), ge(G, W, H), Mt(te, G, H), ge(G, J, H), Mt(ce, G, H), ge(G, Ee, H), Mt(Se, G, H), ie = !0, ue || (pe = [
        De(t, "pointerdown", function() {
          Be(
            /*grab*/
            e[9]("SHAPE")
          ) && e[9]("SHAPE").apply(this, arguments);
        }),
        De(c, "pointerdown", function() {
          Be(
            /*grab*/
            e[9]("SHAPE")
          ) && e[9]("SHAPE").apply(this, arguments);
        }),
        De(m, "pointerdown", function() {
          Be(
            /*grab*/
            e[9]("TOP")
          ) && e[9]("TOP").apply(this, arguments);
        }),
        De(x, "pointerdown", function() {
          Be(
            /*grab*/
            e[9]("RIGHT")
          ) && e[9]("RIGHT").apply(this, arguments);
        }),
        De(C, "pointerdown", function() {
          Be(
            /*grab*/
            e[9]("BOTTOM")
          ) && e[9]("BOTTOM").apply(this, arguments);
        }),
        De(T, "pointerdown", function() {
          Be(
            /*grab*/
            e[9]("LEFT")
          ) && e[9]("LEFT").apply(this, arguments);
        })
      ], ue = !0);
    },
    p(G, H) {
      e = G, (!ie || H & /*computedStyle*/
      2 && n !== (n = /*computedStyle*/
      e[1] ? "display:none;" : void 0)) && B(t, "style", n), (!ie || H & /*geom*/
      16 && r !== (r = /*geom*/
      e[4].x)) && B(t, "x", r), (!ie || H & /*geom*/
      16 && o !== (o = /*geom*/
      e[4].y)) && B(t, "y", o), (!ie || H & /*geom*/
      16 && i !== (i = /*geom*/
      e[4].w)) && B(t, "width", i), (!ie || H & /*geom*/
      16 && s !== (s = /*geom*/
      e[4].h)) && B(t, "height", s), (!ie || H & /*computedStyle*/
      2) && B(
        c,
        "style",
        /*computedStyle*/
        e[1]
      ), (!ie || H & /*geom*/
      16 && u !== (u = /*geom*/
      e[4].x)) && B(c, "x", u), (!ie || H & /*geom*/
      16 && f !== (f = /*geom*/
      e[4].y)) && B(c, "y", f), (!ie || H & /*geom*/
      16 && d !== (d = /*geom*/
      e[4].w)) && B(c, "width", d), (!ie || H & /*geom*/
      16 && p !== (p = /*geom*/
      e[4].h)) && B(c, "height", p), (!ie || H & /*geom*/
      16 && v !== (v = /*geom*/
      e[4].x)) && B(m, "x", v), (!ie || H & /*geom*/
      16 && w !== (w = /*geom*/
      e[4].y)) && B(m, "y", w), (!ie || H & /*geom*/
      16 && b !== (b = /*geom*/
      e[4].w)) && B(m, "width", b), (!ie || H & /*geom*/
      16 && R !== (R = /*geom*/
      e[4].x + /*geom*/
      e[4].w)) && B(x, "x", R), (!ie || H & /*geom*/
      16 && A !== (A = /*geom*/
      e[4].y)) && B(x, "y", A), (!ie || H & /*geom*/
      16 && P !== (P = /*geom*/
      e[4].h)) && B(x, "height", P), (!ie || H & /*geom*/
      16 && M !== (M = /*geom*/
      e[4].x)) && B(C, "x", M), (!ie || H & /*geom*/
      16 && O !== (O = /*geom*/
      e[4].y + /*geom*/
      e[4].h)) && B(C, "y", O), (!ie || H & /*geom*/
      16 && S !== (S = /*geom*/
      e[4].w)) && B(C, "width", S), (!ie || H & /*geom*/
      16 && j !== (j = /*geom*/
      e[4].x)) && B(T, "x", j), (!ie || H & /*geom*/
      16 && L !== (L = /*geom*/
      e[4].y)) && B(T, "y", L), (!ie || H & /*geom*/
      16 && Y !== (Y = /*geom*/
      e[4].h)) && B(T, "height", Y);
      const Z = {};
      H & /*geom*/
      16 && (Z.x = /*geom*/
      e[4].x), H & /*geom*/
      16 && (Z.y = /*geom*/
      e[4].y), H & /*viewportScale*/
      8 && (Z.scale = /*viewportScale*/
      e[3]), K.$set(Z);
      const ne = {};
      H & /*geom*/
      16 && (ne.x = /*geom*/
      e[4].x + /*geom*/
      e[4].w), H & /*geom*/
      16 && (ne.y = /*geom*/
      e[4].y), H & /*viewportScale*/
      8 && (ne.scale = /*viewportScale*/
      e[3]), te.$set(ne);
      const Q = {};
      H & /*geom*/
      16 && (Q.x = /*geom*/
      e[4].x + /*geom*/
      e[4].w), H & /*geom*/
      16 && (Q.y = /*geom*/
      e[4].y + /*geom*/
      e[4].h), H & /*viewportScale*/
      8 && (Q.scale = /*viewportScale*/
      e[3]), ce.$set(Q);
      const oe = {};
      H & /*geom*/
      16 && (oe.x = /*geom*/
      e[4].x), H & /*geom*/
      16 && (oe.y = /*geom*/
      e[4].y + /*geom*/
      e[4].h), H & /*viewportScale*/
      8 && (oe.scale = /*viewportScale*/
      e[3]), Se.$set(oe);
    },
    i(G) {
      ie || (qe(K.$$.fragment, G), qe(te.$$.fragment, G), qe(ce.$$.fragment, G), qe(Se.$$.fragment, G), ie = !0);
    },
    o(G) {
      st(K.$$.fragment, G), st(te.$$.fragment, G), st(ce.$$.fragment, G), st(Se.$$.fragment, G), ie = !1;
    },
    d(G) {
      G && (he(t), he(l), he(c), he(h), he(m), he(g), he(x), he(_), he(C), he($), he(T), he(z), he(W), he(J), he(Ee)), Ft(K, G), Ft(te, G), Ft(ce, G), Ft(Se, G), ue = !1, At(pe);
    }
  };
}
function Nl(e) {
  let t, n;
  return t = new Da({
    props: {
      shape: (
        /*shape*/
        e[0]
      ),
      transform: (
        /*transform*/
        e[2]
      ),
      editor: (
        /*editor*/
        e[5]
      ),
      $$slots: {
        default: [
          jl,
          ({ grab: r }) => ({ 9: r }),
          ({ grab: r }) => r ? 512 : 0
        ]
      },
      $$scope: { ctx: e }
    }
  }), t.$on(
    "grab",
    /*grab_handler*/
    e[6]
  ), t.$on(
    "change",
    /*change_handler*/
    e[7]
  ), t.$on(
    "release",
    /*release_handler*/
    e[8]
  ), {
    c() {
      zt(t.$$.fragment);
    },
    m(r, o) {
      Mt(t, r, o), n = !0;
    },
    p(r, [o]) {
      const i = {};
      o & /*shape*/
      1 && (i.shape = /*shape*/
      r[0]), o & /*transform*/
      4 && (i.transform = /*transform*/
      r[2]), o & /*$$scope, geom, viewportScale, grab, computedStyle*/
      1562 && (i.$$scope = { dirty: o, ctx: r }), t.$set(i);
    },
    i(r) {
      n || (qe(t.$$.fragment, r), n = !0);
    },
    o(r) {
      st(t.$$.fragment, r), n = !1;
    },
    d(r) {
      Ft(t, r);
    }
  };
}
function Ll(e, t, n) {
  let r, { shape: o } = t, { computedStyle: i } = t, { transform: s } = t, { viewportScale: l = 1 } = t;
  const c = (p, h, m) => {
    const v = p.geometry.bounds;
    let [w, b] = [v.minX, v.minY], [g, x] = [v.maxX, v.maxY];
    const [R, A] = m;
    if (h === "SHAPE")
      w += R, g += R, b += A, x += A;
    else {
      switch (h) {
        case "TOP":
        case "TOP_LEFT":
        case "TOP_RIGHT": {
          b += A;
          break;
        }
        case "BOTTOM":
        case "BOTTOM_LEFT":
        case "BOTTOM_RIGHT": {
          x += A;
          break;
        }
      }
      switch (h) {
        case "LEFT":
        case "TOP_LEFT":
        case "BOTTOM_LEFT": {
          w += R;
          break;
        }
        case "RIGHT":
        case "TOP_RIGHT":
        case "BOTTOM_RIGHT": {
          g += R;
          break;
        }
      }
    }
    const P = Math.min(w, g), _ = Math.min(b, x), C = Math.abs(g - w), M = Math.abs(x - b);
    return {
      ...p,
      geometry: {
        x: P,
        y: _,
        w: C,
        h: M,
        bounds: {
          minX: P,
          minY: _,
          maxX: P + C,
          maxY: _ + M
        }
      }
    };
  };
  function u(p) {
    yt.call(this, e, p);
  }
  function f(p) {
    yt.call(this, e, p);
  }
  function d(p) {
    yt.call(this, e, p);
  }
  return e.$$set = (p) => {
    "shape" in p && n(0, o = p.shape), "computedStyle" in p && n(1, i = p.computedStyle), "transform" in p && n(2, s = p.transform), "viewportScale" in p && n(3, l = p.viewportScale);
  }, e.$$.update = () => {
    e.$$.dirty & /*shape*/
    1 && n(4, r = o.geometry);
  }, [
    o,
    i,
    s,
    l,
    r,
    c,
    u,
    f,
    d
  ];
}
class Il extends zr {
  constructor(t) {
    super(), Xr(this, t, Ll, Nl, Kr, {
      shape: 0,
      computedStyle: 1,
      transform: 2,
      viewportScale: 3
    });
  }
}
cn.RECTANGLE, cn.POLYGON;
const Dl = (e) => ({}), Ti = (e) => ({ grab: (
  /*onGrab*/
  e[0]
) });
function Ml(e) {
  let t, n, r, o;
  const i = (
    /*#slots*/
    e[7].default
  ), s = Qs(
    i,
    e,
    /*$$scope*/
    e[6],
    Ti
  );
  return {
    c() {
      t = Ye("g"), s && s.c(), B(t, "class", "a9s-annotation selected");
    },
    m(l, c) {
      ge(l, t, c), s && s.m(t, null), n = !0, r || (o = [
        De(
          t,
          "pointerup",
          /*onRelease*/
          e[2]
        ),
        De(
          t,
          "pointermove",
          /*onPointerMove*/
          e[1]
        )
      ], r = !0);
    },
    p(l, [c]) {
      s && s.p && (!n || c & /*$$scope*/
      64) && tl(
        s,
        i,
        l,
        /*$$scope*/
        l[6],
        n ? el(
          i,
          /*$$scope*/
          l[6],
          c,
          Dl
        ) : nl(
          /*$$scope*/
          l[6]
        ),
        Ti
      );
    },
    i(l) {
      n || (qe(s, l), n = !0);
    },
    o(l) {
      st(s, l), n = !1;
    },
    d(l) {
      l && he(t), s && s.d(l), r = !1, At(o);
    }
  };
}
function Fl(e, t, n) {
  let { $$slots: r = {}, $$scope: o } = t;
  const i = sl();
  let { shape: s } = t, { editor: l } = t, { transform: c } = t, u, f, d;
  const p = (v) => (w) => {
    u = v, f = c.elementToImage(w.offsetX, w.offsetY), d = s, w.target.setPointerCapture(w.pointerId), i("grab", w);
  }, h = (v) => {
    if (u) {
      const [w, b] = c.elementToImage(v.offsetX, v.offsetY), g = [w - f[0], b - f[1]];
      n(3, s = l(d, u, g)), i("change", s);
    }
  }, m = (v) => {
    v.target.releasePointerCapture(v.pointerId), u = void 0, d = s, i("release", v);
  };
  return e.$$set = (v) => {
    "shape" in v && n(3, s = v.shape), "editor" in v && n(4, l = v.editor), "transform" in v && n(5, c = v.transform), "$$scope" in v && n(6, o = v.$$scope);
  }, [p, h, m, s, l, c, o, r];
}
let Da = class extends zr {
  constructor(t) {
    super(), Xr(this, t, Fl, Ml, Kr, { shape: 3, editor: 4, transform: 5 });
  }
};
typeof navigator > "u" || navigator.userAgent.indexOf("Mac OS X");
var pr = { exports: {} }, Dn = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Ci;
function Bl() {
  if (Ci) return Dn;
  Ci = 1;
  var e = We, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function s(l, c, u) {
    var f, d = {}, p = null, h = null;
    u !== void 0 && (p = "" + u), c.key !== void 0 && (p = "" + c.key), c.ref !== void 0 && (h = c.ref);
    for (f in c) r.call(c, f) && !i.hasOwnProperty(f) && (d[f] = c[f]);
    if (l && l.defaultProps) for (f in c = l.defaultProps, c) d[f] === void 0 && (d[f] = c[f]);
    return { $$typeof: t, type: l, key: p, ref: h, props: d, _owner: o.current };
  }
  return Dn.Fragment = n, Dn.jsx = s, Dn.jsxs = s, Dn;
}
var Mn = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ki;
function Ul() {
  return ki || (ki = 1, process.env.NODE_ENV !== "production" && function() {
    var e = We, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), l = Symbol.for("react.context"), c = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), f = Symbol.for("react.suspense_list"), d = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), h = Symbol.for("react.offscreen"), m = Symbol.iterator, v = "@@iterator";
    function w(a) {
      if (a === null || typeof a != "object")
        return null;
      var y = m && a[m] || a[v];
      return typeof y == "function" ? y : null;
    }
    var b = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function g(a) {
      {
        for (var y = arguments.length, E = new Array(y > 1 ? y - 1 : 0), k = 1; k < y; k++)
          E[k - 1] = arguments[k];
        x("error", a, E);
      }
    }
    function x(a, y, E) {
      {
        var k = b.ReactDebugCurrentFrame, U = k.getStackAddendum();
        U !== "" && (y += "%s", E = E.concat([U]));
        var V = E.map(function(I) {
          return String(I);
        });
        V.unshift("Warning: " + y), Function.prototype.apply.call(console[a], console, V);
      }
    }
    var R = !1, A = !1, P = !1, _ = !1, C = !1, M;
    M = Symbol.for("react.module.reference");
    function O(a) {
      return !!(typeof a == "string" || typeof a == "function" || a === r || a === i || C || a === o || a === u || a === f || _ || a === h || R || A || P || typeof a == "object" && a !== null && (a.$$typeof === p || a.$$typeof === d || a.$$typeof === s || a.$$typeof === l || a.$$typeof === c || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      a.$$typeof === M || a.getModuleId !== void 0));
    }
    function S(a, y, E) {
      var k = a.displayName;
      if (k)
        return k;
      var U = y.displayName || y.name || "";
      return U !== "" ? E + "(" + U + ")" : E;
    }
    function $(a) {
      return a.displayName || "Context";
    }
    function T(a) {
      if (a == null)
        return null;
      if (typeof a.tag == "number" && g("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof a == "function")
        return a.displayName || a.name || null;
      if (typeof a == "string")
        return a;
      switch (a) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case f:
          return "SuspenseList";
      }
      if (typeof a == "object")
        switch (a.$$typeof) {
          case l:
            var y = a;
            return $(y) + ".Consumer";
          case s:
            var E = a;
            return $(E._context) + ".Provider";
          case c:
            return S(a, a.render, "ForwardRef");
          case d:
            var k = a.displayName || null;
            return k !== null ? k : T(a.type) || "Memo";
          case p: {
            var U = a, V = U._payload, I = U._init;
            try {
              return T(I(V));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var j = Object.assign, L = 0, Y, z, K, W, te, J, ce;
    function Ee() {
    }
    Ee.__reactDisabledLog = !0;
    function Se() {
      {
        if (L === 0) {
          Y = console.log, z = console.info, K = console.warn, W = console.error, te = console.group, J = console.groupCollapsed, ce = console.groupEnd;
          var a = {
            configurable: !0,
            enumerable: !0,
            value: Ee,
            writable: !0
          };
          Object.defineProperties(console, {
            info: a,
            log: a,
            warn: a,
            error: a,
            group: a,
            groupCollapsed: a,
            groupEnd: a
          });
        }
        L++;
      }
    }
    function ie() {
      {
        if (L--, L === 0) {
          var a = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: j({}, a, {
              value: Y
            }),
            info: j({}, a, {
              value: z
            }),
            warn: j({}, a, {
              value: K
            }),
            error: j({}, a, {
              value: W
            }),
            group: j({}, a, {
              value: te
            }),
            groupCollapsed: j({}, a, {
              value: J
            }),
            groupEnd: j({}, a, {
              value: ce
            })
          });
        }
        L < 0 && g("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var ue = b.ReactCurrentDispatcher, pe;
    function G(a, y, E) {
      {
        if (pe === void 0)
          try {
            throw Error();
          } catch (U) {
            var k = U.stack.trim().match(/\n( *(at )?)/);
            pe = k && k[1] || "";
          }
        return `
` + pe + a;
      }
    }
    var H = !1, Z;
    {
      var ne = typeof WeakMap == "function" ? WeakMap : Map;
      Z = new ne();
    }
    function Q(a, y) {
      if (!a || H)
        return "";
      {
        var E = Z.get(a);
        if (E !== void 0)
          return E;
      }
      var k;
      H = !0;
      var U = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var V;
      V = ue.current, ue.current = null, Se();
      try {
        if (y) {
          var I = function() {
            throw Error();
          };
          if (Object.defineProperty(I.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(I, []);
            } catch (re) {
              k = re;
            }
            Reflect.construct(a, [], I);
          } else {
            try {
              I.call();
            } catch (re) {
              k = re;
            }
            a.call(I.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (re) {
            k = re;
          }
          a();
        }
      } catch (re) {
        if (re && k && typeof re.stack == "string") {
          for (var N = re.stack.split(`
`), ee = k.stack.split(`
`), X = N.length - 1, q = ee.length - 1; X >= 1 && q >= 0 && N[X] !== ee[q]; )
            q--;
          for (; X >= 1 && q >= 0; X--, q--)
            if (N[X] !== ee[q]) {
              if (X !== 1 || q !== 1)
                do
                  if (X--, q--, q < 0 || N[X] !== ee[q]) {
                    var se = `
` + N[X].replace(" at new ", " at ");
                    return a.displayName && se.includes("<anonymous>") && (se = se.replace("<anonymous>", a.displayName)), typeof a == "function" && Z.set(a, se), se;
                  }
                while (X >= 1 && q >= 0);
              break;
            }
        }
      } finally {
        H = !1, ue.current = V, ie(), Error.prepareStackTrace = U;
      }
      var Re = a ? a.displayName || a.name : "", ye = Re ? G(Re) : "";
      return typeof a == "function" && Z.set(a, ye), ye;
    }
    function oe(a, y, E) {
      return Q(a, !1);
    }
    function fe(a) {
      var y = a.prototype;
      return !!(y && y.isReactComponent);
    }
    function le(a, y, E) {
      if (a == null)
        return "";
      if (typeof a == "function")
        return Q(a, fe(a));
      if (typeof a == "string")
        return G(a);
      switch (a) {
        case u:
          return G("Suspense");
        case f:
          return G("SuspenseList");
      }
      if (typeof a == "object")
        switch (a.$$typeof) {
          case c:
            return oe(a.render);
          case d:
            return le(a.type, y, E);
          case p: {
            var k = a, U = k._payload, V = k._init;
            try {
              return le(V(U), y, E);
            } catch {
            }
          }
        }
      return "";
    }
    var ae = Object.prototype.hasOwnProperty, Oe = {}, ke = b.ReactDebugCurrentFrame;
    function Te(a) {
      if (a) {
        var y = a._owner, E = le(a.type, a._source, y ? y.type : null);
        ke.setExtraStackFrame(E);
      } else
        ke.setExtraStackFrame(null);
    }
    function at(a, y, E, k, U) {
      {
        var V = Function.call.bind(ae);
        for (var I in a)
          if (V(a, I)) {
            var N = void 0;
            try {
              if (typeof a[I] != "function") {
                var ee = Error((k || "React class") + ": " + E + " type `" + I + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof a[I] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw ee.name = "Invariant Violation", ee;
              }
              N = a[I](y, I, k, E, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (X) {
              N = X;
            }
            N && !(N instanceof Error) && (Te(U), g("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", k || "React class", E, I, typeof N), Te(null)), N instanceof Error && !(N.message in Oe) && (Oe[N.message] = !0, Te(U), g("Failed %s type: %s", E, N.message), Te(null));
          }
      }
    }
    var ze = Array.isArray;
    function Ce(a) {
      return ze(a);
    }
    function St(a) {
      {
        var y = typeof Symbol == "function" && Symbol.toStringTag, E = y && a[Symbol.toStringTag] || a.constructor.name || "Object";
        return E;
      }
    }
    function hn(a) {
      try {
        return Ot(a), !1;
      } catch {
        return !0;
      }
    }
    function Ot(a) {
      return "" + a;
    }
    function Tt(a) {
      if (hn(a))
        return g("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", St(a)), Ot(a);
    }
    var _e = b.ReactCurrentOwner, gn = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Ct, kt, Ze;
    Ze = {};
    function mn(a) {
      if (ae.call(a, "ref")) {
        var y = Object.getOwnPropertyDescriptor(a, "ref").get;
        if (y && y.isReactWarning)
          return !1;
      }
      return a.ref !== void 0;
    }
    function vn(a) {
      if (ae.call(a, "key")) {
        var y = Object.getOwnPropertyDescriptor(a, "key").get;
        if (y && y.isReactWarning)
          return !1;
      }
      return a.key !== void 0;
    }
    function yn(a, y) {
      if (typeof a.ref == "string" && _e.current && y && _e.current.stateNode !== y) {
        var E = T(_e.current.type);
        Ze[E] || (g('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', T(_e.current.type), a.ref), Ze[E] = !0);
      }
    }
    function bn(a, y) {
      {
        var E = function() {
          Ct || (Ct = !0, g("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", y));
        };
        E.isReactWarning = !0, Object.defineProperty(a, "key", {
          get: E,
          configurable: !0
        });
      }
    }
    function wn(a, y) {
      {
        var E = function() {
          kt || (kt = !0, g("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", y));
        };
        E.isReactWarning = !0, Object.defineProperty(a, "ref", {
          get: E,
          configurable: !0
        });
      }
    }
    var xn = function(a, y, E, k, U, V, I) {
      var N = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: a,
        key: y,
        ref: E,
        props: I,
        // Record the component responsible for creating this element.
        _owner: V
      };
      return N._store = {}, Object.defineProperty(N._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(N, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: k
      }), Object.defineProperty(N, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: U
      }), Object.freeze && (Object.freeze(N.props), Object.freeze(N)), N;
    };
    function En(a, y, E, k, U) {
      {
        var V, I = {}, N = null, ee = null;
        E !== void 0 && (Tt(E), N = "" + E), vn(y) && (Tt(y.key), N = "" + y.key), mn(y) && (ee = y.ref, yn(y, U));
        for (V in y)
          ae.call(y, V) && !gn.hasOwnProperty(V) && (I[V] = y[V]);
        if (a && a.defaultProps) {
          var X = a.defaultProps;
          for (V in X)
            I[V] === void 0 && (I[V] = X[V]);
        }
        if (N || ee) {
          var q = typeof a == "function" ? a.displayName || a.name || "Unknown" : a;
          N && bn(I, q), ee && wn(I, q);
        }
        return xn(a, N, ee, U, k, _e.current, I);
      }
    }
    var Qe = b.ReactCurrentOwner, $t = b.ReactDebugCurrentFrame;
    function Ae(a) {
      if (a) {
        var y = a._owner, E = le(a.type, a._source, y ? y.type : null);
        $t.setExtraStackFrame(E);
      } else
        $t.setExtraStackFrame(null);
    }
    var et;
    et = !1;
    function tt(a) {
      return typeof a == "object" && a !== null && a.$$typeof === t;
    }
    function _t() {
      {
        if (Qe.current) {
          var a = T(Qe.current.type);
          if (a)
            return `

Check the render method of \`` + a + "`.";
        }
        return "";
      }
    }
    function An(a) {
      return "";
    }
    var Pt = {};
    function Rn(a) {
      {
        var y = _t();
        if (!y) {
          var E = typeof a == "string" ? a : a.displayName || a.name;
          E && (y = `

Check the top-level render call using <` + E + ">.");
        }
        return y;
      }
    }
    function jt(a, y) {
      {
        if (!a._store || a._store.validated || a.key != null)
          return;
        a._store.validated = !0;
        var E = Rn(y);
        if (Pt[E])
          return;
        Pt[E] = !0;
        var k = "";
        a && a._owner && a._owner !== Qe.current && (k = " It was passed a child from " + T(a._owner.type) + "."), Ae(a), g('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', E, k), Ae(null);
      }
    }
    function Nt(a, y) {
      {
        if (typeof a != "object")
          return;
        if (Ce(a))
          for (var E = 0; E < a.length; E++) {
            var k = a[E];
            tt(k) && jt(k, y);
          }
        else if (tt(a))
          a._store && (a._store.validated = !0);
        else if (a) {
          var U = w(a);
          if (typeof U == "function" && U !== a.entries)
            for (var V = U.call(a), I; !(I = V.next()).done; )
              tt(I.value) && jt(I.value, y);
        }
      }
    }
    function Sn(a) {
      {
        var y = a.type;
        if (y == null || typeof y == "string")
          return;
        var E;
        if (typeof y == "function")
          E = y.propTypes;
        else if (typeof y == "object" && (y.$$typeof === c || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        y.$$typeof === d))
          E = y.propTypes;
        else
          return;
        if (E) {
          var k = T(y);
          at(E, a.props, "prop", k, a);
        } else if (y.PropTypes !== void 0 && !et) {
          et = !0;
          var U = T(y);
          g("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", U || "Unknown");
        }
        typeof y.getDefaultProps == "function" && !y.getDefaultProps.isReactClassApproved && g("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function On(a) {
      {
        for (var y = Object.keys(a.props), E = 0; E < y.length; E++) {
          var k = y[E];
          if (k !== "children" && k !== "key") {
            Ae(a), g("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", k), Ae(null);
            break;
          }
        }
        a.ref !== null && (Ae(a), g("Invalid attribute `ref` supplied to `React.Fragment`."), Ae(null));
      }
    }
    var Lt = {};
    function It(a, y, E, k, U, V) {
      {
        var I = O(a);
        if (!I) {
          var N = "";
          (a === void 0 || typeof a == "object" && a !== null && Object.keys(a).length === 0) && (N += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var ee = An();
          ee ? N += ee : N += _t();
          var X;
          a === null ? X = "null" : Ce(a) ? X = "array" : a !== void 0 && a.$$typeof === t ? (X = "<" + (T(a.type) || "Unknown") + " />", N = " Did you accidentally export a JSX literal instead of a component?") : X = typeof a, g("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", X, N);
        }
        var q = En(a, y, E, U, V);
        if (q == null)
          return q;
        if (I) {
          var se = y.children;
          if (se !== void 0)
            if (k)
              if (Ce(se)) {
                for (var Re = 0; Re < se.length; Re++)
                  Nt(se[Re], a);
                Object.freeze && Object.freeze(se);
              } else
                g("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Nt(se, a);
        }
        if (ae.call(y, "key")) {
          var ye = T(a), re = Object.keys(y).filter(function(Pn) {
            return Pn !== "key";
          }), nt = re.length > 0 ? "{key: someKey, " + re.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Lt[ye + nt]) {
            var _n = re.length > 0 ? "{" + re.join(": ..., ") + ": ...}" : "{}";
            g(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, nt, ye, _n, ye), Lt[ye + nt] = !0;
          }
        }
        return a === r ? On(q) : Sn(q), q;
      }
    }
    function Tn(a, y, E) {
      return It(a, y, E, !0);
    }
    function Cn(a, y, E) {
      return It(a, y, E, !1);
    }
    var kn = Cn, $n = Tn;
    Mn.Fragment = r, Mn.jsx = kn, Mn.jsxs = $n;
  }()), Mn;
}
var $i;
function Vl() {
  return $i || ($i = 1, process.env.NODE_ENV === "production" ? pr.exports = Bl() : pr.exports = Ul()), pr.exports;
}
var vt = Vl();
const Yl = {
  namespaces: {
    tei: "http://www.tei-c.org/ns/1.0",
    teieg: "http://www.tei-c.org/ns/Examples",
    rng: "http://relaxng.org/ns/structure/1.0"
  },
  tei: {
    eg: ["<pre>", "</pre>"],
    // inserts a link inside <ptr> using the @target; the link in the
    // @href is piped through the rw (rewrite) function before insertion
    ptr: ['<a href="$rw@target">$@target</a>'],
    // wraps the content of the <ref> in an HTML link with the @target in 
    // the @href. If there are multiple @targets, only the first is used.
    ref: [
      ["[target]", ['<a href="$rw@target">', "</a>"]]
    ],
    // creates an img tag with the @url as the src attribute
    graphic: function(e) {
      let t = new Image();
      return t.src = this.rw(e.getAttribute("url")), e.hasAttribute("width") && t.setAttribute("width", e.getAttribute("width")), e.hasAttribute("height") && t.setAttribute("height", e.getAttribute("height")), t;
    },
    list: [
      // will only run on a list where @type="gloss"
      [
        "[type=gloss]",
        function(e) {
          const t = e.ownerDocument;
          let n = t.createElement("dl");
          for (let r of Array.from(e.children))
            if (r.nodeType == 1) {
              if (r.localName == "tei-label") {
                let o = t.createElement("dt");
                o.innerHTML = r.innerHTML, n.appendChild(o);
              }
              if (r.localName == "tei-item") {
                let o = t.createElement("dd");
                o.innerHTML = r.innerHTML, n.appendChild(o);
              }
            }
          return n;
        }
      ]
    ],
    note: [
      // Make endnotes
      ["[place=end]", function(e) {
        const t = e.ownerDocument;
        this.noteIndex ? this.noteIndex++ : this.noteIndex = 1;
        let n = "_note_" + this.noteIndex, r = t.createElement("a");
        r.setAttribute("id", "src" + n), r.setAttribute("href", "#" + n), r.innerHTML = this.noteIndex;
        let o = t.createElement("sup");
        o.appendChild(r);
        let i = t.querySelector("ol.notes");
        i || (i = t.createElement("ol"), i.setAttribute("class", "notes"), this.dom.appendChild(i));
        let s = t.createElement("li");
        return s.id = n, s.innerHTML = e.innerHTML, i.appendChild(s), o;
      }],
      ["_", ["(", ")"]]
    ],
    // Hide the teiHeader by default
    teiHeader: function(e) {
      this.hideContent(e, !1);
    },
    // Make the title element the HTML title
    title: [
      ["tei-titlestmt>tei-title", function(e) {
        const t = e.ownerDocument;
        let n = t.createElement("title");
        n.innerHTML = e.innerText, t.querySelector("head").appendChild(n);
      }]
    ]
  },
  teieg: {
    egXML: function(e) {
      const t = e.ownerDocument;
      let n = t.createElement("pre"), r = t.createElement("code");
      n.appendChild(r);
      let o = this.serialize(e, !0).replace(/</g, "&lt;"), i = o.match(/^[\t ]+/);
      return i && (o = o.replace(new RegExp("^" + i[0], "mg"), "")), r.innerHTML = o, n;
    }
  }
};
function Hl(e, t) {
  let n = 1, r = e;
  for (; r && r.previousElementSibling !== null && (!t || r.previousElementSibling.localName == t) && (n++, r = r.previousElementSibling, !!r.previousElementSibling); )
    ;
  return n;
}
function Ma(e) {
  const t = e.ownerDocument;
  let n = (r) => {
    let o;
    switch (r.nodeType) {
      case 1:
        o = t.createElement(r.nodeName);
        break;
      case 9:
        o = t.implementation.createDocument();
        break;
      case 11:
        o = t.createDocumentFragment();
        break;
      default:
        o = r.cloneNode(!0);
    }
    if (r.attributes)
      for (let i of Array.from(r.attributes))
        i.name !== "data-processed" && o.setAttribute(i.name, i.value);
    for (let i of Array.from(r.childNodes))
      if (i.nodeType == 1)
        if (i.hasAttribute("data-original")) {
          for (let s of Array.from(i.childNodes)) {
            let l = o.appendChild(n(s));
            l.nodeType === 1 && l.hasAttribute("data-origid") && (l.setAttribute("id", l.getAttribute("data-origid")), l.removeAttribute("data-origid"));
          }
          return o;
        } else i.hasAttribute("data-origname") && o.appendChild(n(i));
      else
        o.appendChild(i.cloneNode());
    return o;
  };
  return n(e);
}
function Fa(e) {
  return e.replace(/ .*$/, "");
}
function Ba(e, t = !0) {
  const n = e.ownerDocument;
  if (e.childNodes.length > 0) {
    let r = n.createElement("cetei-original");
    e.appendChild(r), r.setAttribute("hidden", ""), r.setAttribute("data-original", "");
    for (let o of Array.from(e.childNodes))
      if (o !== r) {
        if (o.nodeType === 1) {
          o.setAttribute("data-processed", "");
          for (let i of o.querySelectorAll("*"))
            i.setAttribute("data-processed", "");
        }
        r.appendChild(e.removeChild(o));
      }
    if (t)
      for (let o of Array.from(r.querySelectorAll("*")))
        o.hasAttribute("id") && (o.setAttribute("data-origid", o.getAttribute("id")), o.removeAttribute("id"));
  }
}
function Wl(e) {
  return this.rw(this.first(e));
}
function Kl(e, t) {
  let n = "";
  for (let r = 0; r < t; r++)
    n += e;
  return n;
}
function Xl(e) {
  let t = this.prefixDefs[e.substring(0, e.indexOf(":"))];
  return e.replace(new RegExp(t.matchPattern), t.replacementPattern);
}
function zl(e) {
  return this.prefixDefs[e];
}
function ql(e) {
  return e.match(/^(?:http|mailto|file|\/|#).*$/) ? e : this.base + Fa(e);
}
function Gl(e, t, n) {
  return Pr(Ma(e), t, n);
}
function Pr(e, t, n) {
  let r = "";
  const o = (i) => !/[^\t\n\r ]/.test(i);
  if ((e.nodeType === 9 || e.nodeType === 11) && (r += `<?xml version="1.0" encoding="UTF-8"?>
`), !t && e.nodeType == 1) {
    typeof n == "string" && n !== "" ? r += `
` + n + "<" : r += "<", r += e.getAttribute("data-origname");
    let i = e.hasAttribute("data-origatts") ? e.getAttribute("data-origatts").split(" ") : [];
    for (let s of Array.from(e.attributes))
      !s.name.startsWith("data-") && !["id", "lang", "class"].includes(s.name) && (r += " " + i.find(function(l) {
        return l.toLowerCase() == s.name;
      }) + '="' + s.value + '"'), s.name == "data-xmlns" && (r += ' xmlns="' + s.value + '"');
    e.childNodes.length > 0 ? r += ">" : r += "/>";
  }
  for (let i of Array.from(e.childNodes))
    switch (i.nodeType) {
      case 1:
        typeof n == "string" ? r += Pr(i, !1, n + "  ") : r += Pr(i, !1, n);
        break;
      case 7:
        r += `<?${i.nodeName} ${i.nodeValue}?>`, (e.nodeType === 9 || e.nodeType === 11) && (r += `
`);
        break;
      case 8:
        r += `<!--${i.nodeValue}-->`, (e.nodeType === 9 || e.nodeType === 11) && (r += `
`);
        break;
      default:
        if (t && o(i.nodeValue) && (r += i.nodeValue.replace(/^\s*\n/, "")), typeof n == "string" && o(i.nodeValue))
          break;
        r += i.nodeValue;
    }
  return !t && e.nodeType == 1 && e.childNodes.length > 0 && (typeof n == "string" ? r += `
` + n + "</" : r += "</", r += e.getAttribute("data-origname") + ">"), (e.nodeType === 9 || e.nodeType === 11) && (r += `
`), r;
}
function Fo(e, t, n) {
  const r = ["area", "base", "br", "col", "embed", "hr", "img", "input", "link", "meta", "param", "source", "track", "wbr"];
  let o = "";
  const i = (s) => !/[^\t\n\r ]/.test(s);
  if (!t && e.nodeType == 1) {
    typeof n == "string" && n !== "" ? o += `
` + n + "<" : o += "<", o += e.nodeName;
    for (let s of Array.from(e.attributes))
      o += " " + s.name + '="' + s.value + '"';
    o += ">";
  }
  for (let s of Array.from(e.childNodes))
    switch (s.nodeType) {
      case 1:
        typeof n == "string" ? o += Fo(s, !1, n + "  ") : o += Fo(s, !1, n);
        break;
      case 7:
        o += `<?${s.nodeName} ${s.nodeValue}?>`, (e.nodeType === 9 || e.nodeType === 11) && (o += `
`);
        break;
      case 8:
        o += `<!--${s.nodeValue}-->`, (e.nodeType === 9 || e.nodeType === 11) && (o += `
`);
        break;
      default:
        if (t && i(s.nodeValue) && (o += s.nodeValue.replace(/^\s*\n/, "")), typeof n == "string" && i(s.nodeValue))
          break;
        o += s.nodeValue.replace(/</g, "&lt;");
    }
  return r.includes(e.nodeName) || !t && e.nodeType == 1 && (typeof n == "string" ? o += `
${n}</` : o += "</", o += `${e.nodeName}>`), (e.nodeType === 9 || e.nodeType === 11) && (o += `
`), o;
}
function Jl(e) {
  return e.replace(/&gt;/, ">").replace(/&quot;/, '"').replace(/&apos;/, "'").replace(/&amp;/, "&");
}
function jr(e) {
  return e.includes(":"), e.replace(/:/, "-").toLowerCase();
}
function Ua(e, t = null, n = !1) {
  try {
    window.customElements.define(jr(e), class extends HTMLElement {
      constructor() {
        super(), this.matches(":defined") || t && (t.call(this), this.setAttribute("data-processed", ""));
      }
      // Process new elements when they are connected to the browser DOM
      connectedCallback() {
        this.hasAttribute("data-processed") || t && (t.call(this), this.setAttribute("data-processed", ""));
      }
    });
  } catch (r) {
    n && (console.log(jr(e) + " couldn't be registered or is already registered."), console.log(r));
  }
}
const oo = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  copyAndReset: Ma,
  defineCustomElement: Ua,
  first: Fa,
  getOrdinality: Hl,
  getPrefixDef: zl,
  hideContent: Ba,
  normalizeURI: Wl,
  repeat: Kl,
  resetAndSerialize: Gl,
  resolveURI: Xl,
  rw: ql,
  serialize: Pr,
  serializeHTML: Fo,
  tagName: jr,
  unEscapeEntities: Jl
}, Symbol.toStringTag, { value: "Module" }));
function Zl(e) {
  if (e.namespaces)
    for (let t of Object.keys(e.namespaces))
      !this.namespaces.has(e.namespaces[t]) && !Array.from(this.namespaces.values()).includes(t) && this.namespaces.set(e.namespaces[t], t);
  for (let t of this.namespaces.values())
    if (e[t])
      for (let n of Object.keys(e[t]))
        this.behaviors[`${t}:${n}`] = e[t][n];
  if (e.functions)
    for (let t of Object.keys(e.functions))
      this.utilities[t] = e.functions[t].bind(this.utilities);
  e.handlers && console.log("Behavior handlers are no longer used."), e.fallbacks && console.log("Fallback behaviors are no longer used.");
}
function Ql(e, t, n) {
  let r;
  if (e === Object(e))
    for (let o of Object.keys(e))
      this.namespaces.has(e[o]) || (this.namespaces.set(e[o], o), r = o);
  else
    r = e;
  this.behaviors[`${r}:${t}`] = n;
}
function ec(e, t) {
  let n;
  if (e === Object(e))
    for (let r of Object.keys(e))
      this.namespaces.has(e[r]) || (this.namespaces.set(e[r], r), n = r);
  else
    n = e;
  delete this.behaviors[`${n}:${t}`];
}
function tc(e, t) {
  const n = e.documentElement;
  let r = 1, o = function(s) {
    return t.has(s.namespaceURI ? s.namespaceURI : "") || t.set(s.namespaceURI, "ns" + r++), t.get(s.namespaceURI ? s.namespaceURI : "") + ":" + s.localName;
  };
  const i = new Set(
    Array.from(n.querySelectorAll("*"), o)
  );
  return i.add(o(n)), i;
}
function nc(e) {
  return new Set(Array.from(e.querySelectorAll("*[data-origname]"), (t) => t.localName.replace(/(\w+)-.+/, "$1:") + t.getAttribute("data-origname")));
}
class sn {
  constructor(t) {
    this.options = t || {}, this.document = this.options.documentObject ? this.options.documentObject : void 0, this.document === void 0 && (typeof window < "u" && window.document ? this.document = window.document : typeof global < "u" && global.document && (this.document = global.document)), this.addBehaviors = Zl.bind(this), this.addBehavior = Ql.bind(this), this.removeBehavior = ec.bind(this), this.utilities = {};
    for (const n of Object.keys(oo))
      ["getPrefixDef", "rw", "resolveURI"].includes(n) ? this.utilities[n] = oo[n].bind(this) : this.utilities[n] = oo[n];
    if (this.els = [], this.namespaces = /* @__PURE__ */ new Map(), this.behaviors = {}, this.hasStyle = !1, this.prefixDefs = [], this.debug = this.options.debug === !0, this.discardContent = this.options.discardContent === !0, this.options.base)
      this.base = this.options.base;
    else
      try {
        window && (this.base = window.location.href.replace(/\/[^\/]*$/, "/"));
      } catch {
        this.base = "";
      }
    this.options.omitDefaultBehaviors || this.addBehaviors(Yl), this.options.ignoreFragmentId && window && window.removeEventListener("ceteiceanload", sn.restorePosition);
  }
  /* 
    Returns a Promise that fetches an XML source document from the URL
    provided in the first parameter and then calls the makeHTML5 method
    on the returned document.
  */
  async getHTML5(t, n, r) {
    window && window.location.href.startsWith(this.base) && t.indexOf("/") >= 0 && (this.base = t.replace(/\/[^\/]*$/, "/"));
    try {
      const o = await fetch(t);
      if (o.ok) {
        const i = await o.text();
        return this.makeHTML5(i, n, r);
      } else
        console.log(`Could not get XML file ${t}.
Server returned ${o.status}: ${o.statusText}`);
    } catch (o) {
      console.log(o);
    }
  }
  /* 
    Converts the supplied XML string into HTML5 Custom Elements. If a callback
    function is supplied, calls it on the result.
  */
  makeHTML5(t, n, r) {
    return this.XML_dom = new DOMParser().parseFromString(t, "text/xml"), this.domToHTML5(this.XML_dom, n, r);
  }
  preprocess(t, n, r) {
    this.els = tc(t, this.namespaces);
    let o = (i) => {
      let s;
      if (this.namespaces.has(i.namespaceURI ? i.namespaceURI : "")) {
        let l = this.namespaces.get(i.namespaceURI ? i.namespaceURI : "");
        s = this.document.createElement(`${l}-${i.localName.toLowerCase()}`);
      } else
        s = this.document.importNode(i, !1);
      for (let l of Array.from(i.attributes))
        l.name == "xmlns" ? s.setAttribute("data-xmlns", l.value) : s.setAttribute(l.name, l.value), l.name == "xml:id" && s.setAttribute("id", l.value), l.name == "xml:lang" && s.setAttribute("lang", l.value), l.name == "rendition" && s.setAttribute("class", l.value.replace(/#/g, ""));
      if (s.setAttribute("data-origname", i.localName), i.hasAttributes() && s.setAttribute("data-origatts", i.getAttributeNames().join(" ")), i.childNodes.length == 0 && s.setAttribute("data-empty", ""), i.localName == "head") {
        let l = t.evaluate("count(ancestor::*[tei:head])", i, function(c) {
          if (c == "tei") return "http://www.tei-c.org/ns/1.0";
        }, 1, null);
        s.setAttribute("data-level", l.numberValue);
      }
      if (i.localName == "tagsDecl") {
        let l = this.document.createElement("style");
        for (let c of Array.from(i.childNodes))
          if (c.nodeType == 1 && c.localName == "rendition" && c.getAttribute("scheme") == "css") {
            let u = "";
            c.hasAttribute("selector") ? (u += c.getAttribute("selector").replace(/([^#, >]+\w*)/g, "tei-$1").replace(/#tei-/g, "#") + `{
`, u += c.textContent) : (u += "." + c.getAttribute("xml:id") + `{
`, u += c.textContent), u += `
}
`, l.appendChild(this.document.createTextNode(u));
          }
        l.childNodes.length > 0 && (s.appendChild(l), this.hasStyle = !0);
      }
      i.localName == "prefixDef" && (this.prefixDefs.push(i.getAttribute("ident")), this.prefixDefs[i.getAttribute("ident")] = {
        matchPattern: i.getAttribute("matchPattern"),
        replacementPattern: i.getAttribute("replacementPattern")
      });
      for (let l of Array.from(i.childNodes))
        l.nodeType == 1 ? s.appendChild(o(l)) : s.appendChild(l.cloneNode());
      return r && r(s, i), s;
    };
    this.dom = this.document.createDocumentFragment();
    for (let i of Array.from(t.childNodes))
      i.nodeType == 1 && this.dom.appendChild(o(i)), i.nodeType == 7 && this.dom.appendChild(this.document.importNode(i, !0)), i.nodeType == 8 && this.dom.appendChild(this.document.importNode(i, !0));
    if (this.utilities.dom = this.dom.firstElementChild, n)
      n(this.dom, this), window && window.dispatchEvent(Fn);
    else
      return typeof window < "u" && window.dispatchEvent(Fn), this.dom;
  }
  /* 
    Converts the supplied XML DOM into HTML5 Custom Elements. If a callback
    function is supplied, calls it on the result.
  */
  domToHTML5(t, n, r) {
    if (this.preprocess(t, null, r), this.applyBehaviors(), this.done = !0, n)
      n(this.dom, this), window && window.dispatchEvent(Fn);
    else
      return typeof window < "u" && window.dispatchEvent(Fn), this.dom;
  }
  /*
    Convenience method for HTML pages containing pre-processed CETEIcean Custom 
    Elements. Usage:
      const c = new CETEI();
      c.processPage();
  */
  processPage() {
    this.els = nc(this.document), this.applyBehaviors(), window && window.dispatchEvent(Fn);
  }
  /* 
    To change a namespace -> prefix mapping, the namespace must first be 
    unset. Takes a namespace URI. In order to process a TEI P4 document, e.g.,
    the TEI namespace must be unset before it can be set to the empty string.
  */
  unsetNamespace(t) {
    this.namespaces.delete(t);
  }
  /* 
    Sets the base URL for the document. Used to rewrite relative links in the
    XML source (which may be in a completely different location from the HTML
    wrapper).
  */
  setBaseUrl(t) {
    this.base = t;
  }
  /* 
    Appends any element returned by the function passed in the first
    parameter to the element in the second parameter. If the function
    returns nothing, this is a no-op aside from any side effects caused
    by the provided function.
  
    Called by getHandler() and fallback()
    */
  append(t, n) {
    let r = this;
    if (n && !n.hasAttribute("data-processed")) {
      let o = t.call(r.utilities, n);
      o && r.appendBasic(n, o);
    } else
      return function() {
        if (!this.hasAttribute("data-processed")) {
          let o = t.call(r.utilities, this);
          o && r.appendBasic(this, o);
        }
      };
  }
  appendBasic(t, n) {
    this.discardContent ? t.innerHTML = "" : Ba(t, !0), t.appendChild(n);
  }
  // Given an element, return its qualified name as defined in a behaviors object
  bName(t) {
    return t.tagName.substring(0, t.tagName.indexOf("-")).toLowerCase() + ":" + t.getAttribute("data-origname");
  }
  /* 
    Private method called by append(). Takes a child element and a name, and recurses through the
    child's siblings until an element with that name is found, returning true if it is and false if not.
  */
  childExists(t, n) {
    return t && t.nodeName == n ? !0 : t && t.nextElementSibling && this.childExists(t.nextElementSibling, n);
  }
  /* 
    Takes a template in the form of either an array of 1 or 2 
    strings or an object with CSS selector keys and either functions
    or arrays as described above. Returns a closure around a function 
    that can be called in the element constructor or applied to an 
    individual element. An empty array is considered a no-op.
  
    Called by the getHandler() and getFallback() methods
  */
  decorator(t) {
    if (Array.isArray(t) && t.length == 0)
      return function(r) {
      };
    if (Array.isArray(t) && !Array.isArray(t[0]))
      return this.applyDecorator(t);
    let n = this;
    return function(r) {
      for (let o of t)
        if (r.matches(o[0]) || o[0] === "_")
          return Array.isArray(o[1]) ? n.decorator(o[1]).call(this, r) : o[1].call(this, r);
    };
  }
  applyDecorator(t) {
    let n = this;
    return function(r) {
      let o = [];
      for (let i = 0; i < t.length; i++)
        o.push(n.template(t[i], r));
      return n.insert(r, o);
    };
  }
  /* 
    Returns the fallback function for the given element name.
    Called by fallback().
  */
  getFallback(t, n) {
    if (t[n])
      return t[n] instanceof Function ? t[n] : this.decorator(t[n]);
  }
  /* 
    Returns the handler function for the given element name
    Called by define().
  */
  getHandler(t, n) {
    if (t[n])
      return t[n] instanceof Function ? this.append(t[n]) : this.append(this.decorator(t[n]));
  }
  insert(t, n) {
    let r = this.document.createElement("cetei-content");
    for (let o of Array.from(t.childNodes))
      o.nodeType === 1 && !o.hasAttribute("data-processed") && this.processElement(o);
    if (n[0].match("<[^>]+>") && n[1] && n[1].match("<[^>]+>"))
      r.innerHTML = n[0] + t.innerHTML + (n[1] ? n[1] : "");
    else {
      r.innerHTML = n[0], r.setAttribute("data-before", n[0].replace(/<[^>]+>/g, "").length);
      for (let o of Array.from(t.childNodes))
        r.appendChild(o.cloneNode(!0));
      n.length > 1 && (r.innerHTML += n[1], r.setAttribute("data-after", n[1].replace(/<[^>]+>/g, "").length));
    }
    return r.childNodes.length < 2 ? r.firstChild : r;
  }
  // Runs behaviors recursively on the supplied element and children
  processElement(t) {
    if (t.hasAttribute("data-origname") && !t.hasAttribute("data-processed")) {
      let n = this.getFallback(this.bName(t));
      n && (this.append(n, t), t.setAttribute("data-processed", ""));
    }
    for (let n of Array.from(t.childNodes))
      n.nodeType === 1 && this.processElement(n);
  }
  template(t, n) {
    let r = t;
    if (t.search(/\$(\w*)(@([a-zA-Z:]+))/)) {
      let o = /\$(\w*)@([a-zA-Z:]+)/g, i;
      for (; i = o.exec(t); )
        n.hasAttribute(i[2]) ? i[1] && this.utilities[i[1]] ? r = r.replace(i[0], this.utilities[i[1]](n.getAttribute(i[2]))) : r = r.replace(i[0], n.getAttribute(i[2])) : r = r.replace(i[0], "");
    }
    return r;
  }
  // Define or apply behaviors for the document
  applyBehaviors() {
    typeof window < "u" && window.customElements ? this.define.call(this, this.els) : this.fallback.call(this, this.els);
  }
  /* 
    Registers the list of elements provided with the browser.
    Called by makeHTML5(), but can be called independently if, for example,
    you've created Custom Elements via an XSLT transformation instead.
  */
  define(t) {
    for (let n of t) {
      const r = this.getHandler(this.behaviors, n);
      Ua(n, r, this.debug);
    }
  }
  /* 
    Provides fallback functionality for environments where Custom Elements
    are not supported.
  
    Like define(), this is called by makeHTML5(), but can be called
    independently.
  */
  fallback(t) {
    for (let n of t) {
      let r = this.getFallback(this.behaviors, n);
      if (r)
        for (let o of Array.from((this.dom && !this.done ? this.dom : this.document).querySelectorAll(jr(n))))
          o.hasAttribute("data-processed") || (this.append(r, o), o.setAttribute("data-processed", ""));
    }
  }
  /**********************
   * Utility functions  *
   **********************/
  static savePosition() {
    window.sessionStorage.setItem(window.location + "-scroll", window.scrollY);
  }
  static restorePosition() {
    if (window.location.hash)
      setTimeout(function() {
        let t = this.document.querySelector(window.decodeURI(window.location.hash));
        t && t.scrollIntoView();
      }, 100);
    else {
      let t;
      (t = window.sessionStorage.getItem(window.location + "-scroll")) && (window.sessionStorage.removeItem(window.location + "-scroll"), setTimeout(function() {
        window.scrollTo(0, t);
      }, 100));
    }
  }
}
try {
  if (typeof window < "u") {
    window.CETEI = sn, window.addEventListener("beforeunload", sn.savePosition);
    var Fn = new Event("ceteiceanload");
    window.addEventListener("ceteiceanload", sn.restorePosition);
  }
} catch (e) {
  console.log(e);
}
const _i = {
  tei: {
    ref: (e) => {
      const t = document.createElement("a");
      for (; e.firstChild; )
        t.appendChild(e.removeChild(e.firstChild));
      t.setAttribute("href", e.getAttribute("target")), e.appendChild(t);
    },
    // Cf. https://github.com/TEIC/CETEIcean/issues/67
    graphic: (e) => {
      var t;
      const n = new Image();
      n.src = (t = e.getAttribute("url")) == null ? void 0 : t.trim(), e.hasAttribute("width") && n.setAttribute("width", e.getAttribute("width")), e.hasAttribute("height") && n.setAttribute("height", e.getAttribute("height")), e.appendChild(n);
    },
    list: null,
    note: null,
    table: null,
    teiHeader: (e) => {
      e.hidden = !0;
    }
  }
}, rc = (e) => {
  const t = Go(null);
  return Fe(() => {
    var n;
    if (e.tei) {
      const r = new sn(e.initArgs);
      r.addBehaviors({
        ..._i,
        ...e.behaviors || {},
        tei: {
          ..._i.tei,
          ...((n = e.behaviors) == null ? void 0 : n.tei) || {}
        }
      }), r.makeHTML5(e.tei, (o) => {
        t.current.appendChild(o), e.onLoad(t.current);
      });
    }
    return () => {
      t.current.innerHTML = "";
    };
  }, [e.tei, JSON.stringify(e.initArgs), e.onLoad]), /* @__PURE__ */ vt.jsx(
    "div",
    {
      ref: t,
      className: "tei-container"
    }
  );
}, oc = "not-annotatable", Va = `.${oc}`;
/mac/i.test(navigator.userAgentData ? navigator.userAgentData.platform : navigator.platform);
const ic = (e) => {
  const t = e.cloneContents();
  return t.querySelectorAll(Va).forEach((n) => n.remove()), t;
}, ac = (e) => e.every((t) => t.range instanceof Range && !t.range.collapsed), sc = (e, t, n) => {
  const r = document.createRange(), o = t;
  r.setStart(o, 0), r.setEnd(e.startContainer, e.startOffset);
  const i = ic(r).textContent, s = e.toString(), l = i.length || 0, c = l + s.length;
  return { quote: s, start: l, end: c, range: e };
}, lc = (e, t) => {
  var n, r;
  const { start: o, end: i } = e, s = e.offsetReference || t, l = document.createNodeIterator(
    t,
    NodeFilter.SHOW_TEXT,
    (p) => {
      var h;
      return (h = p.parentElement) != null && h.closest(Va) ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
    }
  );
  let c = 0;
  const u = document.createRange();
  let f = l.nextNode();
  f === null && console.error("Could not revive annotation target. Content missing.");
  let d = !s;
  for (; f !== null; ) {
    if (d || (d = s == null ? void 0 : s.contains(f)), d) {
      const p = ((n = f.textContent) == null ? void 0 : n.length) || 0;
      if (c + p > o) {
        u.setStart(f, o - c);
        break;
      }
      c += p;
    }
    f = l.nextNode();
  }
  for (; f !== null; ) {
    const p = ((r = f.textContent) == null ? void 0 : r.length) || 0;
    if (c + p >= i) {
      u.setEnd(f, i - c);
      break;
    }
    c += p, f = l.nextNode();
  }
  return {
    ...e,
    range: u
  };
}, Pi = (e, t) => ac(e.selector) ? e : {
  ...e,
  selector: e.selector.map((n) => n.range instanceof Range && !n.range.collapsed ? n : lc(n, t))
}, cc = [];
for (let e = 0; e < 256; ++e)
  cc.push((e + 256).toString(16).slice(1));
typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
const uc = [];
for (let e = 0; e < 256; ++e)
  uc.push((e + 256).toString(16).slice(1));
typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
const dc = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
let fc = (e = 21) => {
  let t = "", n = crypto.getRandomValues(new Uint8Array(e |= 0));
  for (; e--; )
    t += dc[n[e] & 63];
  return t;
};
fc();
const io = typeof navigator < "u" ? navigator.userAgent.toLowerCase().indexOf("firefox") > 0 : !1;
function ao(e, t, n, r) {
  e.addEventListener ? e.addEventListener(t, n, r) : e.attachEvent && e.attachEvent("on".concat(t), n);
}
function Bn(e, t, n, r) {
  e.removeEventListener ? e.removeEventListener(t, n, r) : e.detachEvent && e.detachEvent("on".concat(t), n);
}
function Ya(e, t) {
  const n = t.slice(0, t.length - 1);
  for (let r = 0; r < n.length; r++) n[r] = e[n[r].toLowerCase()];
  return n;
}
function Ha(e) {
  typeof e != "string" && (e = ""), e = e.replace(/\s/g, "");
  const t = e.split(",");
  let n = t.lastIndexOf("");
  for (; n >= 0; )
    t[n - 1] += ",", t.splice(n, 1), n = t.lastIndexOf("");
  return t;
}
function pc(e, t) {
  const n = e.length >= t.length ? e : t, r = e.length >= t.length ? t : e;
  let o = !0;
  for (let i = 0; i < n.length; i++)
    r.indexOf(n[i]) === -1 && (o = !1);
  return o;
}
const nr = {
  backspace: 8,
  "⌫": 8,
  tab: 9,
  clear: 12,
  enter: 13,
  "↩": 13,
  return: 13,
  esc: 27,
  escape: 27,
  space: 32,
  left: 37,
  up: 38,
  right: 39,
  down: 40,
  del: 46,
  delete: 46,
  ins: 45,
  insert: 45,
  home: 36,
  end: 35,
  pageup: 33,
  pagedown: 34,
  capslock: 20,
  num_0: 96,
  num_1: 97,
  num_2: 98,
  num_3: 99,
  num_4: 100,
  num_5: 101,
  num_6: 102,
  num_7: 103,
  num_8: 104,
  num_9: 105,
  num_multiply: 106,
  num_add: 107,
  num_enter: 108,
  num_subtract: 109,
  num_decimal: 110,
  num_divide: 111,
  "⇪": 20,
  ",": 188,
  ".": 190,
  "/": 191,
  "`": 192,
  "-": io ? 173 : 189,
  "=": io ? 61 : 187,
  ";": io ? 59 : 186,
  "'": 222,
  "[": 219,
  "]": 221,
  "\\": 220
}, ut = {
  // shiftKey
  "⇧": 16,
  shift: 16,
  // altKey
  "⌥": 18,
  alt: 18,
  option: 18,
  // ctrlKey
  "⌃": 17,
  ctrl: 17,
  control: 17,
  // metaKey
  "⌘": 91,
  cmd: 91,
  command: 91
}, Or = {
  16: "shiftKey",
  18: "altKey",
  17: "ctrlKey",
  91: "metaKey",
  shiftKey: 16,
  ctrlKey: 17,
  altKey: 18,
  metaKey: 91
}, Le = {
  16: !1,
  18: !1,
  17: !1,
  91: !1
}, we = {};
for (let e = 1; e < 20; e++)
  nr["f".concat(e)] = 111 + e;
let me = [], qn = null, Wa = "all";
const ht = /* @__PURE__ */ new Map(), cr = (e) => nr[e.toLowerCase()] || ut[e.toLowerCase()] || e.toUpperCase().charCodeAt(0), hc = (e) => Object.keys(nr).find((t) => nr[t] === e), gc = (e) => Object.keys(ut).find((t) => ut[t] === e);
function Ka(e) {
  Wa = e || "all";
}
function rr() {
  return Wa || "all";
}
function mc() {
  return me.slice(0);
}
function vc() {
  return me.map((e) => hc(e) || gc(e) || String.fromCharCode(e));
}
function yc() {
  const e = [];
  return Object.keys(we).forEach((t) => {
    we[t].forEach((n) => {
      let {
        key: r,
        scope: o,
        mods: i,
        shortcut: s
      } = n;
      e.push({
        scope: o,
        shortcut: s,
        mods: i,
        keys: r.split("+").map((l) => cr(l))
      });
    });
  }), e;
}
function bc(e) {
  const t = e.target || e.srcElement, {
    tagName: n
  } = t;
  let r = !0;
  const o = n === "INPUT" && !["checkbox", "radio", "range", "button", "file", "reset", "submit", "color"].includes(t.type);
  return (t.isContentEditable || (o || n === "TEXTAREA" || n === "SELECT") && !t.readOnly) && (r = !1), r;
}
function wc(e) {
  return typeof e == "string" && (e = cr(e)), me.indexOf(e) !== -1;
}
function xc(e, t) {
  let n, r;
  e || (e = rr());
  for (const o in we)
    if (Object.prototype.hasOwnProperty.call(we, o))
      for (n = we[o], r = 0; r < n.length; )
        n[r].scope === e ? n.splice(r, 1).forEach((i) => {
          let {
            element: s
          } = i;
          return Zo(s);
        }) : r++;
  rr() === e && Ka(t || "all");
}
function Ec(e) {
  let t = e.keyCode || e.which || e.charCode;
  const n = me.indexOf(t);
  if (n >= 0 && me.splice(n, 1), e.key && e.key.toLowerCase() === "meta" && me.splice(0, me.length), (t === 93 || t === 224) && (t = 91), t in Le) {
    Le[t] = !1;
    for (const r in ut) ut[r] === t && (Bt[r] = !1);
  }
}
function Xa(e) {
  if (typeof e > "u")
    Object.keys(we).forEach((o) => {
      Array.isArray(we[o]) && we[o].forEach((i) => hr(i)), delete we[o];
    }), Zo(null);
  else if (Array.isArray(e))
    e.forEach((o) => {
      o.key && hr(o);
    });
  else if (typeof e == "object")
    e.key && hr(e);
  else if (typeof e == "string") {
    for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
      n[r - 1] = arguments[r];
    let [o, i] = n;
    typeof o == "function" && (i = o, o = ""), hr({
      key: e,
      scope: o,
      method: i,
      splitKey: "+"
    });
  }
}
const hr = (e) => {
  let {
    key: t,
    scope: n,
    method: r,
    splitKey: o = "+"
  } = e;
  Ha(t).forEach((i) => {
    const s = i.split(o), l = s.length, c = s[l - 1], u = c === "*" ? "*" : cr(c);
    if (!we[u]) return;
    n || (n = rr());
    const f = l > 1 ? Ya(ut, s) : [], d = [];
    we[u] = we[u].filter((p) => {
      const h = (r ? p.method === r : !0) && p.scope === n && pc(p.mods, f);
      return h && d.push(p.element), !h;
    }), d.forEach((p) => Zo(p));
  });
};
function ji(e, t, n, r) {
  if (t.element !== r)
    return;
  let o;
  if (t.scope === n || t.scope === "all") {
    o = t.mods.length > 0;
    for (const i in Le)
      Object.prototype.hasOwnProperty.call(Le, i) && (!Le[i] && t.mods.indexOf(+i) > -1 || Le[i] && t.mods.indexOf(+i) === -1) && (o = !1);
    (t.mods.length === 0 && !Le[16] && !Le[18] && !Le[17] && !Le[91] || o || t.shortcut === "*") && (t.keys = [], t.keys = t.keys.concat(me), t.method(e, t) === !1 && (e.preventDefault ? e.preventDefault() : e.returnValue = !1, e.stopPropagation && e.stopPropagation(), e.cancelBubble && (e.cancelBubble = !0)));
  }
}
function Ni(e, t) {
  const n = we["*"];
  let r = e.keyCode || e.which || e.charCode;
  if (!Bt.filter.call(this, e)) return;
  if ((r === 93 || r === 224) && (r = 91), me.indexOf(r) === -1 && r !== 229 && me.push(r), ["metaKey", "ctrlKey", "altKey", "shiftKey"].forEach((l) => {
    const c = Or[l];
    e[l] && me.indexOf(c) === -1 ? me.push(c) : !e[l] && me.indexOf(c) > -1 ? me.splice(me.indexOf(c), 1) : l === "metaKey" && e[l] && (me = me.filter((u) => u in Or || u === r));
  }), r in Le) {
    Le[r] = !0;
    for (const l in ut)
      ut[l] === r && (Bt[l] = !0);
    if (!n) return;
  }
  for (const l in Le)
    Object.prototype.hasOwnProperty.call(Le, l) && (Le[l] = e[Or[l]]);
  e.getModifierState && !(e.altKey && !e.ctrlKey) && e.getModifierState("AltGraph") && (me.indexOf(17) === -1 && me.push(17), me.indexOf(18) === -1 && me.push(18), Le[17] = !0, Le[18] = !0);
  const o = rr();
  if (n)
    for (let l = 0; l < n.length; l++)
      n[l].scope === o && (e.type === "keydown" && n[l].keydown || e.type === "keyup" && n[l].keyup) && ji(e, n[l], o, t);
  if (!(r in we)) return;
  const i = we[r], s = i.length;
  for (let l = 0; l < s; l++)
    if ((e.type === "keydown" && i[l].keydown || e.type === "keyup" && i[l].keyup) && i[l].key) {
      const c = i[l], {
        splitKey: u
      } = c, f = c.key.split(u), d = [];
      for (let p = 0; p < f.length; p++)
        d.push(cr(f[p]));
      d.sort().join("") === me.sort().join("") && ji(e, c, o, t);
    }
}
function Bt(e, t, n) {
  me = [];
  const r = Ha(e);
  let o = [], i = "all", s = document, l = 0, c = !1, u = !0, f = "+", d = !1, p = !1;
  for (n === void 0 && typeof t == "function" && (n = t), Object.prototype.toString.call(t) === "[object Object]" && (t.scope && (i = t.scope), t.element && (s = t.element), t.keyup && (c = t.keyup), t.keydown !== void 0 && (u = t.keydown), t.capture !== void 0 && (d = t.capture), typeof t.splitKey == "string" && (f = t.splitKey), t.single === !0 && (p = !0)), typeof t == "string" && (i = t), p && Xa(e, i); l < r.length; l++)
    e = r[l].split(f), o = [], e.length > 1 && (o = Ya(ut, e)), e = e[e.length - 1], e = e === "*" ? "*" : cr(e), e in we || (we[e] = []), we[e].push({
      keyup: c,
      keydown: u,
      scope: i,
      mods: o,
      shortcut: r[l],
      method: n,
      key: r[l],
      splitKey: f,
      element: s
    });
  if (typeof s < "u" && window) {
    if (!ht.has(s)) {
      const h = function() {
        let v = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.event;
        return Ni(v, s);
      }, m = function() {
        let v = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.event;
        Ni(v, s), Ec(v);
      };
      ht.set(s, {
        keydownListener: h,
        keyupListenr: m,
        capture: d
      }), ao(s, "keydown", h, d), ao(s, "keyup", m, d);
    }
    if (!qn) {
      const h = () => {
        me = [];
      };
      qn = {
        listener: h,
        capture: d
      }, ao(window, "focus", h, d);
    }
  }
}
function Ac(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "all";
  Object.keys(we).forEach((n) => {
    we[n].filter((r) => r.scope === t && r.shortcut === e).forEach((r) => {
      r && r.method && r.method();
    });
  });
}
function Zo(e) {
  const t = Object.values(we).flat();
  if (t.findIndex((n) => {
    let {
      element: r
    } = n;
    return r === e;
  }) < 0) {
    const {
      keydownListener: n,
      keyupListenr: r,
      capture: o
    } = ht.get(e) || {};
    n && r && (Bn(e, "keyup", r, o), Bn(e, "keydown", n, o), ht.delete(e));
  }
  if ((t.length <= 0 || ht.size <= 0) && (Object.keys(ht).forEach((n) => {
    const {
      keydownListener: r,
      keyupListenr: o,
      capture: i
    } = ht.get(n) || {};
    r && o && (Bn(n, "keyup", o, i), Bn(n, "keydown", r, i), ht.delete(n));
  }), ht.clear(), Object.keys(we).forEach((n) => delete we[n]), qn)) {
    const {
      listener: n,
      capture: r
    } = qn;
    Bn(window, "focus", n, r), qn = null;
  }
}
const so = {
  getPressedKeyString: vc,
  setScope: Ka,
  getScope: rr,
  deleteScope: xc,
  getPressedKeyCodes: mc,
  getAllKeyCodes: yc,
  isPressed: wc,
  filter: bc,
  trigger: Ac,
  unbind: Xa,
  keyMap: nr,
  modifier: ut,
  modifierMap: Or
};
for (const e in so)
  Object.prototype.hasOwnProperty.call(so, e) && (Bt[e] = so[e]);
if (typeof window < "u") {
  const e = window.hotkeys;
  Bt.noConflict = (t) => (t && window.hotkeys === Bt && (window.hotkeys = e), Bt), window.hotkeys = Bt;
}
const Rc = (e, t, n) => {
  let r = e, o = n;
  const i = document.createNodeIterator(t, NodeFilter.SHOW_TEXT);
  let s = i.nextNode(), l = !0;
  do
    s instanceof Text && (s.length < o ? o -= s.length : (r = s, l = !1)), s = i.nextNode();
  while (s && l);
  return { node: r, offset: o };
}, Bo = (e, t = []) => {
  let n, r, o;
  if (e.nodeType === Node.ELEMENT_NODE && e.hasAttribute("xml:id") ? t.push("/") : e.parentNode && (t = Bo(e.parentNode, t)), e.nodeType === Node.ELEMENT_NODE && e.nodeName.toLowerCase().startsWith("tei-")) {
    const i = e;
    i.hasAttribute("xml:id") ? o = `[@xml:id='${i.getAttribute("xml:id")}']` : (n = `count(preceding-sibling::${i.localName})`, r = document.evaluate(n, e, null, XPathResult.NUMBER_TYPE, null).numberValue + 1, o = `[${r}]`), t.push("/"), t.push(i.getAttribute("data-origname") + o);
  }
  return t;
}, Sc = (e, t, n) => {
  const r = (u) => u ? u.nodeName.toLowerCase().indexOf("tei-") === 0 ? u : r(u.parentNode) : null, o = (u, f, d) => {
    const p = document.createRange();
    return p.setStart(u, 0), p.setEnd(f, d), p.toString().length;
  }, i = o(
    r(n.startContainer),
    n.startContainer,
    n.startOffset
  ), s = o(
    r(n.endContainer),
    n.endContainer,
    n.endOffset
  ), l = e.join("") + "::" + i, c = t.join("") + "::" + s;
  return { start: l, end: c };
}, Oc = (e) => {
  var t;
  const { range: n } = e, r = Bo(n.startContainer), o = Bo(n.endContainer), { start: i, end: s } = Sc(r, o, n);
  return {
    start: e.start,
    startSelector: {
      type: "XPathSelector",
      value: i
    },
    end: e.end,
    endSelector: {
      type: "XPathSelector",
      value: s
    },
    quote: (t = e.quote) == null ? void 0 : t.replace(/\s+/g, " "),
    range: n
  };
}, Tc = (e, t) => {
  var n, r;
  const o = Array.isArray(e.selector) ? e.selector[0] : e.selector;
  if ("start" in o && "end" in o)
    return Pi(e, t);
  {
    const i = (n = o.startSelector) == null ? void 0 : n.value, s = (r = o.endSelector) == null ? void 0 : r.value;
    if (!i || !s)
      throw console.error(e), "Could not revive TEI target.";
    const l = (b) => {
      const g = b.indexOf("::");
      if (g < 0) return;
      const x = b.substring(0, g).replace(/\/([^[/]+)/g, (P, _) => "/tei-" + _.toLowerCase()).replace(/xml:/g, ""), R = document.evaluate(
        "." + x,
        t,
        null,
        XPathResult.FIRST_ORDERED_NODE_TYPE,
        null
      ).singleNodeValue, A = parseInt(b.substring(g + 2));
      return [R, A];
    }, [c, u] = l(i), [f, d] = l(s), p = document.createRange(), h = (b, g) => b.firstChild instanceof Text && b.firstChild.length >= g ? { node: b.firstChild, offset: g } : Rc(b.firstChild, b, g), m = h(c, u);
    p.setStart(m.node, m.offset);
    const v = h(f, d);
    p.setEnd(v.node, v.offset);
    const w = sc(p, t);
    return Pi({
      ...e,
      selector: [{
        ...w,
        ...o,
        range: p
      }]
    }, t);
  }
}, za = (e) => (t) => {
  const n = Tc(t, e);
  return {
    ...t,
    selector: n.selector.map(Oc)
  };
}, Cc = (e) => (t) => ({
  ...t,
  target: za(e)(t.target)
}), kc = (e) => {
  const t = e.element, n = Cc(t), r = za(t), o = e.state.store, i = o.addAnnotation;
  o.addAnnotation = (u, f) => {
    const { selector: d } = u.target;
    return "startSelector" in d && "start" in d ? i(u, f) : i(n(u), f);
  };
  const s = o.bulkAddAnnotation;
  o.bulkAddAnnotation = (u, f = !0, d) => {
    const p = u.map((h) => {
      const { selector: m } = h.target;
      return "startSelector" in m && "start" in m ? h : n(h);
    });
    return s(p, f, d);
  };
  const l = o.updateAnnotation;
  o.updateAnnotation = (u, f) => l(n(u), f);
  const c = o.updateTarget;
  return o.updateTarget = (u, f) => c(r(u), f), {
    ...e,
    state: {
      ...e.state,
      // @ts-ignore
      store: o
    }
  };
}, Qo = "not-annotatable", un = `.${Qo}`, Hn = (e) => {
  var t;
  return !!(e instanceof HTMLElement ? e.closest(un) : (t = e.parentElement) != null && t.closest(un));
}, $c = (e) => {
  const t = e.commonAncestorContainer;
  return !Hn(t);
}, _c = (e) => e.addEventListener("click", (t) => {
  !t.target.closest(un) && !t.target.closest("a") && t.preventDefault();
}), lo = (e) => ({
  ...e,
  type: e.type,
  x: e.x,
  y: e.y,
  clientX: e.clientX,
  clientY: e.clientY,
  offsetX: e.offsetX,
  offsetY: e.offsetY,
  screenX: e.screenX,
  screenY: e.screenY,
  isPrimary: e.isPrimary,
  altKey: e.altKey,
  ctrlKey: e.ctrlKey,
  metaKey: e.metaKey,
  shiftKey: e.shiftKey,
  button: e.button,
  buttons: e.buttons,
  currentTarget: e.currentTarget,
  target: e.target,
  defaultPrevented: e.defaultPrevented,
  detail: e.detail,
  eventPhase: e.eventPhase,
  pointerId: e.pointerId,
  pointerType: e.pointerType,
  timeStamp: e.timeStamp
}), gr = (e) => ({
  ...e,
  type: e.type,
  key: e.key,
  code: e.code,
  location: e.location,
  repeat: e.repeat,
  altKey: e.altKey,
  ctrlKey: e.ctrlKey,
  metaKey: e.metaKey,
  shiftKey: e.shiftKey,
  currentTarget: e.currentTarget,
  target: e.target,
  defaultPrevented: e.defaultPrevented,
  detail: e.detail,
  timeStamp: e.timeStamp
}), Pc = /mac/i.test(navigator.userAgentData ? navigator.userAgentData.platform : navigator.platform), jc = (e) => {
  !e.hasAttribute("tabindex") && e.tabIndex < 0 && e.setAttribute("tabindex", "-1"), e.classList.add("no-focus-outline");
}, ei = (e, t = 10) => {
  let n;
  return (...r) => {
    clearTimeout(n), n = setTimeout(() => e.apply(void 0, r), t);
  };
}, Nc = function* (e) {
  const t = document.createNodeIterator(
    e.commonAncestorContainer,
    NodeFilter.SHOW_ELEMENT,
    (r) => r instanceof HTMLElement && r.classList.contains(Qo) && !r.parentElement.closest(un) && e.intersectsNode(r) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
  );
  let n;
  for (; n = t.nextNode(); )
    n instanceof HTMLElement && (yield n);
}, Lc = (e) => {
  if (!$c(e)) return [];
  const t = [];
  let n = null;
  for (const r of Nc(e)) {
    let o;
    n ? (o = document.createRange(), o.setStartAfter(n), o.setEndBefore(r)) : (o = e.cloneRange(), o.setEndBefore(r)), o.collapsed || t.push(o), n = r;
  }
  if (n) {
    const r = e.cloneRange();
    r.setStartAfter(n), r.collapsed || t.push(r);
  }
  return t.length > 0 ? t : [e];
}, Ic = (e) => {
  const t = e.cloneContents();
  return t.querySelectorAll(un).forEach((n) => n.remove()), t;
}, mt = (e) => e.every((t) => t.range instanceof Range && !t.range.collapsed), Dc = /^\s*$/, Mc = (e) => Dc.test(e.toString()), Fc = (e, t) => {
  const n = (i) => Math.round(i * 10) / 10, r = {
    top: n(e.top),
    bottom: n(e.bottom),
    left: n(e.left),
    right: n(e.right)
  }, o = {
    top: n(t.top),
    bottom: n(t.bottom),
    left: n(t.left),
    right: n(t.right)
  };
  if (Math.abs(r.top - o.top) < 0.5 && Math.abs(r.bottom - o.bottom) < 0.5) {
    if (Math.abs(r.left - o.right) < 0.5 || Math.abs(r.right - o.left) < 0.5)
      return "inline-adjacent";
    if (r.left >= o.left && r.right <= o.right)
      return "inline-is-contained";
    if (r.left <= o.left && r.right >= o.right)
      return "inline-contains";
  } else if (r.top <= o.top && r.bottom >= o.bottom) {
    if (r.left <= o.left && r.right >= o.right)
      return "block-contains";
  } else if (r.top >= o.top && r.bottom <= o.bottom && r.left >= o.left && r.right <= o.right)
    return "block-is-contained";
}, Bc = (e, t) => {
  const n = Math.min(e.left, t.left), r = Math.max(e.right, t.right), o = Math.min(e.top, t.top), i = Math.max(e.bottom, t.bottom);
  return new DOMRect(n, o, r - n, i - o);
}, Uc = (e) => e.reduce((t, n) => {
  if (n.width === 0 || n.height === 0)
    return t;
  let r = [...t], o = !1;
  for (const i of t) {
    const s = Fc(n, i);
    if (s === "inline-adjacent") {
      r = r.map((l) => l === i ? Bc(n, i) : l), o = !0;
      break;
    } else if (s === "inline-contains") {
      r = r.map((l) => l === i ? n : l), o = !0;
      break;
    } else if (s === "inline-is-contained") {
      o = !0;
      break;
    } else if (s === "block-contains" || s === "block-is-contained") {
      n.width < i.width && (r = r.map((l) => l === i ? n : l)), o = !0;
      break;
    }
  }
  return o ? r : [...r, n];
}, []), Vc = (e) => ({
  length: e.length,
  item: (t) => e[t],
  [Symbol.iterator]: function* () {
    for (let t = 0; t < this.length; t++)
      yield this.item(t);
  }
}), Yc = (e, t, n) => {
  const r = document.createRange(), o = n ? e.startContainer.parentElement.closest(n) : t;
  r.setStart(o, 0), r.setEnd(e.startContainer, e.startOffset);
  const i = Ic(r).textContent, s = e.toString(), l = i.length || 0, c = l + s.length;
  return n ? { quote: s, start: l, end: c, range: e, offsetReference: o } : { quote: s, start: l, end: c, range: e };
}, qa = (e, t) => {
  var n, r;
  const { start: o, end: i } = e, s = e.offsetReference || t, l = document.createNodeIterator(
    t,
    NodeFilter.SHOW_TEXT,
    (p) => {
      var h;
      return (h = p.parentElement) != null && h.closest(un) ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
    }
  );
  let c = 0;
  const u = document.createRange();
  let f = l.nextNode();
  f === null && console.error("Could not revive annotation target. Content missing.");
  let d = !s;
  for (; f !== null; ) {
    if (d || (d = s == null ? void 0 : s.contains(f)), d) {
      const p = ((n = f.textContent) == null ? void 0 : n.length) || 0;
      if (c + p > o) {
        u.setStart(f, o - c);
        break;
      }
      c += p;
    }
    f = l.nextNode();
  }
  for (; f !== null; ) {
    const p = ((r = f.textContent) == null ? void 0 : r.length) || 0;
    if (c + p >= i) {
      u.setEnd(f, i - c);
      break;
    }
    c += p, f = l.nextNode();
  }
  return {
    ...e,
    range: u
  };
}, Nr = (e, t) => mt(e.selector) ? e : {
  ...e,
  selector: e.selector.map((n) => n.range instanceof Range && !n.range.collapsed ? n : qa(n, t))
}, co = (e, t) => mt(e.target.selector) ? e : { ...e, target: Nr(e.target, t) }, Hc = (e, t) => {
  const n = e.cloneRange();
  return t.contains(n.startContainer) || n.setStart(t, 0), t.contains(n.endContainer) || n.setEnd(t, t.childNodes.length), n;
}, Ga = (e) => {
  if (e === null)
    return document.scrollingElement;
  const { overflowY: t } = window.getComputedStyle(e);
  return t !== "visible" && t !== "hidden" && e.scrollHeight > e.clientHeight ? e : Ga(e.parentElement);
}, Wc = (e, t) => (n) => {
  const r = typeof n == "string" ? n : n.id, o = (s) => {
    const l = i.getBoundingClientRect(), c = i.clientHeight, u = i.clientWidth, f = s.selector[0].range.getBoundingClientRect(), { width: d, height: p } = t.getAnnotationBounds(r), h = f.top - l.top, m = f.left - l.left, v = i.parentElement ? i.scrollTop : 0, w = i.parentElement ? i.scrollLeft : 0, b = h + v - (c - p) / 2, g = m + w - (u - d) / 2;
    i.scroll({ top: b, left: g, behavior: "smooth" });
  }, i = Ga(e);
  if (i) {
    const s = t.getAnnotation(r), { range: l } = s.target.selector[0];
    if (l && !l.collapsed)
      return o(s.target), !0;
    {
      const c = Nr(s.target, e), { range: u } = c.selector[0];
      if (u && !u.collapsed)
        return o(c), !0;
    }
  }
  return !1;
}, Vt = {
  fill: "rgb(0, 128, 255)",
  fillOpacity: 0.18
}, Lr = {
  fill: "rgb(0, 128, 255)",
  fillOpacity: 0.45
}, Kc = (e, t, n, r, o) => {
  var i, s;
  const l = n ? typeof n == "function" ? n(e.annotation, e.state, o) || ((i = e.state) != null && i.selected ? Lr : Vt) : n : (s = e.state) != null && s.selected ? Lr : Vt;
  return r && r.paint(e, t) || l;
}, Xc = (e) => {
  const { top: t, left: n } = e.getBoundingClientRect(), { innerWidth: r, innerHeight: o } = window, i = -n, s = -t, l = r - n, c = o - t;
  return { top: t, left: n, minX: i, minY: s, maxX: l, maxY: c };
}, zc = (e) => {
  let t = /* @__PURE__ */ new Set();
  return (n) => {
    const r = n.map((o) => o.id);
    (t.size !== r.length || r.some((o) => !t.has(o))) && e.set(r), t = new Set(r);
  };
}, ti = (e, t, n, r) => {
  const { store: o, selection: i, hover: s } = t;
  let l, c, u;
  const f = zc(n), d = (_) => {
    const { x: C, y: M } = e.getBoundingClientRect(), O = o.getAt(_.clientX - C, _.clientY - M, !1, c);
    O ? s.current !== O.id && (e.classList.add("hovered"), s.set(O.id)) : s.current && (e.classList.remove("hovered"), s.set(null));
  };
  e.addEventListener("pointermove", d);
  const p = (_ = !1) => {
    u && u.clear();
    const C = Xc(e), { minX: M, minY: O, maxX: S, maxY: $ } = C, T = c ? o.getIntersecting(M, O, S, $).filter(({ annotation: Y }) => c(Y)) : o.getIntersecting(M, O, S, $), j = i.selected.map(({ id: Y }) => Y), L = T.map(({ annotation: Y, rects: z }) => {
      const K = j.includes(Y.id), W = Y.id === s.current;
      return { annotation: Y, rects: z, state: { selected: K, hover: W } };
    });
    r.redraw(L, C, l, u, _), setTimeout(() => f(T.map(({ annotation: Y }) => Y)), 1);
  }, h = (_) => {
    u = _, p();
  }, m = (_) => {
    l = _, p();
  }, v = (_) => {
    c = _, p(!1);
  }, w = () => p();
  o.observe(w);
  const b = i.subscribe(() => p()), g = () => p(!0);
  document.addEventListener("scroll", g, { capture: !0, passive: !0 });
  const x = ei(() => {
    o.recalculatePositions(), u && u.reset(), p();
  });
  window.addEventListener("resize", x);
  const R = new ResizeObserver(x);
  R.observe(e);
  const A = { attributes: !0, childList: !0, subtree: !0 }, P = new MutationObserver((_) => {
    _.every((C) => C.target === e || e.contains(C.target)) || p(!0);
  });
  return P.observe(document.body, A), {
    destroy: () => {
      e.removeEventListener("pointermove", d), r.destroy(), o.unobserve(w), b(), document.removeEventListener("scroll", g), window.removeEventListener("resize", x), R.disconnect(), P.disconnect();
    },
    redraw: p,
    setStyle: m,
    setFilter: v,
    setPainter: h,
    setVisible: r.setVisible
  };
}, qc = () => {
  const e = document.createElement("canvas");
  return e.width = window.innerWidth, e.height = window.innerHeight, e.className = "r6o-canvas-highlight-layer bg", e;
}, Gc = (e, t) => {
  e.width = window.innerWidth, e.height = window.innerHeight;
}, Jc = (e) => {
  e.classList.add("r6o-annotatable");
  const t = qc(), n = t.getContext("2d");
  document.body.appendChild(t);
  const r = (i, s, l, c) => requestAnimationFrame(() => {
    const { width: u, height: f } = t;
    n.clearRect(-0.5, -0.5, u + 1, f + 1), c && c.clear();
    const { top: d, left: p } = s;
    [...i].sort((h, m) => {
      const { annotation: { target: { created: v } } } = h, { annotation: { target: { created: w } } } = m;
      return v.getTime() - w.getTime();
    }).forEach((h) => {
      var m;
      const v = l ? typeof l == "function" ? l(h.annotation, h.state) : l : (m = h.state) != null && m.selected ? Lr : Vt, w = c && c.paint(h, s) || v, b = h.rects.map(({ x: g, y: x, width: R, height: A }) => ({
        x: g + p,
        y: x + d,
        width: R,
        height: A
      }));
      if (n.fillStyle = w.fill, n.globalAlpha = w.fillOpacity || 1, b.forEach(
        ({ x: g, y: x, width: R, height: A }) => n.fillRect(g, x, R, A)
      ), w.underlineColor) {
        n.globalAlpha = 1, n.strokeStyle = w.underlineColor, n.lineWidth = w.underlineThickness ?? 1;
        const g = w.underlineOffset ?? 0;
        b.forEach(({ x, y: R, width: A, height: P }) => {
          n.beginPath(), n.moveTo(x, R + P + g), n.lineTo(x + A, R + P + g), n.stroke();
        });
      }
    });
  }), o = ei(() => {
    Gc(t);
  });
  return window.addEventListener("resize", o), {
    destroy: () => {
      t.remove(), window.removeEventListener("resize", o);
    },
    setVisible: (i) => {
      console.log("setVisible not implemented on Canvas renderer");
    },
    redraw: r
  };
}, Zc = (e, t, n) => ti(e, t, n, Jc(e));
var Qc = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) }, pt = function(e) {
  return typeof e == "string" ? e.length > 0 : typeof e == "number";
}, $e = function(e, t, n) {
  return t === void 0 && (t = 0), n === void 0 && (n = Math.pow(10, t)), Math.round(n * e) / n + 0;
}, Ge = function(e, t, n) {
  return t === void 0 && (t = 0), n === void 0 && (n = 1), e > n ? n : e > t ? e : t;
}, Ja = function(e) {
  return (e = isFinite(e) ? e % 360 : 0) > 0 ? e : e + 360;
}, Li = function(e) {
  return { r: Ge(e.r, 0, 255), g: Ge(e.g, 0, 255), b: Ge(e.b, 0, 255), a: Ge(e.a) };
}, uo = function(e) {
  return { r: $e(e.r), g: $e(e.g), b: $e(e.b), a: $e(e.a, 3) };
}, eu = /^#([0-9a-f]{3,8})$/i, mr = function(e) {
  var t = e.toString(16);
  return t.length < 2 ? "0" + t : t;
}, Za = function(e) {
  var t = e.r, n = e.g, r = e.b, o = e.a, i = Math.max(t, n, r), s = i - Math.min(t, n, r), l = s ? i === t ? (n - r) / s : i === n ? 2 + (r - t) / s : 4 + (t - n) / s : 0;
  return { h: 60 * (l < 0 ? l + 6 : l), s: i ? s / i * 100 : 0, v: i / 255 * 100, a: o };
}, Qa = function(e) {
  var t = e.h, n = e.s, r = e.v, o = e.a;
  t = t / 360 * 6, n /= 100, r /= 100;
  var i = Math.floor(t), s = r * (1 - n), l = r * (1 - (t - i) * n), c = r * (1 - (1 - t + i) * n), u = i % 6;
  return { r: 255 * [r, l, s, s, c, r][u], g: 255 * [c, r, r, l, s, s][u], b: 255 * [s, s, c, r, r, l][u], a: o };
}, Ii = function(e) {
  return { h: Ja(e.h), s: Ge(e.s, 0, 100), l: Ge(e.l, 0, 100), a: Ge(e.a) };
}, Di = function(e) {
  return { h: $e(e.h), s: $e(e.s), l: $e(e.l), a: $e(e.a, 3) };
}, Mi = function(e) {
  return Qa((n = (t = e).s, { h: t.h, s: (n *= ((r = t.l) < 50 ? r : 100 - r) / 100) > 0 ? 2 * n / (r + n) * 100 : 0, v: r + n, a: t.a }));
  var t, n, r;
}, Gn = function(e) {
  return { h: (t = Za(e)).h, s: (o = (200 - (n = t.s)) * (r = t.v) / 100) > 0 && o < 200 ? n * r / 100 / (o <= 100 ? o : 200 - o) * 100 : 0, l: o / 2, a: t.a };
  var t, n, r, o;
}, tu = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, nu = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, ru = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, ou = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, Fi = { string: [[function(e) {
  var t = eu.exec(e);
  return t ? (e = t[1]).length <= 4 ? { r: parseInt(e[0] + e[0], 16), g: parseInt(e[1] + e[1], 16), b: parseInt(e[2] + e[2], 16), a: e.length === 4 ? $e(parseInt(e[3] + e[3], 16) / 255, 2) : 1 } : e.length === 6 || e.length === 8 ? { r: parseInt(e.substr(0, 2), 16), g: parseInt(e.substr(2, 2), 16), b: parseInt(e.substr(4, 2), 16), a: e.length === 8 ? $e(parseInt(e.substr(6, 2), 16) / 255, 2) : 1 } : null : null;
}, "hex"], [function(e) {
  var t = ru.exec(e) || ou.exec(e);
  return t ? t[2] !== t[4] || t[4] !== t[6] ? null : Li({ r: Number(t[1]) / (t[2] ? 100 / 255 : 1), g: Number(t[3]) / (t[4] ? 100 / 255 : 1), b: Number(t[5]) / (t[6] ? 100 / 255 : 1), a: t[7] === void 0 ? 1 : Number(t[7]) / (t[8] ? 100 : 1) }) : null;
}, "rgb"], [function(e) {
  var t = tu.exec(e) || nu.exec(e);
  if (!t) return null;
  var n, r, o = Ii({ h: (n = t[1], r = t[2], r === void 0 && (r = "deg"), Number(n) * (Qc[r] || 1)), s: Number(t[3]), l: Number(t[4]), a: t[5] === void 0 ? 1 : Number(t[5]) / (t[6] ? 100 : 1) });
  return Mi(o);
}, "hsl"]], object: [[function(e) {
  var t = e.r, n = e.g, r = e.b, o = e.a, i = o === void 0 ? 1 : o;
  return pt(t) && pt(n) && pt(r) ? Li({ r: Number(t), g: Number(n), b: Number(r), a: Number(i) }) : null;
}, "rgb"], [function(e) {
  var t = e.h, n = e.s, r = e.l, o = e.a, i = o === void 0 ? 1 : o;
  if (!pt(t) || !pt(n) || !pt(r)) return null;
  var s = Ii({ h: Number(t), s: Number(n), l: Number(r), a: Number(i) });
  return Mi(s);
}, "hsl"], [function(e) {
  var t = e.h, n = e.s, r = e.v, o = e.a, i = o === void 0 ? 1 : o;
  if (!pt(t) || !pt(n) || !pt(r)) return null;
  var s = function(l) {
    return { h: Ja(l.h), s: Ge(l.s, 0, 100), v: Ge(l.v, 0, 100), a: Ge(l.a) };
  }({ h: Number(t), s: Number(n), v: Number(r), a: Number(i) });
  return Qa(s);
}, "hsv"]] }, Bi = function(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n][0](e);
    if (r) return [r, t[n][1]];
  }
  return [null, void 0];
}, iu = function(e) {
  return typeof e == "string" ? Bi(e.trim(), Fi.string) : typeof e == "object" && e !== null ? Bi(e, Fi.object) : [null, void 0];
}, fo = function(e, t) {
  var n = Gn(e);
  return { h: n.h, s: Ge(n.s + 100 * t, 0, 100), l: n.l, a: n.a };
}, po = function(e) {
  return (299 * e.r + 587 * e.g + 114 * e.b) / 1e3 / 255;
}, Ui = function(e, t) {
  var n = Gn(e);
  return { h: n.h, s: n.s, l: Ge(n.l + 100 * t, 0, 100), a: n.a };
}, Vi = function() {
  function e(t) {
    this.parsed = iu(t)[0], this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 };
  }
  return e.prototype.isValid = function() {
    return this.parsed !== null;
  }, e.prototype.brightness = function() {
    return $e(po(this.rgba), 2);
  }, e.prototype.isDark = function() {
    return po(this.rgba) < 0.5;
  }, e.prototype.isLight = function() {
    return po(this.rgba) >= 0.5;
  }, e.prototype.toHex = function() {
    return t = uo(this.rgba), n = t.r, r = t.g, o = t.b, s = (i = t.a) < 1 ? mr($e(255 * i)) : "", "#" + mr(n) + mr(r) + mr(o) + s;
    var t, n, r, o, i, s;
  }, e.prototype.toRgb = function() {
    return uo(this.rgba);
  }, e.prototype.toRgbString = function() {
    return t = uo(this.rgba), n = t.r, r = t.g, o = t.b, (i = t.a) < 1 ? "rgba(" + n + ", " + r + ", " + o + ", " + i + ")" : "rgb(" + n + ", " + r + ", " + o + ")";
    var t, n, r, o, i;
  }, e.prototype.toHsl = function() {
    return Di(Gn(this.rgba));
  }, e.prototype.toHslString = function() {
    return t = Di(Gn(this.rgba)), n = t.h, r = t.s, o = t.l, (i = t.a) < 1 ? "hsla(" + n + ", " + r + "%, " + o + "%, " + i + ")" : "hsl(" + n + ", " + r + "%, " + o + "%)";
    var t, n, r, o, i;
  }, e.prototype.toHsv = function() {
    return t = Za(this.rgba), { h: $e(t.h), s: $e(t.s), v: $e(t.v), a: $e(t.a, 3) };
    var t;
  }, e.prototype.invert = function() {
    return ot({ r: 255 - (t = this.rgba).r, g: 255 - t.g, b: 255 - t.b, a: t.a });
    var t;
  }, e.prototype.saturate = function(t) {
    return t === void 0 && (t = 0.1), ot(fo(this.rgba, t));
  }, e.prototype.desaturate = function(t) {
    return t === void 0 && (t = 0.1), ot(fo(this.rgba, -t));
  }, e.prototype.grayscale = function() {
    return ot(fo(this.rgba, -1));
  }, e.prototype.lighten = function(t) {
    return t === void 0 && (t = 0.1), ot(Ui(this.rgba, t));
  }, e.prototype.darken = function(t) {
    return t === void 0 && (t = 0.1), ot(Ui(this.rgba, -t));
  }, e.prototype.rotate = function(t) {
    return t === void 0 && (t = 15), this.hue(this.hue() + t);
  }, e.prototype.alpha = function(t) {
    return typeof t == "number" ? ot({ r: (n = this.rgba).r, g: n.g, b: n.b, a: t }) : $e(this.rgba.a, 3);
    var n;
  }, e.prototype.hue = function(t) {
    var n = Gn(this.rgba);
    return typeof t == "number" ? ot({ h: t, s: n.s, l: n.l, a: n.a }) : $e(n.h);
  }, e.prototype.isEqual = function(t) {
    return this.toHex() === ot(t).toHex();
  }, e;
}(), ot = function(e) {
  return e instanceof Vi ? e : new Vi(e);
};
const au = (e) => [
  `background-color:${ot((e == null ? void 0 : e.fill) || Vt.fill).alpha((e == null ? void 0 : e.fillOpacity) === void 0 ? Vt.fillOpacity : e.fillOpacity).toHex()}`,
  e != null && e.underlineThickness ? "text-decoration:underline" : void 0,
  e != null && e.underlineColor ? `text-decoration-color:${e.underlineColor}` : void 0,
  e != null && e.underlineOffset ? `text-underline-offset:${e.underlineOffset}px` : void 0,
  e != null && e.underlineThickness ? `text-decoration-thickness:${e.underlineThickness}px` : void 0
].filter(Boolean).join(";"), su = () => {
  const e = document.createElement("style");
  document.getElementsByTagName("head")[0].appendChild(e);
  let t = /* @__PURE__ */ new Set();
  return {
    destroy: () => {
      CSS.highlights.clear(), e.remove();
    },
    setVisible: (n) => {
      console.log("setVisible not implemented on CSS Custom Highlights renderer");
    },
    redraw: (n, r, o, i) => {
      i && i.clear();
      const s = new Set(n.map((c) => c.annotation.id));
      Array.from(t).filter((c) => !s.has(c));
      const l = n.map((c) => {
        var u;
        const f = o ? typeof o == "function" ? o(c.annotation, c.state) : o : (u = c.state) != null && u.selected ? Lr : Vt, d = i && i.paint(c, r) || f;
        return `::highlight(_${c.annotation.id}) { ${au(d)} }`;
      });
      e.innerHTML = l.join(`
`), CSS.highlights.clear(), n.forEach(({ annotation: c }) => {
        const u = c.target.selector.map((d) => d.range), f = new Highlight(...u);
        CSS.highlights.set(`_${c.id}`, f);
      }), t = s;
    }
  };
}, lu = (e, t, n) => ti(e, t, n, su());
var Yi = Object.prototype.hasOwnProperty;
function Uo(e, t) {
  var n, r;
  if (e === t) return !0;
  if (e && t && (n = e.constructor) === t.constructor) {
    if (n === Date) return e.getTime() === t.getTime();
    if (n === RegExp) return e.toString() === t.toString();
    if (n === Array) {
      if ((r = e.length) === t.length)
        for (; r-- && Uo(e[r], t[r]); ) ;
      return r === -1;
    }
    if (!n || typeof e == "object") {
      r = 0;
      for (n in e)
        if (Yi.call(e, n) && ++r && !Yi.call(t, n) || !(n in t) || !Uo(e[n], t[n])) return !1;
      return Object.keys(t).length === r;
    }
  }
  return e !== e && t !== t;
}
const cu = (e, t) => {
  const n = (i, s) => i.x <= s.x + s.width && i.x + i.width >= s.x && i.y <= s.y + s.height && i.y + i.height >= s.y, r = (i) => i.rects.reduce((s, l) => s + l.width, 0), o = t.filter(({ rects: i }) => i.some((s) => n(e, s)));
  return o.sort((i, s) => r(s) - r(i)), o.findIndex((i) => i.rects.includes(e));
}, uu = (e) => {
  e.classList.add("r6o-annotatable");
  const t = document.createElement("div");
  t.className = "r6o-span-highlight-layer", e.insertBefore(t, e.firstChild);
  let n = [];
  return {
    destroy: () => {
      t.remove();
    },
    redraw: (r, o, i, s, l) => {
      const c = !(Uo(n, r) && l);
      !s && !c || (c && (t.innerHTML = ""), [...r].sort((u, f) => {
        const { annotation: { target: { created: d } } } = u, { annotation: { target: { created: p } } } = f;
        return d && p ? d.getTime() - p.getTime() : 0;
      }).forEach((u) => {
        u.rects.map((f) => {
          const d = cu(f, r), p = Kc(u, o, i, s, d);
          if (c) {
            const h = document.createElement("span");
            h.className = "r6o-annotation", h.dataset.annotation = u.annotation.id, h.style.left = `${f.x}px`, h.style.top = `${f.y}px`, h.style.width = `${f.width}px`, h.style.height = `${f.height}px`, h.style.backgroundColor = ot((p == null ? void 0 : p.fill) || Vt.fill).alpha((p == null ? void 0 : p.fillOpacity) === void 0 ? Vt.fillOpacity : p.fillOpacity).toHex(), p.underlineStyle && (h.style.borderStyle = p.underlineStyle), p.underlineColor && (h.style.borderColor = p.underlineColor), p.underlineThickness && (h.style.borderBottomWidth = `${p.underlineThickness}px`), p.underlineOffset && (h.style.paddingBottom = `${p.underlineOffset}px`), t.appendChild(h);
          }
        });
      }), n = r);
    },
    setVisible: (r) => {
      r ? t.classList.remove("hidden") : t.classList.add("hidden");
    }
  };
}, du = (e, t, n) => ti(e, t, n, uu(e)), Pe = [];
for (let e = 0; e < 256; ++e)
  Pe.push((e + 256).toString(16).slice(1));
function fu(e, t = 0) {
  return (Pe[e[t + 0]] + Pe[e[t + 1]] + Pe[e[t + 2]] + Pe[e[t + 3]] + "-" + Pe[e[t + 4]] + Pe[e[t + 5]] + "-" + Pe[e[t + 6]] + Pe[e[t + 7]] + "-" + Pe[e[t + 8]] + Pe[e[t + 9]] + "-" + Pe[e[t + 10]] + Pe[e[t + 11]] + Pe[e[t + 12]] + Pe[e[t + 13]] + Pe[e[t + 14]] + Pe[e[t + 15]]).toLowerCase();
}
let ho;
const pu = new Uint8Array(16);
function hu() {
  if (!ho) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    ho = crypto.getRandomValues.bind(crypto);
  }
  return ho(pu);
}
const gu = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), Hi = { randomUUID: gu };
function mu(e, t, n) {
  if (Hi.randomUUID && !t && !e)
    return Hi.randomUUID();
  e = e || {};
  const r = e.random || (e.rng || hu)();
  return r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, fu(r);
}
var Wi = Object.prototype.hasOwnProperty;
function qt(e, t) {
  var n, r;
  if (e === t) return !0;
  if (e && t && (n = e.constructor) === t.constructor) {
    if (n === Date) return e.getTime() === t.getTime();
    if (n === RegExp) return e.toString() === t.toString();
    if (n === Array) {
      if ((r = e.length) === t.length)
        for (; r-- && qt(e[r], t[r]); ) ;
      return r === -1;
    }
    if (!n || typeof e == "object") {
      r = 0;
      for (n in e)
        if (Wi.call(e, n) && ++r && !Wi.call(t, n) || !(n in t) || !qt(e[n], t[n])) return !1;
      return Object.keys(t).length === r;
    }
  }
  return e !== e && t !== t;
}
function go() {
}
function vu(e, t) {
  return e != e ? t == t : e !== t || e && typeof e == "object" || typeof e == "function";
}
const Qt = [];
function ni(e, t = go) {
  let n;
  const r = /* @__PURE__ */ new Set();
  function o(l) {
    if (vu(e, l) && (e = l, n)) {
      const c = !Qt.length;
      for (const u of r)
        u[1](), Qt.push(u, e);
      if (c) {
        for (let u = 0; u < Qt.length; u += 2)
          Qt[u][0](Qt[u + 1]);
        Qt.length = 0;
      }
    }
  }
  function i(l) {
    o(l(e));
  }
  function s(l, c = go) {
    const u = [l, c];
    return r.add(u), r.size === 1 && (n = t(o, i) || go), l(e), () => {
      r.delete(u), r.size === 0 && n && (n(), n = null);
    };
  }
  return { set: o, update: i, subscribe: s };
}
const yu = (e) => {
  const { subscribe: t, set: n } = ni();
  let r;
  return t((o) => r = o), e.observe(({ changes: o }) => {
    if (r) {
      (o.deleted || []).some((s) => s.id === r) && n(void 0);
      const i = (o.updated || []).find(({ oldValue: s }) => s.id === r);
      i && n(i.newValue.id);
    }
  }), {
    get current() {
      return r;
    },
    subscribe: t,
    set: n
  };
}, vr = { selected: [] }, bu = (e, t, n) => {
  const { subscribe: r, set: o } = ni(vr);
  let i = t, s = vr;
  r((m) => s = m);
  const l = () => {
    qt(s, vr) || o(vr);
  }, c = () => {
    var m;
    return ((m = s.selected) == null ? void 0 : m.length) === 0;
  }, u = (m) => {
    if (c())
      return !1;
    const v = typeof m == "string" ? m : m.id;
    return s.selected.some((w) => w.id === v);
  }, f = (m, v) => {
    let w;
    if (Array.isArray(m)) {
      if (w = m.map((g) => e.getAnnotation(g)).filter(Boolean), w.length < m.length) {
        console.warn("Invalid selection: " + m.filter((g) => !w.some((x) => x.id === g)));
        return;
      }
    } else {
      const g = e.getAnnotation(m);
      if (!g) {
        console.warn("Invalid selection: " + m);
        return;
      }
      w = [g];
    }
    const b = w.reduce((g, x) => {
      const R = Ki(x, i);
      return R === "EDIT" ? [...g, { id: x.id, editable: !0 }] : R === "SELECT" ? [...g, { id: x.id }] : g;
    }, []);
    o({ selected: b, event: v });
  }, d = (m, v) => {
    const w = Array.isArray(m) ? m : [m], b = w.map((g) => e.getAnnotation(g)).filter((g) => !!g);
    o({
      selected: b.map((g) => {
        const x = v === void 0 ? Ki(g, i) === "EDIT" : v;
        return { id: g.id, editable: x };
      })
    }), b.length !== w.length && console.warn("Invalid selection", m);
  }, p = (m) => {
    if (c())
      return !1;
    const { selected: v } = s;
    v.some(({ id: w }) => m.includes(w)) && o({ selected: v.filter(({ id: w }) => !m.includes(w)) });
  }, h = (m) => i = m;
  return e.observe(
    ({ changes: m }) => p((m.deleted || []).map((v) => v.id))
  ), {
    get event() {
      return s ? s.event : null;
    },
    get selected() {
      return s ? [...s.selected] : null;
    },
    get userSelectAction() {
      return i;
    },
    clear: l,
    isEmpty: c,
    isSelected: u,
    setSelected: d,
    setUserSelectAction: h,
    subscribe: r,
    userSelect: f
  };
}, Ki = (e, t, n) => typeof t == "function" ? t(e) : t || "EDIT", je = [];
for (let e = 0; e < 256; ++e)
  je.push((e + 256).toString(16).slice(1));
function wu(e, t = 0) {
  return (je[e[t + 0]] + je[e[t + 1]] + je[e[t + 2]] + je[e[t + 3]] + "-" + je[e[t + 4]] + je[e[t + 5]] + "-" + je[e[t + 6]] + je[e[t + 7]] + "-" + je[e[t + 8]] + je[e[t + 9]] + "-" + je[e[t + 10]] + je[e[t + 11]] + je[e[t + 12]] + je[e[t + 13]] + je[e[t + 14]] + je[e[t + 15]]).toLowerCase();
}
let mo;
const xu = new Uint8Array(16);
function Eu() {
  if (!mo) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    mo = crypto.getRandomValues.bind(crypto);
  }
  return mo(xu);
}
const Au = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), Xi = { randomUUID: Au };
function Ru(e, t, n) {
  if (Xi.randomUUID && !t && !e)
    return Xi.randomUUID();
  e = e || {};
  const r = e.random || (e.rng || Eu)();
  return r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, wu(r);
}
const vo = (e) => {
  const t = (n) => {
    const r = { ...n };
    return n.created && typeof n.created == "string" && (r.created = new Date(n.created)), n.updated && typeof n.updated == "string" && (r.updated = new Date(n.updated)), r;
  };
  return {
    ...e,
    bodies: (e.bodies || []).map(t),
    target: t(e.target)
  };
}, Su = (e, t) => {
  const n = new Set(e.bodies.map((r) => r.id));
  return t.bodies.filter((r) => !n.has(r.id));
}, Ou = (e, t) => {
  const n = new Set(t.bodies.map((r) => r.id));
  return e.bodies.filter((r) => !n.has(r.id));
}, Tu = (e, t) => t.bodies.map((n) => {
  const r = e.bodies.find((o) => o.id === n.id);
  return { newBody: n, oldBody: r && !qt(r, n) ? r : void 0 };
}).filter(({ oldBody: n }) => n).map(({ oldBody: n, newBody: r }) => ({ oldBody: n, newBody: r })), Cu = (e, t) => !qt(e.target, t.target), es = (e, t) => {
  const n = Su(e, t), r = Ou(e, t), o = Tu(e, t);
  return {
    oldValue: e,
    newValue: t,
    bodiesCreated: n.length > 0 ? n : void 0,
    bodiesDeleted: r.length > 0 ? r : void 0,
    bodiesUpdated: o.length > 0 ? o : void 0,
    targetUpdated: Cu(e, t) ? { oldTarget: e.target, newTarget: t.target } : void 0
  };
};
var de = /* @__PURE__ */ ((e) => (e.LOCAL = "LOCAL", e.REMOTE = "REMOTE", e.SILENT = "SILENT", e))(de || {});
const ku = (e, t) => {
  var n, r;
  const { changes: o, origin: i } = t;
  if (!(e.options.origin ? e.options.origin === i : i !== "SILENT"))
    return !1;
  if (e.options.ignore) {
    const { ignore: s } = e.options, l = (c) => c && c.length > 0;
    if (!(l(o.created) || l(o.deleted))) {
      const c = (n = o.updated) == null ? void 0 : n.some((f) => l(f.bodiesCreated) || l(f.bodiesDeleted) || l(f.bodiesUpdated)), u = (r = o.updated) == null ? void 0 : r.some((f) => f.targetUpdated);
      if (s === "BODY_ONLY" && c && !u || s === "TARGET_ONLY" && u && !c)
        return !1;
    }
  }
  if (e.options.annotations) {
    const s = /* @__PURE__ */ new Set([
      ...(o.created || []).map((l) => l.id),
      ...(o.deleted || []).map((l) => l.id),
      ...(o.updated || []).map(({ oldValue: l }) => l.id)
    ]);
    return !!(Array.isArray(e.options.annotations) ? e.options.annotations : [e.options.annotations]).find((l) => s.has(l));
  } else
    return !0;
}, $u = (e, t) => {
  const n = new Set((e.created || []).map((d) => d.id)), r = new Set((e.updated || []).map(({ newValue: d }) => d.id)), o = new Set((t.created || []).map((d) => d.id)), i = new Set((t.deleted || []).map((d) => d.id)), s = new Set((t.updated || []).map(({ oldValue: d }) => d.id)), l = new Set((t.updated || []).filter(({ oldValue: d }) => n.has(d.id) || r.has(d.id)).map(({ oldValue: d }) => d.id)), c = [
    ...(e.created || []).filter((d) => !i.has(d.id)).map((d) => s.has(d.id) ? t.updated.find(({ oldValue: p }) => p.id === d.id).newValue : d),
    ...t.created || []
  ], u = [
    ...(e.deleted || []).filter((d) => !o.has(d.id)),
    ...(t.deleted || []).filter((d) => !n.has(d.id))
  ], f = [
    ...(e.updated || []).filter(({ newValue: d }) => !i.has(d.id)).map((d) => {
      const { oldValue: p, newValue: h } = d;
      if (s.has(h.id)) {
        const m = t.updated.find((v) => v.oldValue.id === h.id).newValue;
        return es(p, m);
      } else
        return d;
    }),
    ...(t.updated || []).filter(({ oldValue: d }) => !l.has(d.id))
  ];
  return { created: c, deleted: u, updated: f };
}, yo = (e) => {
  const t = e.id === void 0 ? Ru() : e.id;
  return {
    ...e,
    id: t,
    bodies: e.bodies === void 0 ? [] : e.bodies.map((n) => ({
      ...n,
      annotation: t
    })),
    target: {
      ...e.target,
      annotation: t
    }
  };
}, _u = (e) => e.id !== void 0, Pu = () => {
  const e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Map(), n = [], r = (O, S = {}) => {
    n.push({ onChange: O, options: S });
  }, o = (O) => {
    const S = n.findIndex(($) => $.onChange == O);
    S > -1 && n.splice(S, 1);
  }, i = (O, S) => {
    const $ = {
      origin: O,
      changes: {
        created: S.created || [],
        updated: S.updated || [],
        deleted: S.deleted || []
      },
      state: [...e.values()]
    };
    n.forEach((T) => {
      ku(T, $) && T.onChange($);
    });
  }, s = (O, S = de.LOCAL) => {
    if (O.id && e.get(O.id))
      throw Error(`Cannot add annotation ${O.id} - exists already`);
    {
      const $ = yo(O);
      e.set($.id, $), $.bodies.forEach((T) => t.set(T.id, $.id)), i(S, { created: [$] });
    }
  }, l = (O, S) => {
    const $ = yo(typeof O == "string" ? S : O), T = typeof O == "string" ? O : O.id, j = T && e.get(T);
    if (j) {
      const L = es(j, $);
      return T === $.id ? e.set(T, $) : (e.delete(T), e.set($.id, $)), j.bodies.forEach((Y) => t.delete(Y.id)), $.bodies.forEach((Y) => t.set(Y.id, $.id)), L;
    } else
      console.warn(`Cannot update annotation ${T} - does not exist`);
  }, c = (O, S = de.LOCAL, $ = de.LOCAL) => {
    const T = _u(S) ? $ : S, j = l(O, S);
    j && i(T, { updated: [j] });
  }, u = (O, S = de.LOCAL) => {
    const $ = O.reduce((T, j) => {
      const L = l(j);
      return L ? [...T, L] : T;
    }, []);
    $.length > 0 && i(S, { updated: $ });
  }, f = (O, S = de.LOCAL) => {
    const $ = e.get(O.annotation);
    if ($) {
      const T = {
        ...$,
        bodies: [...$.bodies, O]
      };
      e.set($.id, T), t.set(O.id, T.id), i(S, { updated: [{
        oldValue: $,
        newValue: T,
        bodiesCreated: [O]
      }] });
    } else
      console.warn(`Attempt to add body to missing annotation: ${O.annotation}`);
  }, d = () => [...e.values()], p = (O = de.LOCAL) => {
    const S = [...e.values()];
    e.clear(), t.clear(), i(O, { deleted: S });
  }, h = (O, S = !0, $ = de.LOCAL) => {
    const T = O.map(yo);
    if (S) {
      const j = [...e.values()];
      e.clear(), t.clear(), T.forEach((L) => {
        e.set(L.id, L), L.bodies.forEach((Y) => t.set(Y.id, L.id));
      }), i($, { created: T, deleted: j });
    } else {
      const j = O.reduce((L, Y) => {
        const z = Y.id && e.get(Y.id);
        return z ? [...L, z] : L;
      }, []);
      if (j.length > 0)
        throw Error(`Bulk insert would overwrite the following annotations: ${j.map((L) => L.id).join(", ")}`);
      T.forEach((L) => {
        e.set(L.id, L), L.bodies.forEach((Y) => t.set(Y.id, L.id));
      }), i($, { created: T });
    }
  }, m = (O) => {
    const S = typeof O == "string" ? O : O.id, $ = e.get(S);
    if ($)
      return e.delete(S), $.bodies.forEach((T) => t.delete(T.id)), $;
    console.warn(`Attempt to delete missing annotation: ${S}`);
  }, v = (O, S = de.LOCAL) => {
    const $ = m(O);
    $ && i(S, { deleted: [$] });
  }, w = (O, S = de.LOCAL) => {
    const $ = O.reduce((T, j) => {
      const L = m(j);
      return L ? [...T, L] : T;
    }, []);
    $.length > 0 && i(S, { deleted: $ });
  }, b = (O) => {
    const S = e.get(O.annotation);
    if (S) {
      const $ = S.bodies.find((T) => T.id === O.id);
      if ($) {
        t.delete($.id);
        const T = {
          ...S,
          bodies: S.bodies.filter((j) => j.id !== O.id)
        };
        return e.set(S.id, T), {
          oldValue: S,
          newValue: T,
          bodiesDeleted: [$]
        };
      } else
        console.warn(`Attempt to delete missing body ${O.id} from annotation ${O.annotation}`);
    } else
      console.warn(`Attempt to delete body from missing annotation ${O.annotation}`);
  }, g = (O, S = de.LOCAL) => {
    const $ = b(O);
    $ && i(S, { updated: [$] });
  }, x = (O, S = de.LOCAL) => {
    const $ = O.map((T) => b(T)).filter(Boolean);
    $.length > 0 && i(S, { updated: $ });
  }, R = (O) => {
    const S = e.get(O);
    return S ? { ...S } : void 0;
  }, A = (O) => {
    const S = t.get(O);
    if (S) {
      const $ = R(S).bodies.find((T) => T.id === O);
      if ($)
        return $;
      console.error(`Store integrity error: body ${O} in index, but not in annotation`);
    } else
      console.warn(`Attempt to retrieve missing body: ${O}`);
  }, P = (O, S) => {
    if (O.annotation !== S.annotation)
      throw "Annotation integrity violation: annotation ID must be the same when updating bodies";
    const $ = e.get(O.annotation);
    if ($) {
      const T = $.bodies.find((L) => L.id === O.id), j = {
        ...$,
        bodies: $.bodies.map((L) => L.id === T.id ? S : L)
      };
      return e.set($.id, j), T.id !== S.id && (t.delete(T.id), t.set(S.id, j.id)), {
        oldValue: $,
        newValue: j,
        bodiesUpdated: [{ oldBody: T, newBody: S }]
      };
    } else
      console.warn(`Attempt to add body to missing annotation ${O.annotation}`);
  }, _ = (O, S, $ = de.LOCAL) => {
    const T = P(O, S);
    T && i($, { updated: [T] });
  }, C = (O, S = de.LOCAL) => {
    const $ = O.map((T) => P({ id: T.id, annotation: T.annotation }, T)).filter(Boolean);
    i(S, { updated: $ });
  }, M = (O) => {
    const S = e.get(O.annotation);
    if (S) {
      const $ = {
        ...S,
        target: {
          ...S.target,
          ...O
        }
      };
      return e.set(S.id, $), {
        oldValue: S,
        newValue: $,
        targetUpdated: {
          oldTarget: S.target,
          newTarget: O
        }
      };
    } else
      console.warn(`Attempt to update target on missing annotation: ${O.annotation}`);
  };
  return {
    addAnnotation: s,
    addBody: f,
    all: d,
    bulkAddAnnotation: h,
    bulkDeleteAnnotation: w,
    bulkDeleteBodies: x,
    bulkUpdateAnnotation: u,
    bulkUpdateBodies: C,
    bulkUpdateTargets: (O, S = de.LOCAL) => {
      const $ = O.map((T) => M(T)).filter(Boolean);
      $.length > 0 && i(S, { updated: $ });
    },
    clear: p,
    deleteAnnotation: v,
    deleteBody: g,
    getAnnotation: R,
    getBody: A,
    observe: r,
    unobserve: o,
    updateAnnotation: c,
    updateBody: _,
    updateTarget: (O, S = de.LOCAL) => {
      const $ = M(O);
      $ && i(S, { updated: [$] });
    }
  };
};
let ju = () => ({
  emit(e, ...t) {
    for (let n = this.events[e] || [], r = 0, o = n.length; r < o; r++)
      n[r](...t);
  },
  events: {},
  on(e, t) {
    var n;
    return ((n = this.events)[e] || (n[e] = [])).push(t), () => {
      var r;
      this.events[e] = (r = this.events[e]) == null ? void 0 : r.filter((o) => t !== o);
    };
  }
});
const Nu = 250, Lu = (e, t) => {
  const n = ju(), r = [];
  let o = -1, i = !1, s = 0;
  const l = (m) => {
    if (!i) {
      const { changes: v } = m, w = performance.now();
      if (w - s > Nu)
        r.splice(o + 1), r.push(v), o = r.length - 1;
      else {
        const b = r.length - 1;
        r[b] = $u(r[b], v);
      }
      s = w;
    }
    i = !1;
  };
  e.observe(l, { origin: de.LOCAL });
  const c = (m) => m && m.length > 0 && e.bulkDeleteAnnotation(m), u = (m) => m && m.length > 0 && e.bulkAddAnnotation(m, !1), f = (m) => m && m.length > 0 && e.bulkUpdateAnnotation(m.map(({ oldValue: v }) => v)), d = (m) => m && m.length > 0 && e.bulkUpdateAnnotation(m.map(({ newValue: v }) => v)), p = (m) => m && m.length > 0 && e.bulkAddAnnotation(m, !1), h = (m) => m && m.length > 0 && e.bulkDeleteAnnotation(m);
  return {
    canRedo: () => r.length - 1 > o,
    canUndo: () => o > -1,
    destroy: () => e.unobserve(l),
    getHistory: () => ({ changes: [...r], pointer: o }),
    on: (m, v) => n.on(m, v),
    redo: () => {
      if (r.length - 1 > o) {
        i = !0;
        const { created: m, updated: v, deleted: w } = r[o + 1];
        u(m), d(v), h(w), n.emit("redo", r[o + 1]), o += 1;
      }
    },
    undo: () => {
      if (o > -1) {
        i = !0;
        const { created: m, updated: v, deleted: w } = r[o];
        c(m), f(v), p(w), n.emit("undo", r[o]), o -= 1;
      }
    }
  };
}, Iu = () => {
  const { subscribe: e, set: t } = ni([]);
  return {
    subscribe: e,
    set: t
  };
}, Du = (e, t, n, r) => {
  const { hover: o, selection: i, store: s, viewport: l } = e, c = /* @__PURE__ */ new Map();
  let u = [], f;
  const d = (v, w) => {
    c.has(v) ? c.get(v).push(w) : c.set(v, [w]);
  }, p = (v, w) => {
    const b = c.get(v);
    if (b) {
      const g = b.indexOf(w);
      g !== -1 && b.splice(g, 1);
    }
  }, h = (v, w, b) => {
    c.has(v) && setTimeout(() => {
      c.get(v).forEach((g) => {
        if (n) {
          const x = Array.isArray(w) ? w.map((A) => n.serialize(A)) : n.serialize(w), R = b ? b instanceof PointerEvent ? b : n.serialize(b) : void 0;
          g(x, R);
        } else
          g(w, b);
      });
    }, 1);
  };
  i.subscribe(({ selected: v }) => {
    if (!(u.length === 0 && v.length === 0)) {
      if (u.length === 0 && v.length > 0)
        u = v.map(({ id: w }) => s.getAnnotation(w));
      else if (u.length > 0 && v.length === 0)
        u.forEach((w) => {
          const b = s.getAnnotation(w.id);
          b && !qt(b, w) && h("updateAnnotation", b, w);
        }), u = [];
      else {
        const w = new Set(u.map((g) => g.id)), b = new Set(v.map(({ id: g }) => g));
        u.filter((g) => !b.has(g.id)).forEach((g) => {
          const x = s.getAnnotation(g.id);
          x && !qt(x, g) && h("updateAnnotation", x, g);
        }), u = [
          // Remove annotations that were deselected
          ...u.filter((g) => b.has(g.id)),
          // Add editable annotations that were selected
          ...v.filter(({ id: g }) => !w.has(g)).map(({ id: g }) => s.getAnnotation(g))
        ];
      }
      h("selectionChanged", u);
    }
  }), o.subscribe((v) => {
    !f && v ? h("mouseEnterAnnotation", s.getAnnotation(v)) : f && !v ? h("mouseLeaveAnnotation", s.getAnnotation(f)) : f && v && (h("mouseLeaveAnnotation", s.getAnnotation(f)), h("mouseEnterAnnotation", s.getAnnotation(v))), f = v;
  }), l == null || l.subscribe((v) => h("viewportIntersect", v.map((w) => s.getAnnotation(w)))), s.observe((v) => {
    const { created: w, deleted: b } = v.changes;
    (w || []).forEach((g) => h("createAnnotation", g)), (b || []).forEach((g) => h("deleteAnnotation", g)), (v.changes.updated || []).filter((g) => [
      ...g.bodiesCreated || [],
      ...g.bodiesDeleted || [],
      ...g.bodiesUpdated || []
    ].length > 0).forEach(({ oldValue: g, newValue: x }) => {
      const R = u.find((A) => A.id === g.id) || g;
      u = u.map((A) => A.id === g.id ? x : A), h("updateAnnotation", x, R);
    });
  }, { origin: de.LOCAL }), s.observe((v) => {
    if (u) {
      const w = new Set(u.map((g) => g.id)), b = (v.changes.updated || []).filter(({ newValue: g }) => w.has(g.id)).map(({ newValue: g }) => g);
      b.length > 0 && (u = u.map((g) => b.find((x) => x.id === g.id) || g));
    }
  }, { origin: de.REMOTE });
  const m = (v) => (w) => {
    const { updated: b } = w;
    v ? (b || []).forEach((g) => h("updateAnnotation", g.oldValue, g.newValue)) : (b || []).forEach((g) => h("updateAnnotation", g.newValue, g.oldValue));
  };
  return t.on("undo", m(!0)), t.on("redo", m(!1)), { on: d, off: p, emit: h };
}, Mu = (e) => (t) => t.reduce((n, r) => {
  const { parsed: o, error: i } = e.parse(r);
  return i ? {
    parsed: n.parsed,
    failed: [...n.failed, r]
  } : o ? {
    parsed: [...n.parsed, o],
    failed: n.failed
  } : {
    ...n
  };
}, { parsed: [], failed: [] }), Fu = (e, t, n) => {
  const { store: r, selection: o } = e, i = (b) => {
    if (n) {
      const { parsed: g, error: x } = n.parse(b);
      g ? r.addAnnotation(g, de.REMOTE) : console.error(x);
    } else
      r.addAnnotation(vo(b), de.REMOTE);
  }, s = () => o.clear(), l = () => r.clear(), c = (b) => {
    const g = r.getAnnotation(b);
    return n && g ? n.serialize(g) : g;
  }, u = () => n ? r.all().map(n.serialize) : r.all(), f = () => {
    var b;
    const g = (((b = o.selected) == null ? void 0 : b.map((x) => x.id)) || []).map((x) => r.getAnnotation(x)).filter(Boolean);
    return n ? g.map(n.serialize) : g;
  }, d = (b, g = !0) => fetch(b).then((x) => x.json()).then((x) => (h(x, g), x)), p = (b) => {
    if (typeof b == "string") {
      const g = r.getAnnotation(b);
      if (r.deleteAnnotation(b), g)
        return n ? n.serialize(g) : g;
    } else {
      const g = n ? n.parse(b).parsed : b;
      if (g)
        return r.deleteAnnotation(g), b;
    }
  }, h = (b, g = !0) => {
    if (n) {
      const x = n.parseAll || Mu(n), { parsed: R, failed: A } = x(b);
      A.length > 0 && console.warn(`Discarded ${A.length} invalid annotations`, A), r.bulkAddAnnotation(R, g, de.REMOTE);
    } else
      r.bulkAddAnnotation(b.map(vo), g, de.REMOTE);
  }, m = (b, g) => {
    b ? o.setSelected(b, g) : o.clear();
  }, v = (b) => {
    o.clear(), o.setUserSelectAction(b);
  }, w = (b) => {
    if (n) {
      const g = n.parse(b).parsed, x = n.serialize(r.getAnnotation(g.id));
      return r.updateAnnotation(g), x;
    } else {
      const g = r.getAnnotation(b.id);
      return r.updateAnnotation(vo(b)), g;
    }
  };
  return {
    addAnnotation: i,
    cancelSelected: s,
    canRedo: t.canRedo,
    canUndo: t.canUndo,
    clearAnnotations: l,
    getAnnotationById: c,
    getAnnotations: u,
    getHistory: t.getHistory,
    getSelected: f,
    loadAnnotations: d,
    redo: t.redo,
    removeAnnotation: p,
    setAnnotations: h,
    setSelected: m,
    setUserSelectAction: v,
    undo: t.undo,
    updateAnnotation: w
  };
}, Bu = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
let Uu = (e) => crypto.getRandomValues(new Uint8Array(e)), Vu = (e, t, n) => {
  let r = (2 << Math.log2(e.length - 1)) - 1, o = -~(1.6 * r * t / e.length);
  return (i = t) => {
    let s = "";
    for (; ; ) {
      let l = n(o), c = o | 0;
      for (; c--; )
        if (s += e[l[c] & r] || "", s.length >= i) return s;
    }
  };
}, Yu = (e, t = 21) => Vu(e, t | 0, Uu), Hu = (e = 21) => {
  let t = "", n = crypto.getRandomValues(new Uint8Array(e |= 0));
  for (; e--; )
    t += Bu[n[e] & 63];
  return t;
};
const Wu = () => ({ isGuest: !0, id: Yu("1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_", 20)() });
Hu();
function ts(e, t, n = 0, r = e.length - 1, o = Ku) {
  for (; r > n; ) {
    if (r - n > 600) {
      const c = r - n + 1, u = t - n + 1, f = Math.log(c), d = 0.5 * Math.exp(2 * f / 3), p = 0.5 * Math.sqrt(f * d * (c - d) / c) * (u - c / 2 < 0 ? -1 : 1), h = Math.max(n, Math.floor(t - u * d / c + p)), m = Math.min(r, Math.floor(t + (c - u) * d / c + p));
      ts(e, t, h, m, o);
    }
    const i = e[t];
    let s = n, l = r;
    for (Un(e, n, t), o(e[r], i) > 0 && Un(e, n, r); s < l; ) {
      for (Un(e, s, l), s++, l--; o(e[s], i) < 0; ) s++;
      for (; o(e[l], i) > 0; ) l--;
    }
    o(e[n], i) === 0 ? Un(e, n, l) : (l++, Un(e, l, r)), l <= t && (n = l + 1), t <= l && (r = l - 1);
  }
}
function Un(e, t, n) {
  const r = e[t];
  e[t] = e[n], e[n] = r;
}
function Ku(e, t) {
  return e < t ? -1 : e > t ? 1 : 0;
}
class Xu {
  constructor(t = 9) {
    this._maxEntries = Math.max(4, t), this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4)), this.clear();
  }
  all() {
    return this._all(this.data, []);
  }
  search(t) {
    let n = this.data;
    const r = [];
    if (!br(t, n)) return r;
    const o = this.toBBox, i = [];
    for (; n; ) {
      for (let s = 0; s < n.children.length; s++) {
        const l = n.children[s], c = n.leaf ? o(l) : l;
        br(t, c) && (n.leaf ? r.push(l) : wo(t, c) ? this._all(l, r) : i.push(l));
      }
      n = i.pop();
    }
    return r;
  }
  collides(t) {
    let n = this.data;
    if (!br(t, n)) return !1;
    const r = [];
    for (; n; ) {
      for (let o = 0; o < n.children.length; o++) {
        const i = n.children[o], s = n.leaf ? this.toBBox(i) : i;
        if (br(t, s)) {
          if (n.leaf || wo(t, s)) return !0;
          r.push(i);
        }
      }
      n = r.pop();
    }
    return !1;
  }
  load(t) {
    if (!(t && t.length)) return this;
    if (t.length < this._minEntries) {
      for (let r = 0; r < t.length; r++)
        this.insert(t[r]);
      return this;
    }
    let n = this._build(t.slice(), 0, t.length - 1, 0);
    if (!this.data.children.length)
      this.data = n;
    else if (this.data.height === n.height)
      this._splitRoot(this.data, n);
    else {
      if (this.data.height < n.height) {
        const r = this.data;
        this.data = n, n = r;
      }
      this._insert(n, this.data.height - n.height - 1, !0);
    }
    return this;
  }
  insert(t) {
    return t && this._insert(t, this.data.height - 1), this;
  }
  clear() {
    return this.data = on([]), this;
  }
  remove(t, n) {
    if (!t) return this;
    let r = this.data;
    const o = this.toBBox(t), i = [], s = [];
    let l, c, u;
    for (; r || i.length; ) {
      if (r || (r = i.pop(), c = i[i.length - 1], l = s.pop(), u = !0), r.leaf) {
        const f = zu(t, r.children, n);
        if (f !== -1)
          return r.children.splice(f, 1), i.push(r), this._condense(i), this;
      }
      !u && !r.leaf && wo(r, o) ? (i.push(r), s.push(l), l = 0, c = r, r = r.children[0]) : c ? (l++, r = c.children[l], u = !1) : r = null;
    }
    return this;
  }
  toBBox(t) {
    return t;
  }
  compareMinX(t, n) {
    return t.minX - n.minX;
  }
  compareMinY(t, n) {
    return t.minY - n.minY;
  }
  toJSON() {
    return this.data;
  }
  fromJSON(t) {
    return this.data = t, this;
  }
  _all(t, n) {
    const r = [];
    for (; t; )
      t.leaf ? n.push(...t.children) : r.push(...t.children), t = r.pop();
    return n;
  }
  _build(t, n, r, o) {
    const i = r - n + 1;
    let s = this._maxEntries, l;
    if (i <= s)
      return l = on(t.slice(n, r + 1)), en(l, this.toBBox), l;
    o || (o = Math.ceil(Math.log(i) / Math.log(s)), s = Math.ceil(i / Math.pow(s, o - 1))), l = on([]), l.leaf = !1, l.height = o;
    const c = Math.ceil(i / s), u = c * Math.ceil(Math.sqrt(s));
    zi(t, n, r, u, this.compareMinX);
    for (let f = n; f <= r; f += u) {
      const d = Math.min(f + u - 1, r);
      zi(t, f, d, c, this.compareMinY);
      for (let p = f; p <= d; p += c) {
        const h = Math.min(p + c - 1, d);
        l.children.push(this._build(t, p, h, o - 1));
      }
    }
    return en(l, this.toBBox), l;
  }
  _chooseSubtree(t, n, r, o) {
    for (; o.push(n), !(n.leaf || o.length - 1 === r); ) {
      let i = 1 / 0, s = 1 / 0, l;
      for (let c = 0; c < n.children.length; c++) {
        const u = n.children[c], f = bo(u), d = Ju(t, u) - f;
        d < s ? (s = d, i = f < i ? f : i, l = u) : d === s && f < i && (i = f, l = u);
      }
      n = l || n.children[0];
    }
    return n;
  }
  _insert(t, n, r) {
    const o = r ? t : this.toBBox(t), i = [], s = this._chooseSubtree(o, this.data, n, i);
    for (s.children.push(t), Kn(s, o); n >= 0 && i[n].children.length > this._maxEntries; )
      this._split(i, n), n--;
    this._adjustParentBBoxes(o, i, n);
  }
  // split overflowed node into two
  _split(t, n) {
    const r = t[n], o = r.children.length, i = this._minEntries;
    this._chooseSplitAxis(r, i, o);
    const s = this._chooseSplitIndex(r, i, o), l = on(r.children.splice(s, r.children.length - s));
    l.height = r.height, l.leaf = r.leaf, en(r, this.toBBox), en(l, this.toBBox), n ? t[n - 1].children.push(l) : this._splitRoot(r, l);
  }
  _splitRoot(t, n) {
    this.data = on([t, n]), this.data.height = t.height + 1, this.data.leaf = !1, en(this.data, this.toBBox);
  }
  _chooseSplitIndex(t, n, r) {
    let o, i = 1 / 0, s = 1 / 0;
    for (let l = n; l <= r - n; l++) {
      const c = Wn(t, 0, l, this.toBBox), u = Wn(t, l, r, this.toBBox), f = Zu(c, u), d = bo(c) + bo(u);
      f < i ? (i = f, o = l, s = d < s ? d : s) : f === i && d < s && (s = d, o = l);
    }
    return o || r - n;
  }
  // sorts node children by the best axis for split
  _chooseSplitAxis(t, n, r) {
    const o = t.leaf ? this.compareMinX : qu, i = t.leaf ? this.compareMinY : Gu, s = this._allDistMargin(t, n, r, o), l = this._allDistMargin(t, n, r, i);
    s < l && t.children.sort(o);
  }
  // total margin of all possible split distributions where each node is at least m full
  _allDistMargin(t, n, r, o) {
    t.children.sort(o);
    const i = this.toBBox, s = Wn(t, 0, n, i), l = Wn(t, r - n, r, i);
    let c = yr(s) + yr(l);
    for (let u = n; u < r - n; u++) {
      const f = t.children[u];
      Kn(s, t.leaf ? i(f) : f), c += yr(s);
    }
    for (let u = r - n - 1; u >= n; u--) {
      const f = t.children[u];
      Kn(l, t.leaf ? i(f) : f), c += yr(l);
    }
    return c;
  }
  _adjustParentBBoxes(t, n, r) {
    for (let o = r; o >= 0; o--)
      Kn(n[o], t);
  }
  _condense(t) {
    for (let n = t.length - 1, r; n >= 0; n--)
      t[n].children.length === 0 ? n > 0 ? (r = t[n - 1].children, r.splice(r.indexOf(t[n]), 1)) : this.clear() : en(t[n], this.toBBox);
  }
}
function zu(e, t, n) {
  if (!n) return t.indexOf(e);
  for (let r = 0; r < t.length; r++)
    if (n(e, t[r])) return r;
  return -1;
}
function en(e, t) {
  Wn(e, 0, e.children.length, t, e);
}
function Wn(e, t, n, r, o) {
  o || (o = on(null)), o.minX = 1 / 0, o.minY = 1 / 0, o.maxX = -1 / 0, o.maxY = -1 / 0;
  for (let i = t; i < n; i++) {
    const s = e.children[i];
    Kn(o, e.leaf ? r(s) : s);
  }
  return o;
}
function Kn(e, t) {
  return e.minX = Math.min(e.minX, t.minX), e.minY = Math.min(e.minY, t.minY), e.maxX = Math.max(e.maxX, t.maxX), e.maxY = Math.max(e.maxY, t.maxY), e;
}
function qu(e, t) {
  return e.minX - t.minX;
}
function Gu(e, t) {
  return e.minY - t.minY;
}
function bo(e) {
  return (e.maxX - e.minX) * (e.maxY - e.minY);
}
function yr(e) {
  return e.maxX - e.minX + (e.maxY - e.minY);
}
function Ju(e, t) {
  return (Math.max(t.maxX, e.maxX) - Math.min(t.minX, e.minX)) * (Math.max(t.maxY, e.maxY) - Math.min(t.minY, e.minY));
}
function Zu(e, t) {
  const n = Math.max(e.minX, t.minX), r = Math.max(e.minY, t.minY), o = Math.min(e.maxX, t.maxX), i = Math.min(e.maxY, t.maxY);
  return Math.max(0, o - n) * Math.max(0, i - r);
}
function wo(e, t) {
  return e.minX <= t.minX && e.minY <= t.minY && t.maxX <= e.maxX && t.maxY <= e.maxY;
}
function br(e, t) {
  return t.minX <= e.maxX && t.minY <= e.maxY && t.maxX >= e.minX && t.maxY >= e.minY;
}
function on(e) {
  return {
    children: e,
    height: 1,
    leaf: !0,
    minX: 1 / 0,
    minY: 1 / 0,
    maxX: -1 / 0,
    maxY: -1 / 0
  };
}
function zi(e, t, n, r, o) {
  const i = [t, n];
  for (; i.length; ) {
    if (n = i.pop(), t = i.pop(), n - t <= r) continue;
    const s = t + Math.ceil((n - t) / r / 2) * r;
    ts(e, s, t, n, o), i.push(t, s, s, n);
  }
}
const Qu = (e, t) => {
  const n = new Xu(), r = /* @__PURE__ */ new Map(), o = (m, v) => {
    const w = m.selector.flatMap((g) => {
      const x = mt([g]) ? g.range : qa(g, t).range;
      return Array.from(x.getClientRects());
    }), b = Uc(w).map(({ left: g, top: x, right: R, bottom: A }) => new DOMRect(g - v.left, x - v.top, R - g, A - x));
    return b.map((g) => {
      const { x, y: R, width: A, height: P } = g;
      return {
        minX: x,
        minY: R,
        maxX: x + A,
        maxY: R + P,
        annotation: {
          id: m.annotation,
          rects: b
        }
      };
    });
  }, i = () => [...r.values()], s = () => {
    n.clear(), r.clear();
  }, l = (m) => {
    const v = o(m, t.getBoundingClientRect());
    v.length !== 0 && (v.forEach((w) => n.insert(w)), r.set(m.annotation, v));
  }, c = (m) => {
    const v = r.get(m.annotation);
    v && (v.forEach((w) => n.remove(w)), r.delete(m.annotation));
  }, u = (m) => {
    c(m), l(m);
  }, f = (m, v = !0) => {
    v && s();
    const w = t.getBoundingClientRect(), b = m.map((x) => ({ target: x, rects: o(x, w) }));
    b.forEach(({ target: x, rects: R }) => {
      R.length > 0 && r.set(x.annotation, R);
    });
    const g = b.flatMap(({ rects: x }) => x);
    n.load(g);
  }, d = (m, v, w = !1) => {
    const b = n.search({
      minX: m,
      minY: v,
      maxX: m,
      maxY: v
    }), g = (x) => x.annotation.rects.reduce((R, A) => R + A.width * A.height, 0);
    return b.length > 0 ? (b.sort((x, R) => g(x) - g(R)), w ? b.map((x) => x.annotation.id) : [b[0].annotation.id]) : [];
  }, p = (m) => {
    const v = h(m);
    if (v.length === 0)
      return;
    let w = v[0].left, b = v[0].top, g = v[0].right, x = v[0].bottom;
    for (let R = 1; R < v.length; R++) {
      const A = v[R];
      w = Math.min(w, A.left), b = Math.min(b, A.top), g = Math.max(g, A.right), x = Math.max(x, A.bottom);
    }
    return new DOMRect(w, b, g - w, x - b);
  }, h = (m) => {
    const v = r.get(m);
    return v ? v[0].annotation.rects : [];
  };
  return {
    all: i,
    clear: s,
    getAt: d,
    getAnnotationBounds: p,
    getAnnotationRects: h,
    getIntersecting: (m, v, w, b) => {
      const g = n.search({ minX: m, minY: v, maxX: w, maxY: b }), x = new Set(g.map((R) => R.annotation.id));
      return Array.from(x).map((R) => ({
        annotation: e.getAnnotation(R),
        rects: h(R)
      })).filter((R) => !!R.annotation);
    },
    insert: l,
    recalculate: () => f(e.all().map((m) => m.target), !0),
    remove: c,
    set: f,
    size: () => n.all().length,
    update: u
  };
}, ed = (e, t) => {
  const n = Pu(), r = Qu(n, e), o = bu(n);
  o.setUserSelectAction(t);
  const i = yu(n), s = Iu(), l = (b, g = de.LOCAL) => {
    const x = co(b, e), R = mt(x.target.selector);
    return R && n.addAnnotation(x, g), R;
  }, c = (b, g = !0, x = de.LOCAL) => {
    const R = b.map((P) => co(P, e)), A = R.filter((P) => !mt(P.target.selector));
    return n.bulkAddAnnotation(R, g, x), A;
  }, u = (b, g = de.LOCAL) => {
    const x = b.map((A) => co(A, e)), R = x.filter((A) => !mt(A.target.selector));
    return x.forEach((A) => {
      n.getAnnotation(A.id) ? n.updateAnnotation(A, g) : n.addAnnotation(A, g);
    }), R;
  }, f = (b, g = de.LOCAL) => {
    const x = Nr(b, e);
    n.updateTarget(x, g);
  }, d = (b, g = de.LOCAL) => {
    const x = b.map((R) => Nr(R, e));
    n.bulkUpdateTargets(x, g);
  };
  function p(b, g, x, R) {
    const A = x || !!R, P = r.getAt(b, g, A).map((C) => n.getAnnotation(C)), _ = R ? P.filter(R) : P;
    if (_.length !== 0)
      return x ? _ : _[0];
  }
  const h = (b) => {
    if (r.getAnnotationRects(b).length !== 0)
      return r.getAnnotationBounds(b);
  }, m = (b, g, x, R) => r.getIntersecting(b, g, x, R), v = (b) => r.getAnnotationRects(b), w = () => r.recalculate();
  return n.observe(({ changes: b }) => {
    const g = (b.deleted || []).filter((A) => mt(A.target.selector)), x = (b.created || []).filter((A) => mt(A.target.selector)), R = (b.updated || []).filter((A) => mt(A.newValue.target.selector));
    (g == null ? void 0 : g.length) > 0 && g.forEach((A) => r.remove(A.target)), x.length > 0 && r.set(x.map((A) => A.target), !1), (R == null ? void 0 : R.length) > 0 && R.forEach(({ newValue: A }) => r.update(A.target));
  }), {
    store: {
      ...n,
      addAnnotation: l,
      bulkAddAnnotation: c,
      bulkUpdateTargets: d,
      bulkUpsertAnnotations: u,
      getAnnotationBounds: h,
      getAnnotationRects: v,
      getIntersecting: m,
      getAt: p,
      recalculatePositions: w,
      updateTarget: f
    },
    selection: o,
    hover: i,
    viewport: s
  };
}, td = () => {
  const e = document.createElement("canvas");
  e.width = 2 * window.innerWidth, e.height = 2 * window.innerHeight, e.className = "r6o-presence-layer";
  const t = e.getContext("2d");
  return t.scale(2, 2), t.translate(0.5, 0.5), e;
}, nd = (e, t = {}) => {
  const n = td(), r = n.getContext("2d");
  document.body.appendChild(n);
  const o = /* @__PURE__ */ new Map(), i = (s) => Array.from(o.entries()).filter(([l, c]) => c.presenceKey === s.presenceKey).map(([l, c]) => l);
  return e.on("selectionChange", (s, l) => {
    i(s).forEach((c) => o.delete(c)), l && l.forEach((c) => o.set(c, s));
  }), {
    clear: () => {
      const { width: s, height: l } = n;
      r.clearRect(-0.5, -0.5, s + 1, l + 1);
    },
    destroy: () => {
      n.remove();
    },
    paint: (s, l, c) => {
      t.font && (r.font = t.font);
      const u = o.get(s.annotation.id);
      if (u) {
        const { height: f } = s.rects[0], d = s.rects[0].x + l.left, p = s.rects[0].y + l.top;
        r.fillStyle = u.appearance.color, r.fillRect(d - 2, p - 2.5, 2, f + 5);
        const h = r.measureText(u.appearance.label), m = h.width + 6, v = h.actualBoundingBoxAscent + h.actualBoundingBoxDescent + 8, w = h.fontBoundingBoxAscent ? 8 : 6.5;
        return r.fillRect(d - 2, p - 2.5 - v, m, v), r.fillStyle = "#fff", r.fillText(u.appearance.label, d + 1, p - w), {
          fill: u.appearance.color,
          fillOpacity: c ? 0.45 : 0.18
        };
      }
    },
    reset: () => {
      n.width = 2 * window.innerWidth, n.height = 2 * window.innerHeight;
      const s = n.getContext("2d");
      s.scale(2, 2), s.translate(0.5, 0.5);
    }
  };
}, xo = typeof navigator < "u" ? navigator.userAgent.toLowerCase().indexOf("firefox") > 0 : !1;
function Eo(e, t, n, r) {
  e.addEventListener ? e.addEventListener(t, n, r) : e.attachEvent && e.attachEvent("on".concat(t), n);
}
function Vn(e, t, n, r) {
  e.removeEventListener ? e.removeEventListener(t, n, r) : e.detachEvent && e.detachEvent("on".concat(t), n);
}
function ns(e, t) {
  const n = t.slice(0, t.length - 1);
  for (let r = 0; r < n.length; r++) n[r] = e[n[r].toLowerCase()];
  return n;
}
function rs(e) {
  typeof e != "string" && (e = ""), e = e.replace(/\s/g, "");
  const t = e.split(",");
  let n = t.lastIndexOf("");
  for (; n >= 0; )
    t[n - 1] += ",", t.splice(n, 1), n = t.lastIndexOf("");
  return t;
}
function rd(e, t) {
  const n = e.length >= t.length ? e : t, r = e.length >= t.length ? t : e;
  let o = !0;
  for (let i = 0; i < n.length; i++)
    r.indexOf(n[i]) === -1 && (o = !1);
  return o;
}
const or = {
  backspace: 8,
  "⌫": 8,
  tab: 9,
  clear: 12,
  enter: 13,
  "↩": 13,
  return: 13,
  esc: 27,
  escape: 27,
  space: 32,
  left: 37,
  up: 38,
  right: 39,
  down: 40,
  del: 46,
  delete: 46,
  ins: 45,
  insert: 45,
  home: 36,
  end: 35,
  pageup: 33,
  pagedown: 34,
  capslock: 20,
  num_0: 96,
  num_1: 97,
  num_2: 98,
  num_3: 99,
  num_4: 100,
  num_5: 101,
  num_6: 102,
  num_7: 103,
  num_8: 104,
  num_9: 105,
  num_multiply: 106,
  num_add: 107,
  num_enter: 108,
  num_subtract: 109,
  num_decimal: 110,
  num_divide: 111,
  "⇪": 20,
  ",": 188,
  ".": 190,
  "/": 191,
  "`": 192,
  "-": xo ? 173 : 189,
  "=": xo ? 61 : 187,
  ";": xo ? 59 : 186,
  "'": 222,
  "[": 219,
  "]": 221,
  "\\": 220
}, dt = {
  // shiftKey
  "⇧": 16,
  shift: 16,
  // altKey
  "⌥": 18,
  alt: 18,
  option: 18,
  // ctrlKey
  "⌃": 17,
  ctrl: 17,
  control: 17,
  // metaKey
  "⌘": 91,
  cmd: 91,
  command: 91
}, Tr = {
  16: "shiftKey",
  18: "altKey",
  17: "ctrlKey",
  91: "metaKey",
  shiftKey: 16,
  ctrlKey: 17,
  altKey: 18,
  metaKey: 91
}, Ie = {
  16: !1,
  18: !1,
  17: !1,
  91: !1
}, xe = {};
for (let e = 1; e < 20; e++)
  or["f".concat(e)] = 111 + e;
let ve = [], Jn = null, os = "all";
const gt = /* @__PURE__ */ new Map(), ur = (e) => or[e.toLowerCase()] || dt[e.toLowerCase()] || e.toUpperCase().charCodeAt(0), od = (e) => Object.keys(or).find((t) => or[t] === e), id = (e) => Object.keys(dt).find((t) => dt[t] === e);
function is(e) {
  os = e || "all";
}
function ir() {
  return os || "all";
}
function ad() {
  return ve.slice(0);
}
function sd() {
  return ve.map((e) => od(e) || id(e) || String.fromCharCode(e));
}
function ld() {
  const e = [];
  return Object.keys(xe).forEach((t) => {
    xe[t].forEach((n) => {
      let {
        key: r,
        scope: o,
        mods: i,
        shortcut: s
      } = n;
      e.push({
        scope: o,
        shortcut: s,
        mods: i,
        keys: r.split("+").map((l) => ur(l))
      });
    });
  }), e;
}
function cd(e) {
  const t = e.target || e.srcElement, {
    tagName: n
  } = t;
  let r = !0;
  const o = n === "INPUT" && !["checkbox", "radio", "range", "button", "file", "reset", "submit", "color"].includes(t.type);
  return (t.isContentEditable || (o || n === "TEXTAREA" || n === "SELECT") && !t.readOnly) && (r = !1), r;
}
function ud(e) {
  return typeof e == "string" && (e = ur(e)), ve.indexOf(e) !== -1;
}
function dd(e, t) {
  let n, r;
  e || (e = ir());
  for (const o in xe)
    if (Object.prototype.hasOwnProperty.call(xe, o))
      for (n = xe[o], r = 0; r < n.length; )
        n[r].scope === e ? n.splice(r, 1).forEach((i) => {
          let {
            element: s
          } = i;
          return ri(s);
        }) : r++;
  ir() === e && is(t || "all");
}
function fd(e) {
  let t = e.keyCode || e.which || e.charCode;
  const n = ve.indexOf(t);
  if (n >= 0 && ve.splice(n, 1), e.key && e.key.toLowerCase() === "meta" && ve.splice(0, ve.length), (t === 93 || t === 224) && (t = 91), t in Ie) {
    Ie[t] = !1;
    for (const r in dt) dt[r] === t && (Je[r] = !1);
  }
}
function as(e) {
  if (typeof e > "u")
    Object.keys(xe).forEach((o) => {
      Array.isArray(xe[o]) && xe[o].forEach((i) => wr(i)), delete xe[o];
    }), ri(null);
  else if (Array.isArray(e))
    e.forEach((o) => {
      o.key && wr(o);
    });
  else if (typeof e == "object")
    e.key && wr(e);
  else if (typeof e == "string") {
    for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
      n[r - 1] = arguments[r];
    let [o, i] = n;
    typeof o == "function" && (i = o, o = ""), wr({
      key: e,
      scope: o,
      method: i,
      splitKey: "+"
    });
  }
}
const wr = (e) => {
  let {
    key: t,
    scope: n,
    method: r,
    splitKey: o = "+"
  } = e;
  rs(t).forEach((i) => {
    const s = i.split(o), l = s.length, c = s[l - 1], u = c === "*" ? "*" : ur(c);
    if (!xe[u]) return;
    n || (n = ir());
    const f = l > 1 ? ns(dt, s) : [], d = [];
    xe[u] = xe[u].filter((p) => {
      const h = (r ? p.method === r : !0) && p.scope === n && rd(p.mods, f);
      return h && d.push(p.element), !h;
    }), d.forEach((p) => ri(p));
  });
};
function qi(e, t, n, r) {
  if (t.element !== r)
    return;
  let o;
  if (t.scope === n || t.scope === "all") {
    o = t.mods.length > 0;
    for (const i in Ie)
      Object.prototype.hasOwnProperty.call(Ie, i) && (!Ie[i] && t.mods.indexOf(+i) > -1 || Ie[i] && t.mods.indexOf(+i) === -1) && (o = !1);
    (t.mods.length === 0 && !Ie[16] && !Ie[18] && !Ie[17] && !Ie[91] || o || t.shortcut === "*") && (t.keys = [], t.keys = t.keys.concat(ve), t.method(e, t) === !1 && (e.preventDefault ? e.preventDefault() : e.returnValue = !1, e.stopPropagation && e.stopPropagation(), e.cancelBubble && (e.cancelBubble = !0)));
  }
}
function Gi(e, t) {
  const n = xe["*"];
  let r = e.keyCode || e.which || e.charCode;
  if (!Je.filter.call(this, e)) return;
  if ((r === 93 || r === 224) && (r = 91), ve.indexOf(r) === -1 && r !== 229 && ve.push(r), ["metaKey", "ctrlKey", "altKey", "shiftKey"].forEach((l) => {
    const c = Tr[l];
    e[l] && ve.indexOf(c) === -1 ? ve.push(c) : !e[l] && ve.indexOf(c) > -1 ? ve.splice(ve.indexOf(c), 1) : l === "metaKey" && e[l] && (ve = ve.filter((u) => u in Tr || u === r));
  }), r in Ie) {
    Ie[r] = !0;
    for (const l in dt)
      dt[l] === r && (Je[l] = !0);
    if (!n) return;
  }
  for (const l in Ie)
    Object.prototype.hasOwnProperty.call(Ie, l) && (Ie[l] = e[Tr[l]]);
  e.getModifierState && !(e.altKey && !e.ctrlKey) && e.getModifierState("AltGraph") && (ve.indexOf(17) === -1 && ve.push(17), ve.indexOf(18) === -1 && ve.push(18), Ie[17] = !0, Ie[18] = !0);
  const o = ir();
  if (n)
    for (let l = 0; l < n.length; l++)
      n[l].scope === o && (e.type === "keydown" && n[l].keydown || e.type === "keyup" && n[l].keyup) && qi(e, n[l], o, t);
  if (!(r in xe)) return;
  const i = xe[r], s = i.length;
  for (let l = 0; l < s; l++)
    if ((e.type === "keydown" && i[l].keydown || e.type === "keyup" && i[l].keyup) && i[l].key) {
      const c = i[l], {
        splitKey: u
      } = c, f = c.key.split(u), d = [];
      for (let p = 0; p < f.length; p++)
        d.push(ur(f[p]));
      d.sort().join("") === ve.sort().join("") && qi(e, c, o, t);
    }
}
function Je(e, t, n) {
  ve = [];
  const r = rs(e);
  let o = [], i = "all", s = document, l = 0, c = !1, u = !0, f = "+", d = !1, p = !1;
  for (n === void 0 && typeof t == "function" && (n = t), Object.prototype.toString.call(t) === "[object Object]" && (t.scope && (i = t.scope), t.element && (s = t.element), t.keyup && (c = t.keyup), t.keydown !== void 0 && (u = t.keydown), t.capture !== void 0 && (d = t.capture), typeof t.splitKey == "string" && (f = t.splitKey), t.single === !0 && (p = !0)), typeof t == "string" && (i = t), p && as(e, i); l < r.length; l++)
    e = r[l].split(f), o = [], e.length > 1 && (o = ns(dt, e)), e = e[e.length - 1], e = e === "*" ? "*" : ur(e), e in xe || (xe[e] = []), xe[e].push({
      keyup: c,
      keydown: u,
      scope: i,
      mods: o,
      shortcut: r[l],
      method: n,
      key: r[l],
      splitKey: f,
      element: s
    });
  if (typeof s < "u" && window) {
    if (!gt.has(s)) {
      const h = function() {
        let v = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.event;
        return Gi(v, s);
      }, m = function() {
        let v = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.event;
        Gi(v, s), fd(v);
      };
      gt.set(s, {
        keydownListener: h,
        keyupListenr: m,
        capture: d
      }), Eo(s, "keydown", h, d), Eo(s, "keyup", m, d);
    }
    if (!Jn) {
      const h = () => {
        ve = [];
      };
      Jn = {
        listener: h,
        capture: d
      }, Eo(window, "focus", h, d);
    }
  }
}
function pd(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "all";
  Object.keys(xe).forEach((n) => {
    xe[n].filter((r) => r.scope === t && r.shortcut === e).forEach((r) => {
      r && r.method && r.method();
    });
  });
}
function ri(e) {
  const t = Object.values(xe).flat();
  if (t.findIndex((n) => {
    let {
      element: r
    } = n;
    return r === e;
  }) < 0) {
    const {
      keydownListener: n,
      keyupListenr: r,
      capture: o
    } = gt.get(e) || {};
    n && r && (Vn(e, "keyup", r, o), Vn(e, "keydown", n, o), gt.delete(e));
  }
  if ((t.length <= 0 || gt.size <= 0) && (Object.keys(gt).forEach((n) => {
    const {
      keydownListener: r,
      keyupListenr: o,
      capture: i
    } = gt.get(n) || {};
    r && o && (Vn(n, "keyup", o, i), Vn(n, "keydown", r, i), gt.delete(n));
  }), gt.clear(), Object.keys(xe).forEach((n) => delete xe[n]), Jn)) {
    const {
      listener: n,
      capture: r
    } = Jn;
    Vn(window, "focus", n, r), Jn = null;
  }
}
const Ao = {
  getPressedKeyString: sd,
  setScope: is,
  getScope: ir,
  deleteScope: dd,
  getPressedKeyCodes: ad,
  getAllKeyCodes: ld,
  isPressed: ud,
  filter: cd,
  trigger: pd,
  unbind: as,
  keyMap: or,
  modifier: dt,
  modifierMap: Tr
};
for (const e in Ao)
  Object.prototype.hasOwnProperty.call(Ao, e) && (Je[e] = Ao[e]);
if (typeof window < "u") {
  const e = window.hotkeys;
  Je.noConflict = (t) => (t && window.hotkeys === Je && (window.hotkeys = e), Je), window.hotkeys = Je;
}
const Ji = 300, ss = ["up", "down", "left", "right"], ls = Pc ? "⌘+a" : "ctrl+a", hd = [
  ...ss.map((e) => `shift+${e}`),
  ls
], gd = (e, t, n) => {
  let r;
  const { annotatingEnabled: o, offsetReferenceSelector: i, selectionMode: s } = n, l = (C) => r = C;
  let c;
  const u = (C) => c = C, { store: f, selection: d } = t;
  let p, h, m;
  const v = (C) => {
    h !== !1 && (p = Hn(C.target) ? void 0 : {
      annotation: mu(),
      selector: [],
      creator: r,
      created: /* @__PURE__ */ new Date()
    });
  }, w = ei((C) => {
    const M = document.getSelection();
    if (!(M != null && M.anchorNode))
      return;
    if (Hn(M.anchorNode)) {
      p = void 0;
      return;
    }
    const O = C.timeStamp - ((m == null ? void 0 : m.timeStamp) || C.timeStamp);
    if ((m == null ? void 0 : m.type) === "pointerdown" && (O < 1e3 && !p || M.isCollapsed && O < Ji) && v(m || C), !p) return;
    if (M.isCollapsed) {
      f.getAnnotation(p.annotation) && (d.clear(), f.deleteAnnotation(p.annotation));
      return;
    }
    const S = M.getRangeAt(0), $ = Hc(S, e);
    if (Mc($)) return;
    const T = Lc($.cloneRange());
    (T.length !== p.selector.length || T.some((j, L) => {
      var Y;
      return j.toString() !== ((Y = p.selector[L]) == null ? void 0 : Y.quote);
    })) && (p = {
      ...p,
      selector: T.map((j) => Yc(j, e, i)),
      updated: /* @__PURE__ */ new Date()
    }, f.getAnnotation(p.annotation) ? f.updateTarget(p, de.LOCAL) : d.clear());
  }), b = (C) => {
    Hn(C.target) || (m = lo(C), h = m.button === 0);
  }, g = (C) => {
    if (Hn(C.target) || !h) return;
    const M = () => {
      const { x: S, y: $ } = e.getBoundingClientRect(), T = C.target instanceof Node && e.contains(C.target) && f.getAt(C.clientX - S, C.clientY - $, s === "all", c);
      if (T) {
        const { selected: j } = d, L = new Set(j.map((z) => z.id)), Y = Array.isArray(T) ? T.map((z) => z.id) : [T.id];
        (L.size !== Y.length || !Y.every((z) => L.has(z))) && d.userSelect(Y, C);
      } else
        d.clear();
    }, O = C.timeStamp - m.timeStamp;
    setTimeout(() => {
      const S = document.getSelection();
      S != null && S.isCollapsed && O < Ji ? (p = void 0, M()) : p && p.selector.length > 0 && (_(), d.userSelect(p.annotation, lo(C)));
    });
  }, x = (C) => {
    const M = document.getSelection();
    M != null && M.isCollapsed || ((!p || p.selector.length === 0) && w(C), _(), d.userSelect(p.annotation, lo(C)));
  }, R = (C) => {
    C.key === "Shift" && p && (document.getSelection().isCollapsed || (_(), d.userSelect(p.annotation, gr(C))));
  }, A = (C) => {
    const M = () => setTimeout(() => {
      (p == null ? void 0 : p.selector.length) > 0 && (d.clear(), f.addAnnotation({
        id: p.annotation,
        bodies: [],
        target: p
      }), d.userSelect(p.annotation, gr(C))), document.removeEventListener("selectionchange", M);
    }, 100);
    document.addEventListener("selectionchange", M), v(C);
  };
  Je(hd.join(","), { element: e, keydown: !0, keyup: !1 }, (C) => {
    C.repeat || (m = gr(C));
  }), Je(ls, { keydown: !0, keyup: !1 }, (C) => {
    m = gr(C), A(C);
  });
  const P = (C) => {
    C.repeat || C.target !== e && C.target !== document.body || (p = void 0, d.clear());
  };
  Je(ss.join(","), { keydown: !0, keyup: !1 }, P);
  const _ = () => {
    const C = f.getAnnotation(p.annotation);
    if (!C) {
      f.addAnnotation({
        id: p.annotation,
        bodies: [],
        target: p
      });
      return;
    }
    const { target: { updated: M } } = C, { updated: O } = p;
    (!M || !O || M < O) && f.updateTarget(p);
  };
  return e.addEventListener("pointerdown", b), document.addEventListener("pointerup", g), document.addEventListener("contextmenu", x), o && (e.addEventListener("keyup", R), e.addEventListener("selectstart", v), document.addEventListener("selectionchange", w)), {
    destroy: () => {
      e.removeEventListener("pointerdown", b), document.removeEventListener("pointerup", g), document.removeEventListener("contextmenu", x), e.removeEventListener("keyup", R), e.removeEventListener("selectstart", v), document.removeEventListener("selectionchange", w), Je.unbind();
    },
    setFilter: u,
    setUser: l
  };
}, md = (e, t) => ({
  ...e,
  annotatingEnabled: e.annotatingEnabled ?? t.annotatingEnabled,
  user: e.user || t.user
}), Zi = "SPANS", vd = (e, t = {}) => {
  _c(e), jc(e);
  const n = md(t, {
    annotatingEnabled: !0,
    user: Wu()
  }), r = ed(e, n.userSelectAction), { selection: o, viewport: i } = r, s = r.store, l = Lu(s), c = Du(r, l, n.adapter);
  let u = n.user;
  const f = n.renderer === "CSS_HIGHLIGHTS" ? CSS.highlights ? "CSS_HIGHLIGHTS" : Zi : n.renderer || Zi, d = f === "SPANS" ? du(e, r, i) : f === "CSS_HIGHLIGHTS" ? lu(e, r, i) : f === "CANVAS" ? Zc(e, r, i) : void 0;
  if (!d)
    throw `Unknown renderer implementation: ${f}`;
  console.debug(`Using ${f} renderer`), n.style && d.setStyle(n.style);
  const p = gd(e, r, n);
  return p.setUser(u), {
    ...Fu(r, l, n.adapter),
    destroy: () => {
      d.destroy(), p.destroy(), l.destroy();
    },
    element: e,
    getUser: () => u,
    setFilter: (h) => {
      d.setFilter(h), p.setFilter(h);
    },
    setStyle: (h) => d.setStyle(h),
    setUser: (h) => {
      u = h, p.setUser(h);
    },
    setSelected: (h) => {
      h ? o.setSelected(h) : o.clear();
    },
    setPresenceProvider: (h) => {
      h && (d.setPainter(nd(h, n.presence)), h.on("selectionChange", () => d.redraw()));
    },
    setVisible: (h) => d.setVisible(h),
    on: c.on,
    off: c.off,
    scrollIntoView: Wc(e, s),
    state: r
  };
}, yd = (e) => {
  const { children: t, ...n } = e, { anno: r, setAnno: o } = qo(Wr), i = Ms((s) => {
    const l = kc(vd(s, n));
    o(l);
  }, []);
  return Fe(() => {
    r && r.setStyle(e.style);
  }, [e.style]), Fe(() => {
    r && r.setFilter(e.filter);
  }, [e.filter]), e.children ? /* @__PURE__ */ vt.jsx(vt.Fragment, { children: Fs.toArray(e.children).map((s) => Bs(s, { onLoad: i })) }) : null;
}, Qi = () => {
  var e = navigator.userAgent || navigator.vendor || window.opera;
  return !!(/android/i.test(e) || /iPad|iPhone/.test(e) && !window.MSStream);
};
function qr() {
  return typeof window < "u";
}
function Yt(e) {
  return cs(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function Ke(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function ft(e) {
  var t;
  return (t = (cs(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function cs(e) {
  return qr() ? e instanceof Node || e instanceof Ke(e).Node : !1;
}
function be(e) {
  return qr() ? e instanceof Element || e instanceof Ke(e).Element : !1;
}
function Me(e) {
  return qr() ? e instanceof HTMLElement || e instanceof Ke(e).HTMLElement : !1;
}
function Vo(e) {
  return !qr() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof Ke(e).ShadowRoot;
}
function dr(e) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: r,
    display: o
  } = Xe(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !["inline", "contents"].includes(o);
}
function bd(e) {
  return ["table", "td", "th"].includes(Yt(e));
}
function Gr(e) {
  return [":popover-open", ":modal"].some((t) => {
    try {
      return e.matches(t);
    } catch {
      return !1;
    }
  });
}
function oi(e) {
  const t = Jr(), n = be(e) ? Xe(e) : e;
  return n.transform !== "none" || n.perspective !== "none" || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || ["transform", "perspective", "filter"].some((r) => (n.willChange || "").includes(r)) || ["paint", "layout", "strict", "content"].some((r) => (n.contain || "").includes(r));
}
function wd(e) {
  let t = wt(e);
  for (; Me(t) && !bt(t); ) {
    if (oi(t))
      return t;
    if (Gr(t))
      return null;
    t = wt(t);
  }
  return null;
}
function Jr() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function bt(e) {
  return ["html", "body", "#document"].includes(Yt(e));
}
function Xe(e) {
  return Ke(e).getComputedStyle(e);
}
function Zr(e) {
  return be(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.scrollX,
    scrollTop: e.scrollY
  };
}
function wt(e) {
  if (Yt(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    Vo(e) && e.host || // Fallback.
    ft(e)
  );
  return Vo(t) ? t.host : t;
}
function us(e) {
  const t = wt(e);
  return bt(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : Me(t) && dr(t) ? t : us(t);
}
function Ut(e, t, n) {
  var r;
  t === void 0 && (t = []), n === void 0 && (n = !0);
  const o = us(e), i = o === ((r = e.ownerDocument) == null ? void 0 : r.body), s = Ke(o);
  if (i) {
    const l = Yo(s);
    return t.concat(s, s.visualViewport || [], dr(o) ? o : [], l && n ? Ut(l) : []);
  }
  return t.concat(o, Ut(o, [], n));
}
function Yo(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
}
function Ht(e) {
  let t = e.activeElement;
  for (; ((n = t) == null || (n = n.shadowRoot) == null ? void 0 : n.activeElement) != null; ) {
    var n;
    t = t.shadowRoot.activeElement;
  }
  return t;
}
function Ve(e, t) {
  if (!e || !t)
    return !1;
  const n = t.getRootNode == null ? void 0 : t.getRootNode();
  if (e.contains(t))
    return !0;
  if (n && Vo(n)) {
    let r = t;
    for (; r; ) {
      if (e === r)
        return !0;
      r = r.parentNode || r.host;
    }
  }
  return !1;
}
function xd() {
  const e = navigator.userAgentData;
  return e != null && e.platform ? e.platform : navigator.platform;
}
function ds() {
  const e = navigator.userAgentData;
  return e && Array.isArray(e.brands) ? e.brands.map((t) => {
    let {
      brand: n,
      version: r
    } = t;
    return n + "/" + r;
  }).join(" ") : navigator.userAgent;
}
function Ed(e) {
  return e.mozInputSource === 0 && e.isTrusted ? !0 : Ho() && e.pointerType ? e.type === "click" && e.buttons === 1 : e.detail === 0 && !e.pointerType;
}
function Ad(e) {
  return Sd() ? !1 : !Ho() && e.width === 0 && e.height === 0 || Ho() && e.width === 1 && e.height === 1 && e.pressure === 0 && e.detail === 0 && e.pointerType === "mouse" || // iOS VoiceOver returns 0.333• for width/height.
  e.width < 1 && e.height < 1 && e.pressure === 0 && e.detail === 0 && e.pointerType === "touch";
}
function Rd() {
  return /apple/i.test(navigator.vendor);
}
function Ho() {
  const e = /android/i;
  return e.test(xd()) || e.test(ds());
}
function Sd() {
  return ds().includes("jsdom/");
}
function Od(e) {
  return "nativeEvent" in e;
}
function Td(e) {
  return e.matches("html,body");
}
function it(e) {
  return (e == null ? void 0 : e.ownerDocument) || document;
}
function Ro(e, t) {
  if (t == null)
    return !1;
  if ("composedPath" in e)
    return e.composedPath().includes(t);
  const n = e;
  return n.target != null && t.contains(n.target);
}
function Kt(e) {
  return "composedPath" in e ? e.composedPath()[0] : e.target;
}
const Cd = "input:not([type='hidden']):not([disabled]),[contenteditable]:not([contenteditable='false']),textarea:not([disabled])";
function kd(e) {
  return Me(e) && e.matches(Cd);
}
function So(e) {
  e.preventDefault(), e.stopPropagation();
}
function $d(e) {
  return e ? e.getAttribute("role") === "combobox" && kd(e) : !1;
}
/*!
* tabbable 6.2.0
* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
*/
var _d = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"], Ir = /* @__PURE__ */ _d.join(","), fs = typeof Element > "u", dn = fs ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector, Dr = !fs && Element.prototype.getRootNode ? function(e) {
  var t;
  return e == null || (t = e.getRootNode) === null || t === void 0 ? void 0 : t.call(e);
} : function(e) {
  return e == null ? void 0 : e.ownerDocument;
}, Mr = function e(t, n) {
  var r;
  n === void 0 && (n = !0);
  var o = t == null || (r = t.getAttribute) === null || r === void 0 ? void 0 : r.call(t, "inert"), i = o === "" || o === "true", s = i || n && t && e(t.parentNode);
  return s;
}, Pd = function(t) {
  var n, r = t == null || (n = t.getAttribute) === null || n === void 0 ? void 0 : n.call(t, "contenteditable");
  return r === "" || r === "true";
}, jd = function(t, n, r) {
  if (Mr(t))
    return [];
  var o = Array.prototype.slice.apply(t.querySelectorAll(Ir));
  return n && dn.call(t, Ir) && o.unshift(t), o = o.filter(r), o;
}, Nd = function e(t, n, r) {
  for (var o = [], i = Array.from(t); i.length; ) {
    var s = i.shift();
    if (!Mr(s, !1))
      if (s.tagName === "SLOT") {
        var l = s.assignedElements(), c = l.length ? l : s.children, u = e(c, !0, r);
        r.flatten ? o.push.apply(o, u) : o.push({
          scopeParent: s,
          candidates: u
        });
      } else {
        var f = dn.call(s, Ir);
        f && r.filter(s) && (n || !t.includes(s)) && o.push(s);
        var d = s.shadowRoot || // check for an undisclosed shadow
        typeof r.getShadowRoot == "function" && r.getShadowRoot(s), p = !Mr(d, !1) && (!r.shadowRootFilter || r.shadowRootFilter(s));
        if (d && p) {
          var h = e(d === !0 ? s.children : d.children, !0, r);
          r.flatten ? o.push.apply(o, h) : o.push({
            scopeParent: s,
            candidates: h
          });
        } else
          i.unshift.apply(i, s.children);
      }
  }
  return o;
}, ps = function(t) {
  return !isNaN(parseInt(t.getAttribute("tabindex"), 10));
}, hs = function(t) {
  if (!t)
    throw new Error("No node provided");
  return t.tabIndex < 0 && (/^(AUDIO|VIDEO|DETAILS)$/.test(t.tagName) || Pd(t)) && !ps(t) ? 0 : t.tabIndex;
}, Ld = function(t, n) {
  var r = hs(t);
  return r < 0 && n && !ps(t) ? 0 : r;
}, Id = function(t, n) {
  return t.tabIndex === n.tabIndex ? t.documentOrder - n.documentOrder : t.tabIndex - n.tabIndex;
}, gs = function(t) {
  return t.tagName === "INPUT";
}, Dd = function(t) {
  return gs(t) && t.type === "hidden";
}, Md = function(t) {
  var n = t.tagName === "DETAILS" && Array.prototype.slice.apply(t.children).some(function(r) {
    return r.tagName === "SUMMARY";
  });
  return n;
}, Fd = function(t, n) {
  for (var r = 0; r < t.length; r++)
    if (t[r].checked && t[r].form === n)
      return t[r];
}, Bd = function(t) {
  if (!t.name)
    return !0;
  var n = t.form || Dr(t), r = function(l) {
    return n.querySelectorAll('input[type="radio"][name="' + l + '"]');
  }, o;
  if (typeof window < "u" && typeof window.CSS < "u" && typeof window.CSS.escape == "function")
    o = r(window.CSS.escape(t.name));
  else
    try {
      o = r(t.name);
    } catch (s) {
      return console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", s.message), !1;
    }
  var i = Fd(o, t.form);
  return !i || i === t;
}, Ud = function(t) {
  return gs(t) && t.type === "radio";
}, Vd = function(t) {
  return Ud(t) && !Bd(t);
}, Yd = function(t) {
  var n, r = t && Dr(t), o = (n = r) === null || n === void 0 ? void 0 : n.host, i = !1;
  if (r && r !== t) {
    var s, l, c;
    for (i = !!((s = o) !== null && s !== void 0 && (l = s.ownerDocument) !== null && l !== void 0 && l.contains(o) || t != null && (c = t.ownerDocument) !== null && c !== void 0 && c.contains(t)); !i && o; ) {
      var u, f, d;
      r = Dr(o), o = (u = r) === null || u === void 0 ? void 0 : u.host, i = !!((f = o) !== null && f !== void 0 && (d = f.ownerDocument) !== null && d !== void 0 && d.contains(o));
    }
  }
  return i;
}, ea = function(t) {
  var n = t.getBoundingClientRect(), r = n.width, o = n.height;
  return r === 0 && o === 0;
}, Hd = function(t, n) {
  var r = n.displayCheck, o = n.getShadowRoot;
  if (getComputedStyle(t).visibility === "hidden")
    return !0;
  var i = dn.call(t, "details>summary:first-of-type"), s = i ? t.parentElement : t;
  if (dn.call(s, "details:not([open]) *"))
    return !0;
  if (!r || r === "full" || r === "legacy-full") {
    if (typeof o == "function") {
      for (var l = t; t; ) {
        var c = t.parentElement, u = Dr(t);
        if (c && !c.shadowRoot && o(c) === !0)
          return ea(t);
        t.assignedSlot ? t = t.assignedSlot : !c && u !== t.ownerDocument ? t = u.host : t = c;
      }
      t = l;
    }
    if (Yd(t))
      return !t.getClientRects().length;
    if (r !== "legacy-full")
      return !0;
  } else if (r === "non-zero-area")
    return ea(t);
  return !1;
}, Wd = function(t) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(t.tagName))
    for (var n = t.parentElement; n; ) {
      if (n.tagName === "FIELDSET" && n.disabled) {
        for (var r = 0; r < n.children.length; r++) {
          var o = n.children.item(r);
          if (o.tagName === "LEGEND")
            return dn.call(n, "fieldset[disabled] *") ? !0 : !o.contains(t);
        }
        return !0;
      }
      n = n.parentElement;
    }
  return !1;
}, Kd = function(t, n) {
  return !(n.disabled || // we must do an inert look up to filter out any elements inside an inert ancestor
  //  because we're limited in the type of selectors we can use in JSDom (see related
  //  note related to `candidateSelectors`)
  Mr(n) || Dd(n) || Hd(n, t) || // For a details element with a summary, the summary element gets the focus
  Md(n) || Wd(n));
}, Wo = function(t, n) {
  return !(Vd(n) || hs(n) < 0 || !Kd(t, n));
}, Xd = function(t) {
  var n = parseInt(t.getAttribute("tabindex"), 10);
  return !!(isNaN(n) || n >= 0);
}, zd = function e(t) {
  var n = [], r = [];
  return t.forEach(function(o, i) {
    var s = !!o.scopeParent, l = s ? o.scopeParent : o, c = Ld(l, s), u = s ? e(o.candidates) : l;
    c === 0 ? s ? n.push.apply(n, u) : n.push(l) : r.push({
      documentOrder: i,
      tabIndex: c,
      item: o,
      isScope: s,
      content: u
    });
  }), r.sort(Id).reduce(function(o, i) {
    return i.isScope ? o.push.apply(o, i.content) : o.push(i.content), o;
  }, []).concat(n);
}, Qr = function(t, n) {
  n = n || {};
  var r;
  return n.getShadowRoot ? r = Nd([t], n.includeContainer, {
    filter: Wo.bind(null, n),
    flatten: !1,
    getShadowRoot: n.getShadowRoot,
    shadowRootFilter: Xd
  }) : r = jd(t, n.includeContainer, Wo.bind(null, n)), zd(r);
}, qd = function(t, n) {
  if (n = n || {}, !t)
    throw new Error("No node provided");
  return dn.call(t, Ir) === !1 ? !1 : Wo(n, t);
};
const xt = Math.min, lt = Math.max, Fr = Math.round, xr = Math.floor, ct = (e) => ({
  x: e,
  y: e
}), Gd = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, Jd = {
  start: "end",
  end: "start"
};
function Ko(e, t, n) {
  return lt(e, xt(t, n));
}
function pn(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function Et(e) {
  return e.split("-")[0];
}
function fr(e) {
  return e.split("-")[1];
}
function ms(e) {
  return e === "x" ? "y" : "x";
}
function ii(e) {
  return e === "y" ? "height" : "width";
}
function Gt(e) {
  return ["top", "bottom"].includes(Et(e)) ? "y" : "x";
}
function ai(e) {
  return ms(Gt(e));
}
function Zd(e, t, n) {
  n === void 0 && (n = !1);
  const r = fr(e), o = ai(e), i = ii(o);
  let s = o === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return t.reference[i] > t.floating[i] && (s = Br(s)), [s, Br(s)];
}
function Qd(e) {
  const t = Br(e);
  return [Xo(e), t, Xo(t)];
}
function Xo(e) {
  return e.replace(/start|end/g, (t) => Jd[t]);
}
function ef(e, t, n) {
  const r = ["left", "right"], o = ["right", "left"], i = ["top", "bottom"], s = ["bottom", "top"];
  switch (e) {
    case "top":
    case "bottom":
      return n ? t ? o : r : t ? r : o;
    case "left":
    case "right":
      return t ? i : s;
    default:
      return [];
  }
}
function tf(e, t, n, r) {
  const o = fr(e);
  let i = ef(Et(e), n === "start", r);
  return o && (i = i.map((s) => s + "-" + o), t && (i = i.concat(i.map(Xo)))), i;
}
function Br(e) {
  return e.replace(/left|right|bottom|top/g, (t) => Gd[t]);
}
function nf(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function si(e) {
  return typeof e != "number" ? nf(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function fn(e) {
  const {
    x: t,
    y: n,
    width: r,
    height: o
  } = e;
  return {
    width: r,
    height: o,
    top: n,
    left: t,
    right: t + r,
    bottom: n + o,
    x: t,
    y: n
  };
}
function ta(e, t, n) {
  let {
    reference: r,
    floating: o
  } = e;
  const i = Gt(t), s = ai(t), l = ii(s), c = Et(t), u = i === "y", f = r.x + r.width / 2 - o.width / 2, d = r.y + r.height / 2 - o.height / 2, p = r[l] / 2 - o[l] / 2;
  let h;
  switch (c) {
    case "top":
      h = {
        x: f,
        y: r.y - o.height
      };
      break;
    case "bottom":
      h = {
        x: f,
        y: r.y + r.height
      };
      break;
    case "right":
      h = {
        x: r.x + r.width,
        y: d
      };
      break;
    case "left":
      h = {
        x: r.x - o.width,
        y: d
      };
      break;
    default:
      h = {
        x: r.x,
        y: r.y
      };
  }
  switch (fr(t)) {
    case "start":
      h[s] -= p * (n && u ? -1 : 1);
      break;
    case "end":
      h[s] += p * (n && u ? -1 : 1);
      break;
  }
  return h;
}
const rf = async (e, t, n) => {
  const {
    placement: r = "bottom",
    strategy: o = "absolute",
    middleware: i = [],
    platform: s
  } = n, l = i.filter(Boolean), c = await (s.isRTL == null ? void 0 : s.isRTL(t));
  let u = await s.getElementRects({
    reference: e,
    floating: t,
    strategy: o
  }), {
    x: f,
    y: d
  } = ta(u, r, c), p = r, h = {}, m = 0;
  for (let v = 0; v < l.length; v++) {
    const {
      name: w,
      fn: b
    } = l[v], {
      x: g,
      y: x,
      data: R,
      reset: A
    } = await b({
      x: f,
      y: d,
      initialPlacement: r,
      placement: p,
      strategy: o,
      middlewareData: h,
      rects: u,
      platform: s,
      elements: {
        reference: e,
        floating: t
      }
    });
    f = g ?? f, d = x ?? d, h = {
      ...h,
      [w]: {
        ...h[w],
        ...R
      }
    }, A && m <= 50 && (m++, typeof A == "object" && (A.placement && (p = A.placement), A.rects && (u = A.rects === !0 ? await s.getElementRects({
      reference: e,
      floating: t,
      strategy: o
    }) : A.rects), {
      x: f,
      y: d
    } = ta(u, p, c)), v = -1);
  }
  return {
    x: f,
    y: d,
    placement: p,
    strategy: o,
    middlewareData: h
  };
};
async function vs(e, t) {
  var n;
  t === void 0 && (t = {});
  const {
    x: r,
    y: o,
    platform: i,
    rects: s,
    elements: l,
    strategy: c
  } = e, {
    boundary: u = "clippingAncestors",
    rootBoundary: f = "viewport",
    elementContext: d = "floating",
    altBoundary: p = !1,
    padding: h = 0
  } = pn(t, e), m = si(h), w = l[p ? d === "floating" ? "reference" : "floating" : d], b = fn(await i.getClippingRect({
    element: (n = await (i.isElement == null ? void 0 : i.isElement(w))) == null || n ? w : w.contextElement || await (i.getDocumentElement == null ? void 0 : i.getDocumentElement(l.floating)),
    boundary: u,
    rootBoundary: f,
    strategy: c
  })), g = d === "floating" ? {
    x: r,
    y: o,
    width: s.floating.width,
    height: s.floating.height
  } : s.reference, x = await (i.getOffsetParent == null ? void 0 : i.getOffsetParent(l.floating)), R = await (i.isElement == null ? void 0 : i.isElement(x)) ? await (i.getScale == null ? void 0 : i.getScale(x)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, A = fn(i.convertOffsetParentRelativeRectToViewportRelativeRect ? await i.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: l,
    rect: g,
    offsetParent: x,
    strategy: c
  }) : g);
  return {
    top: (b.top - A.top + m.top) / R.y,
    bottom: (A.bottom - b.bottom + m.bottom) / R.y,
    left: (b.left - A.left + m.left) / R.x,
    right: (A.right - b.right + m.right) / R.x
  };
}
const of = (e) => ({
  name: "arrow",
  options: e,
  async fn(t) {
    const {
      x: n,
      y: r,
      placement: o,
      rects: i,
      platform: s,
      elements: l,
      middlewareData: c
    } = t, {
      element: u,
      padding: f = 0
    } = pn(e, t) || {};
    if (u == null)
      return {};
    const d = si(f), p = {
      x: n,
      y: r
    }, h = ai(o), m = ii(h), v = await s.getDimensions(u), w = h === "y", b = w ? "top" : "left", g = w ? "bottom" : "right", x = w ? "clientHeight" : "clientWidth", R = i.reference[m] + i.reference[h] - p[h] - i.floating[m], A = p[h] - i.reference[h], P = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(u));
    let _ = P ? P[x] : 0;
    (!_ || !await (s.isElement == null ? void 0 : s.isElement(P))) && (_ = l.floating[x] || i.floating[m]);
    const C = R / 2 - A / 2, M = _ / 2 - v[m] / 2 - 1, O = xt(d[b], M), S = xt(d[g], M), $ = O, T = _ - v[m] - S, j = _ / 2 - v[m] / 2 + C, L = Ko($, j, T), Y = !c.arrow && fr(o) != null && j !== L && i.reference[m] / 2 - (j < $ ? O : S) - v[m] / 2 < 0, z = Y ? j < $ ? j - $ : j - T : 0;
    return {
      [h]: p[h] + z,
      data: {
        [h]: L,
        centerOffset: j - L - z,
        ...Y && {
          alignmentOffset: z
        }
      },
      reset: Y
    };
  }
}), af = function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    async fn(t) {
      var n, r;
      const {
        placement: o,
        middlewareData: i,
        rects: s,
        initialPlacement: l,
        platform: c,
        elements: u
      } = t, {
        mainAxis: f = !0,
        crossAxis: d = !0,
        fallbackPlacements: p,
        fallbackStrategy: h = "bestFit",
        fallbackAxisSideDirection: m = "none",
        flipAlignment: v = !0,
        ...w
      } = pn(e, t);
      if ((n = i.arrow) != null && n.alignmentOffset)
        return {};
      const b = Et(o), g = Gt(l), x = Et(l) === l, R = await (c.isRTL == null ? void 0 : c.isRTL(u.floating)), A = p || (x || !v ? [Br(l)] : Qd(l)), P = m !== "none";
      !p && P && A.push(...tf(l, v, m, R));
      const _ = [l, ...A], C = await vs(t, w), M = [];
      let O = ((r = i.flip) == null ? void 0 : r.overflows) || [];
      if (f && M.push(C[b]), d) {
        const j = Zd(o, s, R);
        M.push(C[j[0]], C[j[1]]);
      }
      if (O = [...O, {
        placement: o,
        overflows: M
      }], !M.every((j) => j <= 0)) {
        var S, $;
        const j = (((S = i.flip) == null ? void 0 : S.index) || 0) + 1, L = _[j];
        if (L)
          return {
            data: {
              index: j,
              overflows: O
            },
            reset: {
              placement: L
            }
          };
        let Y = ($ = O.filter((z) => z.overflows[0] <= 0).sort((z, K) => z.overflows[1] - K.overflows[1])[0]) == null ? void 0 : $.placement;
        if (!Y)
          switch (h) {
            case "bestFit": {
              var T;
              const z = (T = O.filter((K) => {
                if (P) {
                  const W = Gt(K.placement);
                  return W === g || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  W === "y";
                }
                return !0;
              }).map((K) => [K.placement, K.overflows.filter((W) => W > 0).reduce((W, te) => W + te, 0)]).sort((K, W) => K[1] - W[1])[0]) == null ? void 0 : T[0];
              z && (Y = z);
              break;
            }
            case "initialPlacement":
              Y = l;
              break;
          }
        if (o !== Y)
          return {
            reset: {
              placement: Y
            }
          };
      }
      return {};
    }
  };
};
function ys(e) {
  const t = xt(...e.map((i) => i.left)), n = xt(...e.map((i) => i.top)), r = lt(...e.map((i) => i.right)), o = lt(...e.map((i) => i.bottom));
  return {
    x: t,
    y: n,
    width: r - t,
    height: o - n
  };
}
function sf(e) {
  const t = e.slice().sort((o, i) => o.y - i.y), n = [];
  let r = null;
  for (let o = 0; o < t.length; o++) {
    const i = t[o];
    !r || i.y - r.y > r.height / 2 ? n.push([i]) : n[n.length - 1].push(i), r = i;
  }
  return n.map((o) => fn(ys(o)));
}
const lf = function(e) {
  return e === void 0 && (e = {}), {
    name: "inline",
    options: e,
    async fn(t) {
      const {
        placement: n,
        elements: r,
        rects: o,
        platform: i,
        strategy: s
      } = t, {
        padding: l = 2,
        x: c,
        y: u
      } = pn(e, t), f = Array.from(await (i.getClientRects == null ? void 0 : i.getClientRects(r.reference)) || []), d = sf(f), p = fn(ys(f)), h = si(l);
      function m() {
        if (d.length === 2 && d[0].left > d[1].right && c != null && u != null)
          return d.find((w) => c > w.left - h.left && c < w.right + h.right && u > w.top - h.top && u < w.bottom + h.bottom) || p;
        if (d.length >= 2) {
          if (Gt(n) === "y") {
            const O = d[0], S = d[d.length - 1], $ = Et(n) === "top", T = O.top, j = S.bottom, L = $ ? O.left : S.left, Y = $ ? O.right : S.right, z = Y - L, K = j - T;
            return {
              top: T,
              bottom: j,
              left: L,
              right: Y,
              width: z,
              height: K,
              x: L,
              y: T
            };
          }
          const w = Et(n) === "left", b = lt(...d.map((O) => O.right)), g = xt(...d.map((O) => O.left)), x = d.filter((O) => w ? O.left === g : O.right === b), R = x[0].top, A = x[x.length - 1].bottom, P = g, _ = b, C = _ - P, M = A - R;
          return {
            top: R,
            bottom: A,
            left: P,
            right: _,
            width: C,
            height: M,
            x: P,
            y: R
          };
        }
        return p;
      }
      const v = await i.getElementRects({
        reference: {
          getBoundingClientRect: m
        },
        floating: r.floating,
        strategy: s
      });
      return o.reference.x !== v.reference.x || o.reference.y !== v.reference.y || o.reference.width !== v.reference.width || o.reference.height !== v.reference.height ? {
        reset: {
          rects: v
        }
      } : {};
    }
  };
};
async function cf(e, t) {
  const {
    placement: n,
    platform: r,
    elements: o
  } = e, i = await (r.isRTL == null ? void 0 : r.isRTL(o.floating)), s = Et(n), l = fr(n), c = Gt(n) === "y", u = ["left", "top"].includes(s) ? -1 : 1, f = i && c ? -1 : 1, d = pn(t, e);
  let {
    mainAxis: p,
    crossAxis: h,
    alignmentAxis: m
  } = typeof d == "number" ? {
    mainAxis: d,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: d.mainAxis || 0,
    crossAxis: d.crossAxis || 0,
    alignmentAxis: d.alignmentAxis
  };
  return l && typeof m == "number" && (h = l === "end" ? m * -1 : m), c ? {
    x: h * f,
    y: p * u
  } : {
    x: p * u,
    y: h * f
  };
}
const uf = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      var n, r;
      const {
        x: o,
        y: i,
        placement: s,
        middlewareData: l
      } = t, c = await cf(t, e);
      return s === ((n = l.offset) == null ? void 0 : n.placement) && (r = l.arrow) != null && r.alignmentOffset ? {} : {
        x: o + c.x,
        y: i + c.y,
        data: {
          ...c,
          placement: s
        }
      };
    }
  };
}, df = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: r,
        placement: o
      } = t, {
        mainAxis: i = !0,
        crossAxis: s = !1,
        limiter: l = {
          fn: (w) => {
            let {
              x: b,
              y: g
            } = w;
            return {
              x: b,
              y: g
            };
          }
        },
        ...c
      } = pn(e, t), u = {
        x: n,
        y: r
      }, f = await vs(t, c), d = Gt(Et(o)), p = ms(d);
      let h = u[p], m = u[d];
      if (i) {
        const w = p === "y" ? "top" : "left", b = p === "y" ? "bottom" : "right", g = h + f[w], x = h - f[b];
        h = Ko(g, h, x);
      }
      if (s) {
        const w = d === "y" ? "top" : "left", b = d === "y" ? "bottom" : "right", g = m + f[w], x = m - f[b];
        m = Ko(g, m, x);
      }
      const v = l.fn({
        ...t,
        [p]: h,
        [d]: m
      });
      return {
        ...v,
        data: {
          x: v.x - n,
          y: v.y - r,
          enabled: {
            [p]: i,
            [d]: s
          }
        }
      };
    }
  };
};
function bs(e) {
  const t = Xe(e);
  let n = parseFloat(t.width) || 0, r = parseFloat(t.height) || 0;
  const o = Me(e), i = o ? e.offsetWidth : n, s = o ? e.offsetHeight : r, l = Fr(n) !== i || Fr(r) !== s;
  return l && (n = i, r = s), {
    width: n,
    height: r,
    $: l
  };
}
function li(e) {
  return be(e) ? e : e.contextElement;
}
function ln(e) {
  const t = li(e);
  if (!Me(t))
    return ct(1);
  const n = t.getBoundingClientRect(), {
    width: r,
    height: o,
    $: i
  } = bs(t);
  let s = (i ? Fr(n.width) : n.width) / r, l = (i ? Fr(n.height) : n.height) / o;
  return (!s || !Number.isFinite(s)) && (s = 1), (!l || !Number.isFinite(l)) && (l = 1), {
    x: s,
    y: l
  };
}
const ff = /* @__PURE__ */ ct(0);
function ws(e) {
  const t = Ke(e);
  return !Jr() || !t.visualViewport ? ff : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function pf(e, t, n) {
  return t === void 0 && (t = !1), !n || t && n !== Ke(e) ? !1 : t;
}
function Jt(e, t, n, r) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const o = e.getBoundingClientRect(), i = li(e);
  let s = ct(1);
  t && (r ? be(r) && (s = ln(r)) : s = ln(e));
  const l = pf(i, n, r) ? ws(i) : ct(0);
  let c = (o.left + l.x) / s.x, u = (o.top + l.y) / s.y, f = o.width / s.x, d = o.height / s.y;
  if (i) {
    const p = Ke(i), h = r && be(r) ? Ke(r) : r;
    let m = p, v = Yo(m);
    for (; v && r && h !== m; ) {
      const w = ln(v), b = v.getBoundingClientRect(), g = Xe(v), x = b.left + (v.clientLeft + parseFloat(g.paddingLeft)) * w.x, R = b.top + (v.clientTop + parseFloat(g.paddingTop)) * w.y;
      c *= w.x, u *= w.y, f *= w.x, d *= w.y, c += x, u += R, m = Ke(v), v = Yo(m);
    }
  }
  return fn({
    width: f,
    height: d,
    x: c,
    y: u
  });
}
function ci(e, t) {
  const n = Zr(e).scrollLeft;
  return t ? t.left + n : Jt(ft(e)).left + n;
}
function xs(e, t, n) {
  n === void 0 && (n = !1);
  const r = e.getBoundingClientRect(), o = r.left + t.scrollLeft - (n ? 0 : (
    // RTL <body> scrollbar.
    ci(e, r)
  )), i = r.top + t.scrollTop;
  return {
    x: o,
    y: i
  };
}
function hf(e) {
  let {
    elements: t,
    rect: n,
    offsetParent: r,
    strategy: o
  } = e;
  const i = o === "fixed", s = ft(r), l = t ? Gr(t.floating) : !1;
  if (r === s || l && i)
    return n;
  let c = {
    scrollLeft: 0,
    scrollTop: 0
  }, u = ct(1);
  const f = ct(0), d = Me(r);
  if ((d || !d && !i) && ((Yt(r) !== "body" || dr(s)) && (c = Zr(r)), Me(r))) {
    const h = Jt(r);
    u = ln(r), f.x = h.x + r.clientLeft, f.y = h.y + r.clientTop;
  }
  const p = s && !d && !i ? xs(s, c, !0) : ct(0);
  return {
    width: n.width * u.x,
    height: n.height * u.y,
    x: n.x * u.x - c.scrollLeft * u.x + f.x + p.x,
    y: n.y * u.y - c.scrollTop * u.y + f.y + p.y
  };
}
function gf(e) {
  return Array.from(e.getClientRects());
}
function mf(e) {
  const t = ft(e), n = Zr(e), r = e.ownerDocument.body, o = lt(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth), i = lt(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight);
  let s = -n.scrollLeft + ci(e);
  const l = -n.scrollTop;
  return Xe(r).direction === "rtl" && (s += lt(t.clientWidth, r.clientWidth) - o), {
    width: o,
    height: i,
    x: s,
    y: l
  };
}
function vf(e, t) {
  const n = Ke(e), r = ft(e), o = n.visualViewport;
  let i = r.clientWidth, s = r.clientHeight, l = 0, c = 0;
  if (o) {
    i = o.width, s = o.height;
    const u = Jr();
    (!u || u && t === "fixed") && (l = o.offsetLeft, c = o.offsetTop);
  }
  return {
    width: i,
    height: s,
    x: l,
    y: c
  };
}
function yf(e, t) {
  const n = Jt(e, !0, t === "fixed"), r = n.top + e.clientTop, o = n.left + e.clientLeft, i = Me(e) ? ln(e) : ct(1), s = e.clientWidth * i.x, l = e.clientHeight * i.y, c = o * i.x, u = r * i.y;
  return {
    width: s,
    height: l,
    x: c,
    y: u
  };
}
function na(e, t, n) {
  let r;
  if (t === "viewport")
    r = vf(e, n);
  else if (t === "document")
    r = mf(ft(e));
  else if (be(t))
    r = yf(t, n);
  else {
    const o = ws(e);
    r = {
      x: t.x - o.x,
      y: t.y - o.y,
      width: t.width,
      height: t.height
    };
  }
  return fn(r);
}
function Es(e, t) {
  const n = wt(e);
  return n === t || !be(n) || bt(n) ? !1 : Xe(n).position === "fixed" || Es(n, t);
}
function bf(e, t) {
  const n = t.get(e);
  if (n)
    return n;
  let r = Ut(e, [], !1).filter((l) => be(l) && Yt(l) !== "body"), o = null;
  const i = Xe(e).position === "fixed";
  let s = i ? wt(e) : e;
  for (; be(s) && !bt(s); ) {
    const l = Xe(s), c = oi(s);
    !c && l.position === "fixed" && (o = null), (i ? !c && !o : !c && l.position === "static" && !!o && ["absolute", "fixed"].includes(o.position) || dr(s) && !c && Es(e, s)) ? r = r.filter((f) => f !== s) : o = l, s = wt(s);
  }
  return t.set(e, r), r;
}
function wf(e) {
  let {
    element: t,
    boundary: n,
    rootBoundary: r,
    strategy: o
  } = e;
  const s = [...n === "clippingAncestors" ? Gr(t) ? [] : bf(t, this._c) : [].concat(n), r], l = s[0], c = s.reduce((u, f) => {
    const d = na(t, f, o);
    return u.top = lt(d.top, u.top), u.right = xt(d.right, u.right), u.bottom = xt(d.bottom, u.bottom), u.left = lt(d.left, u.left), u;
  }, na(t, l, o));
  return {
    width: c.right - c.left,
    height: c.bottom - c.top,
    x: c.left,
    y: c.top
  };
}
function xf(e) {
  const {
    width: t,
    height: n
  } = bs(e);
  return {
    width: t,
    height: n
  };
}
function Ef(e, t, n) {
  const r = Me(t), o = ft(t), i = n === "fixed", s = Jt(e, !0, i, t);
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const c = ct(0);
  if (r || !r && !i)
    if ((Yt(t) !== "body" || dr(o)) && (l = Zr(t)), r) {
      const p = Jt(t, !0, i, t);
      c.x = p.x + t.clientLeft, c.y = p.y + t.clientTop;
    } else o && (c.x = ci(o));
  const u = o && !r && !i ? xs(o, l) : ct(0), f = s.left + l.scrollLeft - c.x - u.x, d = s.top + l.scrollTop - c.y - u.y;
  return {
    x: f,
    y: d,
    width: s.width,
    height: s.height
  };
}
function Oo(e) {
  return Xe(e).position === "static";
}
function ra(e, t) {
  if (!Me(e) || Xe(e).position === "fixed")
    return null;
  if (t)
    return t(e);
  let n = e.offsetParent;
  return ft(e) === n && (n = n.ownerDocument.body), n;
}
function As(e, t) {
  const n = Ke(e);
  if (Gr(e))
    return n;
  if (!Me(e)) {
    let o = wt(e);
    for (; o && !bt(o); ) {
      if (be(o) && !Oo(o))
        return o;
      o = wt(o);
    }
    return n;
  }
  let r = ra(e, t);
  for (; r && bd(r) && Oo(r); )
    r = ra(r, t);
  return r && bt(r) && Oo(r) && !oi(r) ? n : r || wd(e) || n;
}
const Af = async function(e) {
  const t = this.getOffsetParent || As, n = this.getDimensions, r = await n(e.floating);
  return {
    reference: Ef(e.reference, await t(e.floating), e.strategy),
    floating: {
      x: 0,
      y: 0,
      width: r.width,
      height: r.height
    }
  };
};
function Rf(e) {
  return Xe(e).direction === "rtl";
}
const Sf = {
  convertOffsetParentRelativeRectToViewportRelativeRect: hf,
  getDocumentElement: ft,
  getClippingRect: wf,
  getOffsetParent: As,
  getElementRects: Af,
  getClientRects: gf,
  getDimensions: xf,
  getScale: ln,
  isElement: be,
  isRTL: Rf
};
function Of(e, t) {
  let n = null, r;
  const o = ft(e);
  function i() {
    var l;
    clearTimeout(r), (l = n) == null || l.disconnect(), n = null;
  }
  function s(l, c) {
    l === void 0 && (l = !1), c === void 0 && (c = 1), i();
    const {
      left: u,
      top: f,
      width: d,
      height: p
    } = e.getBoundingClientRect();
    if (l || t(), !d || !p)
      return;
    const h = xr(f), m = xr(o.clientWidth - (u + d)), v = xr(o.clientHeight - (f + p)), w = xr(u), g = {
      rootMargin: -h + "px " + -m + "px " + -v + "px " + -w + "px",
      threshold: lt(0, xt(1, c)) || 1
    };
    let x = !0;
    function R(A) {
      const P = A[0].intersectionRatio;
      if (P !== c) {
        if (!x)
          return s();
        P ? s(!1, P) : r = setTimeout(() => {
          s(!1, 1e-7);
        }, 1e3);
      }
      x = !1;
    }
    try {
      n = new IntersectionObserver(R, {
        ...g,
        // Handle <iframe>s
        root: o.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(R, g);
    }
    n.observe(e);
  }
  return s(!0), i;
}
function Tf(e, t, n, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: o = !0,
    ancestorResize: i = !0,
    elementResize: s = typeof ResizeObserver == "function",
    layoutShift: l = typeof IntersectionObserver == "function",
    animationFrame: c = !1
  } = r, u = li(e), f = o || i ? [...u ? Ut(u) : [], ...Ut(t)] : [];
  f.forEach((b) => {
    o && b.addEventListener("scroll", n, {
      passive: !0
    }), i && b.addEventListener("resize", n);
  });
  const d = u && l ? Of(u, n) : null;
  let p = -1, h = null;
  s && (h = new ResizeObserver((b) => {
    let [g] = b;
    g && g.target === u && h && (h.unobserve(t), cancelAnimationFrame(p), p = requestAnimationFrame(() => {
      var x;
      (x = h) == null || x.observe(t);
    })), n();
  }), u && !c && h.observe(u), h.observe(t));
  let m, v = c ? Jt(e) : null;
  c && w();
  function w() {
    const b = Jt(e);
    v && (b.x !== v.x || b.y !== v.y || b.width !== v.width || b.height !== v.height) && n(), v = b, m = requestAnimationFrame(w);
  }
  return n(), () => {
    var b;
    f.forEach((g) => {
      o && g.removeEventListener("scroll", n), i && g.removeEventListener("resize", n);
    }), d == null || d(), (b = h) == null || b.disconnect(), h = null, c && cancelAnimationFrame(m);
  };
}
const Cf = uf, kf = df, $f = af, oa = of, _f = lf, Pf = (e, t, n) => {
  const r = /* @__PURE__ */ new Map(), o = {
    platform: Sf,
    ...n
  }, i = {
    ...o.platform,
    _c: r
  };
  return rf(e, t, {
    ...o,
    platform: i
  });
};
var Cr = typeof document < "u" ? Ca : Fe;
function Ur(e, t) {
  if (e === t)
    return !0;
  if (typeof e != typeof t)
    return !1;
  if (typeof e == "function" && e.toString() === t.toString())
    return !0;
  let n, r, o;
  if (e && t && typeof e == "object") {
    if (Array.isArray(e)) {
      if (n = e.length, n !== t.length) return !1;
      for (r = n; r-- !== 0; )
        if (!Ur(e[r], t[r]))
          return !1;
      return !0;
    }
    if (o = Object.keys(e), n = o.length, n !== Object.keys(t).length)
      return !1;
    for (r = n; r-- !== 0; )
      if (!{}.hasOwnProperty.call(t, o[r]))
        return !1;
    for (r = n; r-- !== 0; ) {
      const i = o[r];
      if (!(i === "_owner" && e.$$typeof) && !Ur(e[i], t[i]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function Rs(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function ia(e, t) {
  const n = Rs(e);
  return Math.round(t * n) / n;
}
function To(e) {
  const t = D.useRef(e);
  return Cr(() => {
    t.current = e;
  }), t;
}
function jf(e) {
  e === void 0 && (e = {});
  const {
    placement: t = "bottom",
    strategy: n = "absolute",
    middleware: r = [],
    platform: o,
    elements: {
      reference: i,
      floating: s
    } = {},
    transform: l = !0,
    whileElementsMounted: c,
    open: u
  } = e, [f, d] = D.useState({
    x: 0,
    y: 0,
    strategy: n,
    placement: t,
    middlewareData: {},
    isPositioned: !1
  }), [p, h] = D.useState(r);
  Ur(p, r) || h(r);
  const [m, v] = D.useState(null), [w, b] = D.useState(null), g = D.useCallback((K) => {
    K !== P.current && (P.current = K, v(K));
  }, []), x = D.useCallback((K) => {
    K !== _.current && (_.current = K, b(K));
  }, []), R = i || m, A = s || w, P = D.useRef(null), _ = D.useRef(null), C = D.useRef(f), M = c != null, O = To(c), S = To(o), $ = To(u), T = D.useCallback(() => {
    if (!P.current || !_.current)
      return;
    const K = {
      placement: t,
      strategy: n,
      middleware: p
    };
    S.current && (K.platform = S.current), Pf(P.current, _.current, K).then((W) => {
      const te = {
        ...W,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: $.current !== !1
      };
      j.current && !Ur(C.current, te) && (C.current = te, ka.flushSync(() => {
        d(te);
      }));
    });
  }, [p, t, n, S, $]);
  Cr(() => {
    u === !1 && C.current.isPositioned && (C.current.isPositioned = !1, d((K) => ({
      ...K,
      isPositioned: !1
    })));
  }, [u]);
  const j = D.useRef(!1);
  Cr(() => (j.current = !0, () => {
    j.current = !1;
  }), []), Cr(() => {
    if (R && (P.current = R), A && (_.current = A), R && A) {
      if (O.current)
        return O.current(R, A, T);
      T();
    }
  }, [R, A, T, O, M]);
  const L = D.useMemo(() => ({
    reference: P,
    floating: _,
    setReference: g,
    setFloating: x
  }), [g, x]), Y = D.useMemo(() => ({
    reference: R,
    floating: A
  }), [R, A]), z = D.useMemo(() => {
    const K = {
      position: n,
      left: 0,
      top: 0
    };
    if (!Y.floating)
      return K;
    const W = ia(Y.floating, f.x), te = ia(Y.floating, f.y);
    return l ? {
      ...K,
      transform: "translate(" + W + "px, " + te + "px)",
      ...Rs(Y.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: n,
      left: W,
      top: te
    };
  }, [n, l, Y.floating, f.x, f.y]);
  return D.useMemo(() => ({
    ...f,
    update: T,
    refs: L,
    elements: Y,
    floatingStyles: z
  }), [f, T, L, Y, z]);
}
const Nf = (e) => {
  function t(n) {
    return {}.hasOwnProperty.call(n, "current");
  }
  return {
    name: "arrow",
    options: e,
    fn(n) {
      const {
        element: r,
        padding: o
      } = typeof e == "function" ? e(n) : e;
      return r && t(r) ? r.current != null ? oa({
        element: r.current,
        padding: o
      }).fn(n) : {} : r ? oa({
        element: r,
        padding: o
      }).fn(n) : {};
    }
  };
}, Lf = (e, t) => ({
  ...Cf(e),
  options: [e, t]
}), If = (e, t) => ({
  ...kf(e),
  options: [e, t]
}), Df = (e, t) => ({
  ...$f(e),
  options: [e, t]
}), Mf = (e, t) => ({
  ..._f(e),
  options: [e, t]
}), Ff = (e, t) => ({
  ...Nf(e),
  options: [e, t]
});
function aa(e) {
  return D.useMemo(() => e.every((t) => t == null) ? null : (t) => {
    e.forEach((n) => {
      typeof n == "function" ? n(t) : n != null && (n.current = t);
    });
  }, e);
}
const Ss = {
  ...D
}, Bf = Ss.useInsertionEffect, Uf = Bf || ((e) => e());
function Dt(e) {
  const t = D.useRef(() => {
    if (process.env.NODE_ENV !== "production")
      throw new Error("Cannot call an event handler while rendering.");
  });
  return Uf(() => {
    t.current = e;
  }), D.useCallback(function() {
    for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
      r[o] = arguments[o];
    return t.current == null ? void 0 : t.current(...r);
  }, []);
}
var He = typeof document < "u" ? Ca : Fe;
function ar() {
  return ar = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, ar.apply(this, arguments);
}
let sa = !1, Vf = 0;
const la = () => (
  // Ensure the id is unique with multiple independent versions of Floating UI
  // on <React 18
  "floating-ui-" + Math.random().toString(36).slice(2, 6) + Vf++
);
function Yf() {
  const [e, t] = D.useState(() => sa ? la() : void 0);
  return He(() => {
    e == null && t(la());
  }, []), D.useEffect(() => {
    sa = !0;
  }, []), e;
}
const Hf = Ss.useId, eo = Hf || Yf;
let sr;
process.env.NODE_ENV !== "production" && (sr = /* @__PURE__ */ new Set());
function Wf() {
  for (var e, t = arguments.length, n = new Array(t), r = 0; r < t; r++)
    n[r] = arguments[r];
  const o = "Floating UI: " + n.join(" ");
  if (!((e = sr) != null && e.has(o))) {
    var i;
    (i = sr) == null || i.add(o), console.warn(o);
  }
}
function Kf() {
  for (var e, t = arguments.length, n = new Array(t), r = 0; r < t; r++)
    n[r] = arguments[r];
  const o = "Floating UI: " + n.join(" ");
  if (!((e = sr) != null && e.has(o))) {
    var i;
    (i = sr) == null || i.add(o), console.error(o);
  }
}
const Xf = /* @__PURE__ */ D.forwardRef(function(t, n) {
  const {
    context: {
      placement: r,
      elements: {
        floating: o
      },
      middlewareData: {
        arrow: i,
        shift: s
      }
    },
    width: l = 14,
    height: c = 7,
    tipRadius: u = 0,
    strokeWidth: f = 0,
    staticOffset: d,
    stroke: p,
    d: h,
    style: {
      transform: m,
      ...v
    } = {},
    ...w
  } = t;
  process.env.NODE_ENV !== "production" && (n || Wf("The `ref` prop is required for `FloatingArrow`."));
  const b = eo(), [g, x] = D.useState(!1);
  if (He(() => {
    if (!o) return;
    Xe(o).direction === "rtl" && x(!0);
  }, [o]), !o)
    return null;
  const [R, A] = r.split("-"), P = R === "top" || R === "bottom";
  let _ = d;
  (P && s != null && s.x || !P && s != null && s.y) && (_ = null);
  const C = f * 2, M = C / 2, O = l / 2 * (u / -8 + 1), S = c / 2 * u / 4, $ = !!h, T = _ && A === "end" ? "bottom" : "top";
  let j = _ && A === "end" ? "right" : "left";
  _ && g && (j = A === "end" ? "left" : "right");
  const L = (i == null ? void 0 : i.x) != null ? _ || i.x : "", Y = (i == null ? void 0 : i.y) != null ? _ || i.y : "", z = h || "M0,0" + (" H" + l) + (" L" + (l - O) + "," + (c - S)) + (" Q" + l / 2 + "," + c + " " + O + "," + (c - S)) + " Z", K = {
    top: $ ? "rotate(180deg)" : "",
    left: $ ? "rotate(90deg)" : "rotate(-90deg)",
    bottom: $ ? "" : "rotate(180deg)",
    right: $ ? "rotate(-90deg)" : "rotate(90deg)"
  }[R];
  return /* @__PURE__ */ D.createElement("svg", ar({}, w, {
    "aria-hidden": !0,
    ref: n,
    width: $ ? l : l + C,
    height: l,
    viewBox: "0 0 " + l + " " + (c > l ? c : l),
    style: {
      position: "absolute",
      pointerEvents: "none",
      [j]: L,
      [T]: Y,
      [R]: P || $ ? "100%" : "calc(100% - " + C / 2 + "px)",
      transform: [K, m].filter((W) => !!W).join(" "),
      ...v
    }
  }), C > 0 && /* @__PURE__ */ D.createElement("path", {
    clipPath: "url(#" + b + ")",
    fill: "none",
    stroke: p,
    strokeWidth: C + (h ? 0 : 1),
    d: z
  }), /* @__PURE__ */ D.createElement("path", {
    stroke: C && !h ? w.fill : "none",
    d: z
  }), /* @__PURE__ */ D.createElement("clipPath", {
    id: b
  }, /* @__PURE__ */ D.createElement("rect", {
    x: -M,
    y: M * ($ ? -1 : 1),
    width: l + C,
    height: l
  })));
});
function zf() {
  const e = /* @__PURE__ */ new Map();
  return {
    emit(t, n) {
      var r;
      (r = e.get(t)) == null || r.forEach((o) => o(n));
    },
    on(t, n) {
      e.set(t, [...e.get(t) || [], n]);
    },
    off(t, n) {
      var r;
      e.set(t, ((r = e.get(t)) == null ? void 0 : r.filter((o) => o !== n)) || []);
    }
  };
}
const qf = /* @__PURE__ */ D.createContext(null), Gf = /* @__PURE__ */ D.createContext(null), Os = () => {
  var e;
  return ((e = D.useContext(qf)) == null ? void 0 : e.id) || null;
}, ui = () => D.useContext(Gf);
function lr(e) {
  return "data-floating-ui-" + e;
}
function Co(e) {
  const t = Go(e);
  return He(() => {
    t.current = e;
  }), t;
}
let ca = 0;
function tn(e, t) {
  t === void 0 && (t = {});
  const {
    preventScroll: n = !1,
    cancelPrevious: r = !0,
    sync: o = !1
  } = t;
  r && cancelAnimationFrame(ca);
  const i = () => e == null ? void 0 : e.focus({
    preventScroll: n
  });
  o ? i() : ca = requestAnimationFrame(i);
}
function ua(e, t) {
  var n;
  let r = [], o = (n = e.find((i) => i.id === t)) == null ? void 0 : n.parentId;
  for (; o; ) {
    const i = e.find((s) => s.id === o);
    o = i == null ? void 0 : i.parentId, i && (r = r.concat(i));
  }
  return r;
}
function Zn(e, t) {
  let n = e.filter((o) => {
    var i;
    return o.parentId === t && ((i = o.context) == null ? void 0 : i.open);
  }), r = n;
  for (; r.length; )
    r = e.filter((o) => {
      var i;
      return (i = r) == null ? void 0 : i.some((s) => {
        var l;
        return o.parentId === s.id && ((l = o.context) == null ? void 0 : l.open);
      });
    }), n = n.concat(r);
  return n;
}
let nn = /* @__PURE__ */ new WeakMap(), Er = /* @__PURE__ */ new WeakSet(), Ar = {}, ko = 0;
const Jf = () => typeof HTMLElement < "u" && "inert" in HTMLElement.prototype, Ts = (e) => e && (e.host || Ts(e.parentNode)), Zf = (e, t) => t.map((n) => {
  if (e.contains(n))
    return n;
  const r = Ts(n);
  return e.contains(r) ? r : null;
}).filter((n) => n != null);
function Qf(e, t, n, r) {
  const o = "data-floating-ui-inert", i = r ? "inert" : n ? "aria-hidden" : null, s = Zf(t, e), l = /* @__PURE__ */ new Set(), c = new Set(s), u = [];
  Ar[o] || (Ar[o] = /* @__PURE__ */ new WeakMap());
  const f = Ar[o];
  s.forEach(d), p(t), l.clear();
  function d(h) {
    !h || l.has(h) || (l.add(h), h.parentNode && d(h.parentNode));
  }
  function p(h) {
    !h || c.has(h) || [].forEach.call(h.children, (m) => {
      if (Yt(m) !== "script")
        if (l.has(m))
          p(m);
        else {
          const v = i ? m.getAttribute(i) : null, w = v !== null && v !== "false", b = (nn.get(m) || 0) + 1, g = (f.get(m) || 0) + 1;
          nn.set(m, b), f.set(m, g), u.push(m), b === 1 && w && Er.add(m), g === 1 && m.setAttribute(o, ""), !w && i && m.setAttribute(i, "true");
        }
    });
  }
  return ko++, () => {
    u.forEach((h) => {
      const m = (nn.get(h) || 0) - 1, v = (f.get(h) || 0) - 1;
      nn.set(h, m), f.set(h, v), m || (!Er.has(h) && i && h.removeAttribute(i), Er.delete(h)), v || h.removeAttribute(o);
    }), ko--, ko || (nn = /* @__PURE__ */ new WeakMap(), nn = /* @__PURE__ */ new WeakMap(), Er = /* @__PURE__ */ new WeakSet(), Ar = {});
  };
}
function da(e, t, n) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const r = it(e[0]).body;
  return Qf(e.concat(Array.from(r.querySelectorAll("[aria-live]"))), r, t, n);
}
const to = () => ({
  getShadowRoot: !0,
  displayCheck: (
    // JSDOM does not support the `tabbable` library. To solve this we can
    // check if `ResizeObserver` is a real function (not polyfilled), which
    // determines if the current environment is JSDOM-like.
    typeof ResizeObserver == "function" && ResizeObserver.toString().includes("[native code]") ? "full" : "none"
  )
});
function Cs(e, t) {
  const n = Qr(e, to());
  t === "prev" && n.reverse();
  const r = n.indexOf(Ht(it(e)));
  return n.slice(r + 1)[0];
}
function ks() {
  return Cs(document.body, "next");
}
function $s() {
  return Cs(document.body, "prev");
}
function Qn(e, t) {
  const n = t || e.currentTarget, r = e.relatedTarget;
  return !r || !Ve(n, r);
}
function ep(e) {
  Qr(e, to()).forEach((n) => {
    n.dataset.tabindex = n.getAttribute("tabindex") || "", n.setAttribute("tabindex", "-1");
  });
}
function fa(e) {
  e.querySelectorAll("[data-tabindex]").forEach((n) => {
    const r = n.dataset.tabindex;
    delete n.dataset.tabindex, r ? n.setAttribute("tabindex", r) : n.removeAttribute("tabindex");
  });
}
const no = {
  border: 0,
  clip: "rect(0 0 0 0)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: 0,
  position: "fixed",
  whiteSpace: "nowrap",
  width: "1px",
  top: 0,
  left: 0
};
let tp;
function pa(e) {
  e.key === "Tab" && (e.target, clearTimeout(tp));
}
const Vr = /* @__PURE__ */ D.forwardRef(function(t, n) {
  const [r, o] = D.useState();
  He(() => (Rd() && o("button"), document.addEventListener("keydown", pa), () => {
    document.removeEventListener("keydown", pa);
  }), []);
  const i = {
    ref: n,
    tabIndex: 0,
    // Role is only for VoiceOver
    role: r,
    "aria-hidden": r ? void 0 : !0,
    [lr("focus-guard")]: "",
    style: no
  };
  return /* @__PURE__ */ D.createElement("span", ar({}, t, i));
}), _s = /* @__PURE__ */ D.createContext(null), ha = /* @__PURE__ */ lr("portal");
function np(e) {
  e === void 0 && (e = {});
  const {
    id: t,
    root: n
  } = e, r = eo(), o = Ps(), [i, s] = D.useState(null), l = D.useRef(null);
  return He(() => () => {
    i == null || i.remove(), queueMicrotask(() => {
      l.current = null;
    });
  }, [i]), He(() => {
    if (!r || l.current) return;
    const c = t ? document.getElementById(t) : null;
    if (!c) return;
    const u = document.createElement("div");
    u.id = r, u.setAttribute(ha, ""), c.appendChild(u), l.current = u, s(u);
  }, [t, r]), He(() => {
    if (n === null || !r || l.current) return;
    let c = n || (o == null ? void 0 : o.portalNode);
    c && !be(c) && (c = c.current), c = c || document.body;
    let u = null;
    t && (u = document.createElement("div"), u.id = t, c.appendChild(u));
    const f = document.createElement("div");
    f.id = r, f.setAttribute(ha, ""), c = u || c, c.appendChild(f), l.current = f, s(f);
  }, [t, n, r, o]), i;
}
function rp(e) {
  const {
    children: t,
    id: n,
    root: r,
    preserveTabOrder: o = !0
  } = e, i = np({
    id: n,
    root: r
  }), [s, l] = D.useState(null), c = D.useRef(null), u = D.useRef(null), f = D.useRef(null), d = D.useRef(null), p = s == null ? void 0 : s.modal, h = s == null ? void 0 : s.open, m = (
    // The FocusManager and therefore floating element are currently open/
    // rendered.
    !!s && // Guards are only for non-modal focus management.
    !s.modal && // Don't render if unmount is transitioning.
    s.open && o && !!(r || i)
  );
  return D.useEffect(() => {
    if (!i || !o || p)
      return;
    function v(w) {
      i && Qn(w) && (w.type === "focusin" ? fa : ep)(i);
    }
    return i.addEventListener("focusin", v, !0), i.addEventListener("focusout", v, !0), () => {
      i.removeEventListener("focusin", v, !0), i.removeEventListener("focusout", v, !0);
    };
  }, [i, o, p]), D.useEffect(() => {
    i && (h || fa(i));
  }, [h, i]), /* @__PURE__ */ D.createElement(_s.Provider, {
    value: D.useMemo(() => ({
      preserveTabOrder: o,
      beforeOutsideRef: c,
      afterOutsideRef: u,
      beforeInsideRef: f,
      afterInsideRef: d,
      portalNode: i,
      setFocusManagerState: l
    }), [o, i])
  }, m && i && /* @__PURE__ */ D.createElement(Vr, {
    "data-type": "outside",
    ref: c,
    onFocus: (v) => {
      if (Qn(v, i)) {
        var w;
        (w = f.current) == null || w.focus();
      } else {
        const b = $s() || (s == null ? void 0 : s.refs.domReference.current);
        b == null || b.focus();
      }
    }
  }), m && i && /* @__PURE__ */ D.createElement("span", {
    "aria-owns": i.id,
    style: no
  }), i && /* @__PURE__ */ ka.createPortal(t, i), m && i && /* @__PURE__ */ D.createElement(Vr, {
    "data-type": "outside",
    ref: u,
    onFocus: (v) => {
      if (Qn(v, i)) {
        var w;
        (w = d.current) == null || w.focus();
      } else {
        const b = ks() || (s == null ? void 0 : s.refs.domReference.current);
        b == null || b.focus(), s != null && s.closeOnFocusOut && (s == null || s.onOpenChange(!1, v.nativeEvent, "focus-out"));
      }
    }
  }));
}
const Ps = () => D.useContext(_s), zo = "data-floating-ui-focusable";
function ga(e) {
  return e ? e.hasAttribute(zo) ? e : e.querySelector("[" + zo + "]") || e : null;
}
const ma = 20;
let Wt = [];
function $o(e) {
  Wt = Wt.filter((t) => t.isConnected), e && Yt(e) !== "body" && (Wt.push(e), Wt.length > ma && (Wt = Wt.slice(-ma)));
}
function va() {
  return Wt.slice().reverse().find((e) => e.isConnected);
}
function op(e) {
  const t = to();
  return qd(e, t) ? e : Qr(e, t)[0] || e;
}
const ip = /* @__PURE__ */ D.forwardRef(function(t, n) {
  return /* @__PURE__ */ D.createElement("button", ar({}, t, {
    type: "button",
    ref: n,
    tabIndex: -1,
    style: no
  }));
});
function ap(e) {
  const {
    context: t,
    children: n,
    disabled: r = !1,
    order: o = ["content"],
    guards: i = !0,
    initialFocus: s = 0,
    returnFocus: l = !0,
    restoreFocus: c = !1,
    modal: u = !0,
    visuallyHiddenDismiss: f = !1,
    closeOnFocusOut: d = !0,
    outsideElementsInert: p = !1
  } = e, {
    open: h,
    refs: m,
    nodeId: v,
    onOpenChange: w,
    events: b,
    dataRef: g,
    elements: {
      domReference: x,
      floating: R
    }
  } = t, A = typeof s == "number" && s < 0, P = $d(x) && A, _ = Jf(), C = _ ? i : !0, M = !C || _ && p, O = Co(o), S = Co(s), $ = Co(l), T = ui(), j = Ps(), L = D.useRef(null), Y = D.useRef(null), z = D.useRef(!1), K = D.useRef(!1), W = D.useRef(-1), te = j != null, J = ga(R), ce = Dt(function(Z) {
    return Z === void 0 && (Z = J), Z ? Qr(Z, to()) : [];
  }), Ee = Dt((Z) => {
    const ne = ce(Z);
    return O.current.map((Q) => x && Q === "reference" ? x : J && Q === "floating" ? J : ne).filter(Boolean).flat();
  });
  D.useEffect(() => {
    if (r || !u) return;
    function Z(Q) {
      if (Q.key === "Tab") {
        Ve(J, Ht(it(J))) && ce().length === 0 && !P && So(Q);
        const oe = Ee(), fe = Kt(Q);
        O.current[0] === "reference" && fe === x && (So(Q), Q.shiftKey ? tn(oe[oe.length - 1]) : tn(oe[1])), O.current[1] === "floating" && fe === J && Q.shiftKey && (So(Q), tn(oe[0]));
      }
    }
    const ne = it(J);
    return ne.addEventListener("keydown", Z), () => {
      ne.removeEventListener("keydown", Z);
    };
  }, [r, x, J, u, O, P, ce, Ee]), D.useEffect(() => {
    if (r || !R) return;
    function Z(ne) {
      const Q = Kt(ne), fe = ce().indexOf(Q);
      fe !== -1 && (W.current = fe);
    }
    return R.addEventListener("focusin", Z), () => {
      R.removeEventListener("focusin", Z);
    };
  }, [r, R, ce]), D.useEffect(() => {
    if (r || !d) return;
    function Z() {
      K.current = !0, setTimeout(() => {
        K.current = !1;
      });
    }
    function ne(Q) {
      const oe = Q.relatedTarget;
      queueMicrotask(() => {
        const fe = !(Ve(x, oe) || Ve(R, oe) || Ve(oe, R) || Ve(j == null ? void 0 : j.portalNode, oe) || oe != null && oe.hasAttribute(lr("focus-guard")) || T && (Zn(T.nodesRef.current, v).find((le) => {
          var ae, Oe;
          return Ve((ae = le.context) == null ? void 0 : ae.elements.floating, oe) || Ve((Oe = le.context) == null ? void 0 : Oe.elements.domReference, oe);
        }) || ua(T.nodesRef.current, v).find((le) => {
          var ae, Oe, ke;
          return [(ae = le.context) == null ? void 0 : ae.elements.floating, ga((Oe = le.context) == null ? void 0 : Oe.elements.floating)].includes(oe) || ((ke = le.context) == null ? void 0 : ke.elements.domReference) === oe;
        })));
        if (c && fe && Ht(it(J)) === it(J).body) {
          Me(J) && J.focus();
          const le = W.current, ae = ce(), Oe = ae[le] || ae[ae.length - 1] || J;
          Me(Oe) && Oe.focus();
        }
        (P || !u) && oe && fe && !K.current && // Fix React 18 Strict Mode returnFocus due to double rendering.
        oe !== va() && (z.current = !0, w(!1, Q, "focus-out"));
      });
    }
    if (R && Me(x))
      return x.addEventListener("focusout", ne), x.addEventListener("pointerdown", Z), R.addEventListener("focusout", ne), () => {
        x.removeEventListener("focusout", ne), x.removeEventListener("pointerdown", Z), R.removeEventListener("focusout", ne);
      };
  }, [r, x, R, J, u, v, T, j, w, d, c, ce, P]);
  const Se = D.useRef(null), ie = D.useRef(null), ue = aa([Se, j == null ? void 0 : j.beforeInsideRef]), pe = aa([ie, j == null ? void 0 : j.afterInsideRef]);
  D.useEffect(() => {
    var Z;
    if (r || !R) return;
    const ne = Array.from((j == null || (Z = j.portalNode) == null ? void 0 : Z.querySelectorAll("[" + lr("portal") + "]")) || []), Q = T && !u ? ua(T == null ? void 0 : T.nodesRef.current, v).map((le) => {
      var ae;
      return (ae = le.context) == null ? void 0 : ae.elements.floating;
    }) : [], oe = [R, ...ne, ...Q, L.current, Y.current, Se.current, ie.current, j == null ? void 0 : j.beforeOutsideRef.current, j == null ? void 0 : j.afterOutsideRef.current, O.current.includes("reference") || P ? x : null].filter((le) => le != null), fe = u || P ? da(oe, !M, M) : da(oe);
    return () => {
      fe();
    };
  }, [r, x, R, u, O, j, P, C, M, T, v]), He(() => {
    if (r || !Me(J)) return;
    const Z = it(J), ne = Ht(Z);
    queueMicrotask(() => {
      const Q = Ee(J), oe = S.current, fe = (typeof oe == "number" ? Q[oe] : oe.current) || J, le = Ve(J, ne);
      !A && !le && h && tn(fe, {
        preventScroll: fe === J
      });
    });
  }, [r, h, J, A, Ee, S]), He(() => {
    if (r || !J) return;
    let Z = !1;
    const ne = it(J), Q = Ht(ne);
    let fe = g.current.openEvent;
    $o(Q);
    function le(ke) {
      let {
        open: Te,
        reason: at,
        event: ze,
        nested: Ce
      } = ke;
      Te && (fe = ze), at === "escape-key" && m.domReference.current && $o(m.domReference.current), ["hover", "safe-polygon"].includes(at) && ze.type === "mouseleave" && (z.current = !0), at === "outside-press" && (Ce ? (z.current = !1, Z = !0) : z.current = !(Ed(ze) || Ad(ze)));
    }
    b.on("openchange", le);
    const ae = ne.createElement("span");
    ae.setAttribute("tabindex", "-1"), ae.setAttribute("aria-hidden", "true"), Object.assign(ae.style, no), te && x && x.insertAdjacentElement("afterend", ae);
    function Oe() {
      return typeof $.current == "boolean" ? va() || ae : $.current.current || ae;
    }
    return () => {
      b.off("openchange", le);
      const ke = Ht(ne), Te = Ve(R, ke) || T && Zn(T.nodesRef.current, v).some((Ce) => {
        var St;
        return Ve((St = Ce.context) == null ? void 0 : St.elements.floating, ke);
      });
      (Te || fe && ["click", "mousedown"].includes(fe.type)) && m.domReference.current && $o(m.domReference.current);
      const ze = Oe();
      queueMicrotask(() => {
        const Ce = op(ze);
        // eslint-disable-next-line react-hooks/exhaustive-deps
        $.current && !z.current && Me(Ce) && // If the focus moved somewhere else after mount, avoid returning focus
        // since it likely entered a different element which should be
        // respected: https://github.com/floating-ui/floating-ui/issues/2607
        (!(Ce !== ke && ke !== ne.body) || Te) && Ce.focus({
          preventScroll: Z
        }), ae.remove();
      });
    };
  }, [r, R, J, $, g, m, b, T, v, te, x]), D.useEffect(() => {
    queueMicrotask(() => {
      z.current = !1;
    });
  }, [r]), He(() => {
    if (!r && j)
      return j.setFocusManagerState({
        modal: u,
        closeOnFocusOut: d,
        open: h,
        onOpenChange: w,
        refs: m
      }), () => {
        j.setFocusManagerState(null);
      };
  }, [r, j, u, h, w, m, d]), He(() => {
    if (r || !J || typeof MutationObserver != "function" || A) return;
    const Z = () => {
      const Q = J.getAttribute("tabindex"), oe = ce(), fe = Ht(it(R)), le = oe.indexOf(fe);
      le !== -1 && (W.current = le), O.current.includes("floating") || fe !== m.domReference.current && oe.length === 0 ? Q !== "0" && J.setAttribute("tabindex", "0") : Q !== "-1" && J.setAttribute("tabindex", "-1");
    };
    Z();
    const ne = new MutationObserver(Z);
    return ne.observe(J, {
      childList: !0,
      subtree: !0,
      attributes: !0
    }), () => {
      ne.disconnect();
    };
  }, [r, R, J, m, O, ce, A]);
  function G(Z) {
    return r || !f || !u ? null : /* @__PURE__ */ D.createElement(ip, {
      ref: Z === "start" ? L : Y,
      onClick: (ne) => w(!1, ne.nativeEvent)
    }, typeof f == "string" ? f : "Dismiss");
  }
  const H = !r && C && (u ? !P : !0) && (te || u);
  return /* @__PURE__ */ D.createElement(D.Fragment, null, H && /* @__PURE__ */ D.createElement(Vr, {
    "data-type": "inside",
    ref: ue,
    onFocus: (Z) => {
      if (u) {
        const Q = Ee();
        tn(o[0] === "reference" ? Q[0] : Q[Q.length - 1]);
      } else if (j != null && j.preserveTabOrder && j.portalNode)
        if (z.current = !1, Qn(Z, j.portalNode)) {
          const Q = ks() || x;
          Q == null || Q.focus();
        } else {
          var ne;
          (ne = j.beforeOutsideRef.current) == null || ne.focus();
        }
    }
  }), !P && G("start"), n, G("end"), H && /* @__PURE__ */ D.createElement(Vr, {
    "data-type": "inside",
    ref: pe,
    onFocus: (Z) => {
      if (u)
        tn(Ee()[0]);
      else if (j != null && j.preserveTabOrder && j.portalNode)
        if (d && (z.current = !0), Qn(Z, j.portalNode)) {
          const Q = $s() || x;
          Q == null || Q.focus();
        } else {
          var ne;
          (ne = j.afterOutsideRef.current) == null || ne.focus();
        }
    }
  }));
}
const sp = {
  pointerdown: "onPointerDown",
  mousedown: "onMouseDown",
  click: "onClick"
}, lp = {
  pointerdown: "onPointerDownCapture",
  mousedown: "onMouseDownCapture",
  click: "onClickCapture"
}, ya = (e) => {
  var t, n;
  return {
    escapeKey: typeof e == "boolean" ? e : (t = e == null ? void 0 : e.escapeKey) != null ? t : !1,
    outsidePress: typeof e == "boolean" ? e : (n = e == null ? void 0 : e.outsidePress) != null ? n : !0
  };
};
function cp(e, t) {
  t === void 0 && (t = {});
  const {
    open: n,
    onOpenChange: r,
    elements: o,
    dataRef: i
  } = e, {
    enabled: s = !0,
    escapeKey: l = !0,
    outsidePress: c = !0,
    outsidePressEvent: u = "pointerdown",
    referencePress: f = !1,
    referencePressEvent: d = "pointerdown",
    ancestorScroll: p = !1,
    bubbles: h,
    capture: m
  } = t, v = ui(), w = Dt(typeof c == "function" ? c : () => !1), b = typeof c == "function" ? w : c, g = D.useRef(!1), x = D.useRef(!1), {
    escapeKey: R,
    outsidePress: A
  } = ya(h), {
    escapeKey: P,
    outsidePress: _
  } = ya(m), C = D.useRef(!1), M = Dt((L) => {
    var Y;
    if (!n || !s || !l || L.key !== "Escape" || C.current)
      return;
    const z = (Y = i.current.floatingContext) == null ? void 0 : Y.nodeId, K = v ? Zn(v.nodesRef.current, z) : [];
    if (!R && (L.stopPropagation(), K.length > 0)) {
      let W = !0;
      if (K.forEach((te) => {
        var J;
        if ((J = te.context) != null && J.open && !te.context.dataRef.current.__escapeKeyBubbles) {
          W = !1;
          return;
        }
      }), !W)
        return;
    }
    r(!1, Od(L) ? L.nativeEvent : L, "escape-key");
  }), O = Dt((L) => {
    var Y;
    const z = () => {
      var K;
      M(L), (K = Kt(L)) == null || K.removeEventListener("keydown", z);
    };
    (Y = Kt(L)) == null || Y.addEventListener("keydown", z);
  }), S = Dt((L) => {
    var Y;
    const z = g.current;
    g.current = !1;
    const K = x.current;
    if (x.current = !1, u === "click" && K || z || typeof b == "function" && !b(L))
      return;
    const W = Kt(L), te = "[" + lr("inert") + "]", J = it(o.floating).querySelectorAll(te);
    let ce = be(W) ? W : null;
    for (; ce && !bt(ce); ) {
      const ue = wt(ce);
      if (bt(ue) || !be(ue))
        break;
      ce = ue;
    }
    if (J.length && be(W) && !Td(W) && // Clicked on a direct ancestor (e.g. FloatingOverlay).
    !Ve(W, o.floating) && // If the target root element contains none of the markers, then the
    // element was injected after the floating element rendered.
    Array.from(J).every((ue) => !Ve(ce, ue)))
      return;
    if (Me(W) && j) {
      const ue = bt(W), pe = Xe(W), G = /auto|scroll/, H = ue || G.test(pe.overflowX), Z = ue || G.test(pe.overflowY), ne = H && W.clientWidth > 0 && W.scrollWidth > W.clientWidth, Q = Z && W.clientHeight > 0 && W.scrollHeight > W.clientHeight, oe = pe.direction === "rtl", fe = Q && (oe ? L.offsetX <= W.offsetWidth - W.clientWidth : L.offsetX > W.clientWidth), le = ne && L.offsetY > W.clientHeight;
      if (fe || le)
        return;
    }
    const Ee = (Y = i.current.floatingContext) == null ? void 0 : Y.nodeId, Se = v && Zn(v.nodesRef.current, Ee).some((ue) => {
      var pe;
      return Ro(L, (pe = ue.context) == null ? void 0 : pe.elements.floating);
    });
    if (Ro(L, o.floating) || Ro(L, o.domReference) || Se)
      return;
    const ie = v ? Zn(v.nodesRef.current, Ee) : [];
    if (ie.length > 0) {
      let ue = !0;
      if (ie.forEach((pe) => {
        var G;
        if ((G = pe.context) != null && G.open && !pe.context.dataRef.current.__outsidePressBubbles) {
          ue = !1;
          return;
        }
      }), !ue)
        return;
    }
    r(!1, L, "outside-press");
  }), $ = Dt((L) => {
    var Y;
    const z = () => {
      var K;
      S(L), (K = Kt(L)) == null || K.removeEventListener(u, z);
    };
    (Y = Kt(L)) == null || Y.addEventListener(u, z);
  });
  D.useEffect(() => {
    if (!n || !s)
      return;
    i.current.__escapeKeyBubbles = R, i.current.__outsidePressBubbles = A;
    let L = -1;
    function Y(J) {
      r(!1, J, "ancestor-scroll");
    }
    function z() {
      window.clearTimeout(L), C.current = !0;
    }
    function K() {
      L = window.setTimeout(
        () => {
          C.current = !1;
        },
        // 0ms or 1ms don't work in Safari. 5ms appears to consistently work.
        // Only apply to WebKit for the test to remain 0ms.
        Jr() ? 5 : 0
      );
    }
    const W = it(o.floating);
    l && (W.addEventListener("keydown", P ? O : M, P), W.addEventListener("compositionstart", z), W.addEventListener("compositionend", K)), b && W.addEventListener(u, _ ? $ : S, _);
    let te = [];
    return p && (be(o.domReference) && (te = Ut(o.domReference)), be(o.floating) && (te = te.concat(Ut(o.floating))), !be(o.reference) && o.reference && o.reference.contextElement && (te = te.concat(Ut(o.reference.contextElement)))), te = te.filter((J) => {
      var ce;
      return J !== ((ce = W.defaultView) == null ? void 0 : ce.visualViewport);
    }), te.forEach((J) => {
      J.addEventListener("scroll", Y, {
        passive: !0
      });
    }), () => {
      l && (W.removeEventListener("keydown", P ? O : M, P), W.removeEventListener("compositionstart", z), W.removeEventListener("compositionend", K)), b && W.removeEventListener(u, _ ? $ : S, _), te.forEach((J) => {
        J.removeEventListener("scroll", Y);
      }), window.clearTimeout(L);
    };
  }, [i, o, l, b, u, n, r, p, s, R, A, M, P, O, S, _, $]), D.useEffect(() => {
    g.current = !1;
  }, [b, u]);
  const T = D.useMemo(() => ({
    onKeyDown: M,
    ...f && {
      [sp[d]]: (L) => {
        r(!1, L.nativeEvent, "reference-press");
      },
      ...d !== "click" && {
        onClick(L) {
          r(!1, L.nativeEvent, "reference-press");
        }
      }
    }
  }), [M, r, f, d]), j = D.useMemo(() => ({
    onKeyDown: M,
    onMouseDown() {
      x.current = !0;
    },
    onMouseUp() {
      x.current = !0;
    },
    [lp[u]]: () => {
      g.current = !0;
    }
  }), [M, u]);
  return D.useMemo(() => s ? {
    reference: T,
    floating: j
  } : {}, [s, T, j]);
}
function up(e) {
  const {
    open: t = !1,
    onOpenChange: n,
    elements: r
  } = e, o = eo(), i = D.useRef({}), [s] = D.useState(() => zf()), l = Os() != null;
  if (process.env.NODE_ENV !== "production") {
    const h = r.reference;
    h && !be(h) && Kf("Cannot pass a virtual element to the `elements.reference` option,", "as it must be a real DOM element. Use `refs.setPositionReference()`", "instead.");
  }
  const [c, u] = D.useState(r.reference), f = Dt((h, m, v) => {
    i.current.openEvent = h ? m : void 0, s.emit("openchange", {
      open: h,
      event: m,
      reason: v,
      nested: l
    }), n == null || n(h, m, v);
  }), d = D.useMemo(() => ({
    setPositionReference: u
  }), []), p = D.useMemo(() => ({
    reference: c || r.reference || null,
    floating: r.floating || null,
    domReference: r.reference
  }), [c, r.reference, r.floating]);
  return D.useMemo(() => ({
    dataRef: i,
    open: t,
    onOpenChange: f,
    elements: p,
    events: s,
    floatingId: o,
    refs: d
  }), [t, f, p, s, o, d]);
}
function dp(e) {
  e === void 0 && (e = {});
  const {
    nodeId: t
  } = e, n = up({
    ...e,
    elements: {
      reference: null,
      floating: null,
      ...e.elements
    }
  }), r = e.rootContext || n, o = r.elements, [i, s] = D.useState(null), [l, c] = D.useState(null), f = (o == null ? void 0 : o.domReference) || i, d = D.useRef(null), p = ui();
  He(() => {
    f && (d.current = f);
  }, [f]);
  const h = jf({
    ...e,
    elements: {
      ...o,
      ...l && {
        reference: l
      }
    }
  }), m = D.useCallback((x) => {
    const R = be(x) ? {
      getBoundingClientRect: () => x.getBoundingClientRect(),
      contextElement: x
    } : x;
    c(R), h.refs.setReference(R);
  }, [h.refs]), v = D.useCallback((x) => {
    (be(x) || x === null) && (d.current = x, s(x)), (be(h.refs.reference.current) || h.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    x !== null && !be(x)) && h.refs.setReference(x);
  }, [h.refs]), w = D.useMemo(() => ({
    ...h.refs,
    setReference: v,
    setPositionReference: m,
    domReference: d
  }), [h.refs, v, m]), b = D.useMemo(() => ({
    ...h.elements,
    domReference: f
  }), [h.elements, f]), g = D.useMemo(() => ({
    ...h,
    ...r,
    refs: w,
    elements: b,
    nodeId: t
  }), [h, w, b, t, r]);
  return He(() => {
    r.dataRef.current.floatingContext = g;
    const x = p == null ? void 0 : p.nodesRef.current.find((R) => R.id === t);
    x && (x.context = g);
  }), D.useMemo(() => ({
    ...h,
    context: g,
    refs: w,
    elements: b
  }), [h, w, b, g]);
}
const ba = "active", wa = "selected";
function _o(e, t, n) {
  const r = /* @__PURE__ */ new Map(), o = n === "item";
  let i = e;
  if (o && e) {
    const {
      [ba]: s,
      [wa]: l,
      ...c
    } = e;
    i = c;
  }
  return {
    ...n === "floating" && {
      tabIndex: -1,
      [zo]: ""
    },
    ...i,
    ...t.map((s) => {
      const l = s ? s[n] : null;
      return typeof l == "function" ? e ? l(e) : null : l;
    }).concat(e).reduce((s, l) => (l && Object.entries(l).forEach((c) => {
      let [u, f] = c;
      if (!(o && [ba, wa].includes(u)))
        if (u.indexOf("on") === 0) {
          if (r.has(u) || r.set(u, []), typeof f == "function") {
            var d;
            (d = r.get(u)) == null || d.push(f), s[u] = function() {
              for (var p, h = arguments.length, m = new Array(h), v = 0; v < h; v++)
                m[v] = arguments[v];
              return (p = r.get(u)) == null ? void 0 : p.map((w) => w(...m)).find((w) => w !== void 0);
            };
          }
        } else
          s[u] = f;
    }), s), {})
  };
}
function fp(e) {
  e === void 0 && (e = []);
  const t = e.map((l) => l == null ? void 0 : l.reference), n = e.map((l) => l == null ? void 0 : l.floating), r = e.map((l) => l == null ? void 0 : l.item), o = D.useCallback(
    (l) => _o(l, e, "reference"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    t
  ), i = D.useCallback(
    (l) => _o(l, e, "floating"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    n
  ), s = D.useCallback(
    (l) => _o(l, e, "item"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    r
  );
  return D.useMemo(() => ({
    getReferenceProps: o,
    getFloatingProps: i,
    getItemProps: s
  }), [o, i, s]);
}
const pp = /* @__PURE__ */ new Map([["select", "listbox"], ["combobox", "listbox"], ["label", !1]]);
function hp(e, t) {
  var n;
  t === void 0 && (t = {});
  const {
    open: r,
    floatingId: o
  } = e, {
    enabled: i = !0,
    role: s = "dialog"
  } = t, l = (n = pp.get(s)) != null ? n : s, c = eo(), f = Os() != null, d = D.useMemo(() => l === "tooltip" || s === "label" ? {
    ["aria-" + (s === "label" ? "labelledby" : "describedby")]: r ? o : void 0
  } : {
    "aria-expanded": r ? "true" : "false",
    "aria-haspopup": l === "alertdialog" ? "dialog" : l,
    "aria-controls": r ? o : void 0,
    ...l === "listbox" && {
      role: "combobox"
    },
    ...l === "menu" && {
      id: c
    },
    ...l === "menu" && f && {
      role: "menuitem"
    },
    ...s === "select" && {
      "aria-autocomplete": "none"
    },
    ...s === "combobox" && {
      "aria-autocomplete": "list"
    }
  }, [l, o, f, r, c, s]), p = D.useMemo(() => {
    const m = {
      id: o,
      ...l && {
        role: l
      }
    };
    return l === "tooltip" || s === "label" ? m : {
      ...m,
      ...l === "menu" && {
        "aria-labelledby": c
      }
    };
  }, [l, o, c, s]), h = D.useCallback((m) => {
    let {
      active: v,
      selected: w
    } = m;
    const b = {
      role: "option",
      ...v && {
        id: o + "-option"
      }
    };
    switch (s) {
      case "select":
        return {
          ...b,
          "aria-selected": v && w
        };
      case "combobox":
        return {
          ...b,
          ...v && {
            "aria-selected": !0
          }
        };
    }
    return {};
  }, [o, s]);
  return D.useMemo(() => i ? {
    reference: d,
    floating: p,
    item: h
  } : {}, [i, d, p, h]);
}
const xa = (e, t) => {
  const { left: n, top: r, right: o, bottom: i } = e, s = t.getBoundingClientRect();
  return new DOMRect(n + s.left, r + s.top, o - n, i - r);
}, gp = (e) => {
  var t;
  const n = $a(), { selected: r, event: o } = _a(), i = (t = r[0]) == null ? void 0 : t.annotation, [s, l] = Ue((r == null ? void 0 : r.length) > 0), c = Go(null), { refs: u, floatingStyles: f, update: d, context: p } = dp({
    placement: Qi() ? "bottom" : "top",
    open: s,
    onOpenChange: (g, x, R) => {
      !g && (R === "escape-key" || R === "focus-out") && (l(g), n == null || n.cancelSelected());
    },
    middleware: [
      Mf(),
      Lf(10),
      Df({ crossAxis: !0 }),
      If({ crossAxis: !0, padding: 10 }),
      Ff({ element: c })
    ],
    whileElementsMounted: Tf
  }), h = cp(p), m = hp(p, { role: "dialog" }), { getFloatingProps: v } = fp([h, m]);
  Fe(() => {
    if (i != null && i.id) {
      const g = n == null ? void 0 : n.state.store.getAnnotationBounds(i.id);
      l(!!g);
    } else
      l(!1);
  }, [i == null ? void 0 : i.id, n == null ? void 0 : n.state.store]), Fe(() => {
    n && (s && (i != null && i.id) ? u.setPositionReference({
      getBoundingClientRect: () => {
        const g = n.state.store.getAnnotationBounds(i.id);
        return g ? xa(g, n.element) : new DOMRect();
      },
      getClientRects: () => {
        const x = n.state.store.getAnnotationRects(i.id).map((R) => xa(R, n.element));
        return Vc(x);
      }
    }) : u.setPositionReference(null));
  }, [s, i == null ? void 0 : i.id, i == null ? void 0 : i.target, n]), Fe(() => {
    const g = { attributes: !0, childList: !0, subtree: !0 }, x = new MutationObserver(() => d());
    return x.observe(document.body, g), window.document.addEventListener("scroll", d, !0), () => {
      x.disconnect(), window.document.removeEventListener("scroll", d, !0);
    };
  }, [d]);
  const w = $r(() => (o == null ? void 0 : o.type) === "keyup" || (o == null ? void 0 : o.type) === "contextmenu" || Qi() ? -1 : 0, [o]), b = () => n == null ? void 0 : n.cancelSelected();
  return s && i ? /* @__PURE__ */ vt.jsx(rp, { children: /* @__PURE__ */ vt.jsx(
    ap,
    {
      context: p,
      modal: !1,
      closeOnFocusOut: !0,
      returnFocus: !1,
      initialFocus: w,
      children: /* @__PURE__ */ vt.jsxs(
        "div",
        {
          className: `a9s-popup r6o-popup annotation-popup r6o-text-popup ${Qo}`,
          ref: u.setFloating,
          style: f,
          ...v(mp()),
          children: [
            e.popup({
              annotation: r[0].annotation,
              editable: r[0].editable,
              event: o
            }),
            e.arrow && /* @__PURE__ */ vt.jsx(
              Xf,
              {
                ref: c,
                context: p,
                ...e.arrowProps || {}
              }
            ),
            /* @__PURE__ */ vt.jsx("button", { className: "r6o-popup-sr-only", "aria-live": "assertive", onClick: b, children: e.ariaCloseWarning || "Click or leave this dialog to close it." })
          ]
        }
      )
    }
  ) }) : null;
}, mp = () => ({
  onPointerUp: (e) => e.stopPropagation(),
  onPointerDown: (e) => e.stopPropagation(),
  onMouseDown: (e) => e.stopPropagation(),
  onMouseUp: (e) => e.stopPropagation()
}), vp = (e) => (Fe(() => {
  console.warn("TextAnnotatorPopup is deprecated and will be removed in a future version. Please use TextAnnotationPopup instead.");
}, []), /* @__PURE__ */ vt.jsx(gp, { ...e }));
var Ne = [];
for (var Po = 0; Po < 256; ++Po)
  Ne.push((Po + 256).toString(16).slice(1));
function yp(e, t = 0) {
  return (Ne[e[t + 0]] + Ne[e[t + 1]] + Ne[e[t + 2]] + Ne[e[t + 3]] + "-" + Ne[e[t + 4]] + Ne[e[t + 5]] + "-" + Ne[e[t + 6]] + Ne[e[t + 7]] + "-" + Ne[e[t + 8]] + Ne[e[t + 9]] + "-" + Ne[e[t + 10]] + Ne[e[t + 11]] + Ne[e[t + 12]] + Ne[e[t + 13]] + Ne[e[t + 14]] + Ne[e[t + 15]]).toLowerCase();
}
var Rr, bp = new Uint8Array(16);
function wp() {
  if (!Rr && (Rr = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !Rr))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return Rr(bp);
}
var xp = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
const Ea = {
  randomUUID: xp
};
function Aa(e, t, n) {
  if (Ea.randomUUID && !t && !e)
    return Ea.randomUUID();
  e = e || {};
  var r = e.random || (e.rng || wp)();
  return r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, yp(r);
}
const Ra = (e) => e != null && e.startsWith("#") ? e.substring(1) : e, Ep = (e) => e ? new Date(e) : void 0, Ap = (e) => {
  const [t, n] = Ue([]);
  Fe(() => {
    if (!e) return;
    const l = new DOMParser().parseFromString(e, "text/xml").querySelectorAll("TEI > standOff"), c = Array.from(l).reduce((u, f, d) => {
      const p = l.length > 1 ? `tei_standoff_${d + 1}` : "tei_standoff", h = {
        id: p,
        name: l.length > 1 ? `TEI Standoff ${d + 1}` : "TEI Standoff"
      }, m = f.querySelectorAll(
        "listAnnotation > annotation"
      ), w = Array.from(m).map((b) => {
        const g = b.getAttribute("xml:id"), x = Array.from(
          b.querySelectorAll("revisionDesc > change")
        ).map(
          (S) => ({
            who: Ra(S.getAttribute("who")),
            when: Ep(S.getAttribute("when")),
            status: S.getAttribute("status")
          })
        ), R = Array.from(b.querySelectorAll("respStmt")).map(
          (S) => ({
            id: S.getAttribute("xml:id"),
            name: S.textContent
          })
        ), A = Array.from(b.querySelectorAll("note")).map(
          (S) => ({
            text: S.textContent,
            responsible: R.find(
              ($) => $.id === Ra(S.getAttribute("resp"))
            )
          })
        ), P = Array.from(
          b.querySelectorAll("rs[ana]")
        ).reduce(
          (S, $) => [...S, ...$.getAttribute("ana").split(" ")],
          []
        ), _ = x.find((S) => S.status === "created"), C = x.find((S) => S.status === "modified"), [M, O] = b.getAttribute("target") ? b.getAttribute("target").split(" ") : [void 0, void 0];
        return {
          id: g,
          layer_id: p,
          target: {
            annotation: g,
            creator: _ ? R.find((S) => S.id === _.who) : void 0,
            created: _ == null ? void 0 : _.when,
            updatedBy: C ? R.find((S) => S.id === C.who) : void 0,
            updated: C == null ? void 0 : C.when,
            selector: M && O ? [
              {
                startSelector: {
                  type: "XPathSelector",
                  value: M
                },
                endSelector: {
                  type: "XPathSelector",
                  value: O
                }
              }
            ] : void 0
          },
          bodies: [
            ...A.map((S) => ({
              id: Aa(),
              annotation: g,
              value: S.text,
              creator: S.responsible
            })),
            ...P.map((S) => ({
              id: Aa(),
              annotation: g,
              purpose: "tagging",
              value: S,
              // Maybe not the greatest convention - but we'll attribute
              // all tags to the annotation creator. The issue: we current don't have a
              // mechanism implemented in our TEI export that associates users with
              // tags. (I'm not sure there even is a mechansim in TEI!)
              creator: _ ? R.find(($) => $.id === _.who) : void 0
            }))
          ]
        };
      }).filter(
        (b) => b.target.selector
      );
      return [...u, { layer: h, annotations: w }];
    }, []);
    n(c);
  }, [e]);
  const r = $r(
    () => t.reduce(
      (i, s) => [...i, ...s.annotations],
      []
    ),
    [t]
  );
  return { layers: $r(
    () => t.map((i) => i.layer),
    [t]
  ), annotations: r };
};
var js = {
  color: void 0,
  size: void 0,
  className: void 0,
  style: void 0,
  attr: void 0
}, Sa = We.createContext && /* @__PURE__ */ We.createContext(js), Rp = ["attr", "size", "title"];
function Sp(e, t) {
  if (e == null) return {};
  var n = Op(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
function Op(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e)
    if (Object.prototype.hasOwnProperty.call(e, r)) {
      if (t.indexOf(r) >= 0) continue;
      n[r] = e[r];
    }
  return n;
}
function Yr() {
  return Yr = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Yr.apply(this, arguments);
}
function Oa(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Hr(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Oa(Object(n), !0).forEach(function(r) {
      Tp(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Oa(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Tp(e, t, n) {
  return t = Cp(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function Cp(e) {
  var t = kp(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function kp(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Ns(e) {
  return e && e.map((t, n) => /* @__PURE__ */ We.createElement(t.tag, Hr({
    key: n
  }, t.attr), Ns(t.child)));
}
function Rt(e) {
  return (t) => /* @__PURE__ */ We.createElement($p, Yr({
    attr: Hr({}, e.attr)
  }, t), Ns(e.child));
}
function $p(e) {
  var t = (n) => {
    var {
      attr: r,
      size: o,
      title: i
    } = e, s = Sp(e, Rp), l = o || n.size || "1em", c;
    return n.className && (c = n.className), e.className && (c = (c ? c + " " : "") + e.className), /* @__PURE__ */ We.createElement("svg", Yr({
      stroke: "currentColor",
      fill: "currentColor",
      strokeWidth: "0"
    }, n.attr, r, s, {
      className: c,
      style: Hr(Hr({
        color: e.color || n.color
      }, n.style), e.style),
      height: l,
      width: l,
      xmlns: "http://www.w3.org/2000/svg"
    }), i && /* @__PURE__ */ We.createElement("title", null, i), e.children);
  };
  return Sa !== void 0 ? /* @__PURE__ */ We.createElement(Sa.Consumer, null, (n) => t(n)) : t(js);
}
function _p(e) {
  return Rt({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160zm352-160l-160 160c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L301.3 256 438.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0z" }, child: [] }] })(e);
}
function Pp(e) {
  return Rt({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M470.6 278.6c12.5-12.5 12.5-32.8 0-45.3l-160-160c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L402.7 256 265.4 393.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l160-160zm-352 160l160-160c12.5-12.5 12.5-32.8 0-45.3l-160-160c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L210.7 256 73.4 393.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0z" }, child: [] }] })(e);
}
function kr(e) {
  return Rt({ tag: "svg", attr: { viewBox: "0 0 448 512" }, child: [{ tag: "path", attr: { d: "M0 80V229.5c0 17 6.7 33.3 18.7 45.3l176 176c25 25 65.5 25 90.5 0L418.7 317.3c25-25 25-65.5 0-90.5l-176-176c-12-12-28.3-18.7-45.3-18.7H48C21.5 32 0 53.5 0 80zm112 32a32 32 0 1 1 0 64 32 32 0 1 1 0-64z" }, child: [] }] })(e);
}
function Xn(e) {
  return Rt({ tag: "svg", attr: { viewBox: "0 0 448 512" }, child: [{ tag: "path", attr: { d: "M224 256A128 128 0 1 0 224 0a128 128 0 1 0 0 256zm-45.7 48C79.8 304 0 383.8 0 482.3C0 498.7 13.3 512 29.7 512H418.3c16.4 0 29.7-13.3 29.7-29.7C448 383.8 368.2 304 269.7 304H178.3z" }, child: [] }] })(e);
}
const jp = (e) => {
  const [t, n] = Ue([]), [r, o] = Ue([]);
  return Fe(() => {
    const i = [], s = [];
    e.annotation.bodies.forEach((l) => {
      var c, u, f, d, p;
      if (l.purpose === "tagging")
        s.push({
          id: l.id,
          name: l.value || "Unknown",
          color: "green",
          quote: e.annotation.target.selector[0].quote,
          author: ((c = l.creator) == null ? void 0 : c.name) || ((u = e.annotation.target.creator) == null ? void 0 : u.name) || "Anonymous",
          annotation: "_no_annotation_"
        });
      else {
        const h = (f = l.value) == null ? void 0 : f.split(`
`);
        i.push({
          id: l.id,
          quote: e.annotation.target.selector[0].quote,
          annotation: h || [l.value || ""],
          author: ((d = l.creator) == null ? void 0 : d.name) || ((p = e.annotation.target.creator) == null ? void 0 : p.name) || "Anonymous"
        });
      }
    }), n(i), o(s);
  }, [e.annotation]), t.length > 0 || r.length > 0 ? /* @__PURE__ */ F.jsx("div", { className: "popover-wrapper", onClick: e.onClick, children: t.map((i, s) => /* @__PURE__ */ F.jsx("div", { className: "popover-content", children: /* @__PURE__ */ F.jsx("table", { children: /* @__PURE__ */ F.jsxs("tbody", { children: [
    s === 0 && /* @__PURE__ */ F.jsx("tr", { children: /* @__PURE__ */ F.jsx(
      "td",
      {
        className: "popover-annotated-text popover-truncate",
        colSpan: 2,
        children: `...${i.quote}`
      }
    ) }),
    /* @__PURE__ */ F.jsx("tr", { children: /* @__PURE__ */ F.jsxs("td", { className: "popover-person-option", children: [
      /* @__PURE__ */ F.jsx(Xn, { color: "#1e95e5" }),
      i.author
    ] }) }),
    /* @__PURE__ */ F.jsx("tr", { children: /* @__PURE__ */ F.jsx("div", { className: "popover-tag-row", children: r.map((l, c) => /* @__PURE__ */ F.jsxs("td", { className: "popover-category-option", children: [
      c === 0 && /* @__PURE__ */ F.jsx(kr, { color: l.color }),
      /* @__PURE__ */ F.jsx("div", { className: "popover-tag", children: l.name })
    ] }, c)) }) }),
    /* @__PURE__ */ F.jsx("tr", { children: /* @__PURE__ */ F.jsx("td", { className: "popover-teaser", children: /* @__PURE__ */ F.jsx("div", { className: "popover-annotation", children: i.annotation[0] === "_no_annotation_" ? "" : i.annotation.map((l, c) => l.startsWith("http") && [".jpg", ".png"].includes(l.slice(-4)) ? /* @__PURE__ */ F.jsx(
      "img",
      {
        src: l,
        className: "popover-annotation-img",
        alt: "image in annotation"
      },
      c
    ) : l.startsWith("http") ? /* @__PURE__ */ F.jsx("a", { href: l, children: l }, c) : /* @__PURE__ */ F.jsx("div", { className: "popover-annotation-line", children: l })) }) }) })
  ] }) }) }, i.id)) }) : /* @__PURE__ */ F.jsx("div", {});
};
function Np(e) {
  return Rt({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M8 256c0 136.966 111.033 248 248 248s248-111.034 248-248S392.966 8 256 8 8 119.033 8 256zm248 184V72c101.705 0 184 82.311 184 184 0 101.705-82.311 184-184 184z" }, child: [] }] })(e);
}
function jo(e) {
  return Rt({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zM124 296c-6.6 0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h264c6.6 0 12 5.4 12 12v56c0 6.6-5.4 12-12 12H124z" }, child: [] }] })(e);
}
function Ta(e) {
  return Rt({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm144 276c0 6.6-5.4 12-12 12h-92v92c0 6.6-5.4 12-12 12h-56c-6.6 0-12-5.4-12-12v-92h-92c-6.6 0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h92v-92c0-6.6 5.4-12 12-12h56c6.6 0 12 5.4 12 12v92h92c6.6 0 12 5.4 12 12v56z" }, child: [] }] })(e);
}
function Lp(e) {
  return Rt({ tag: "svg", attr: { viewBox: "0 0 576 512" }, child: [{ tag: "path", attr: { d: "M384 64H192C85.961 64 0 149.961 0 256s85.961 192 192 192h192c106.039 0 192-85.961 192-192S490.039 64 384 64zM64 256c0-70.741 57.249-128 128-128 70.741 0 128 57.249 128 128 0 70.741-57.249 128-128 128-70.741 0-128-57.249-128-128zm320 128h-48.905c65.217-72.858 65.236-183.12 0-256H384c70.741 0 128 57.249 128 128 0 70.74-57.249 128-128 128z" }, child: [] }] })(e);
}
function Ip(e) {
  return Rt({ tag: "svg", attr: { viewBox: "0 0 576 512" }, child: [{ tag: "path", attr: { d: "M384 64H192C86 64 0 150 0 256s86 192 192 192h192c106 0 192-86 192-192S490 64 384 64zm0 320c-70.8 0-128-57.3-128-128 0-70.8 57.3-128 128-128 70.8 0 128 57.3 128 128 0 70.8-57.3 128-128 128z" }, child: [] }] })(e);
}
const Dp = (e) => /* @__PURE__ */ F.jsx("div", { className: "header-tabs", children: /* @__PURE__ */ F.jsxs("ul", { children: [
  /* @__PURE__ */ F.jsx(
    "li",
    {
      className: "header-adjust active",
      onClick: () => e.onAdjust(!e.adjust),
      children: /* @__PURE__ */ F.jsx(Np, { size: 20, color: e.adjust ? "#1b6c7a" : void 0 })
    }
  ),
  /* @__PURE__ */ F.jsx(
    "li",
    {
      className: e.activeTab === "annotations" ? "active" : void 0,
      onClick: () => e.onSetActiveTab("annotations"),
      children: "Annotations"
    }
  ),
  /* @__PURE__ */ F.jsx(
    "li",
    {
      className: e.activeTab === "filters" ? "active" : void 0,
      onClick: () => e.onSetActiveTab("filters"),
      children: "Filters"
    }
  )
] }) }), Mp = ({
  opened: e,
  annotation: t,
  adjust: n,
  filtered: r,
  filters: o,
  onClickClose: i,
  onClickOpen: s,
  onAdjust: l,
  onToggleTagFilter: c,
  onToggleAuthorFilter: u
}) => {
  var x, R;
  const [f, d] = Ue("annotations"), [p, h] = Ue(), [m, v] = Ue();
  Fe(() => {
    v(void 0), h(void 0);
  }, [r]);
  const w = (A) => {
    l(A);
  }, b = [];
  t == null || t.bodies.forEach((A) => {
    A.purpose === "tagging" && b.push(A.value || "Unknown");
  });
  const g = r.authors.length > 0 || r.tags.length > 0;
  return /* @__PURE__ */ F.jsx("div", { className: `wrapper ${e ? "visible" : ""}`, children: /* @__PURE__ */ F.jsxs("aside", { className: `sidebar ${e ? "opened" : ""}`, children: [
    /* @__PURE__ */ F.jsx(
      Dp,
      {
        activeTab: f,
        adjust: n,
        onSetActiveTab: d,
        onAdjust: w
      }
    ),
    /* @__PURE__ */ F.jsxs("div", { className: "sidebar-background", children: [
      /* @__PURE__ */ F.jsx(
        "div",
        {
          className: "sidebar-handle",
          onClick: e ? () => i() : () => s(),
          children: e ? /* @__PURE__ */ F.jsx(Pp, { size: 35 }) : /* @__PURE__ */ F.jsx(_p, { size: 35 })
        }
      ),
      f === "annotations" ? /* @__PURE__ */ F.jsxs(F.Fragment, { children: [
        /* @__PURE__ */ F.jsxs("div", { className: "sidebar-header", children: [
          t ? /* @__PURE__ */ F.jsxs(
            "div",
            {
              className: b.length > 0 ? "sidebar-author third" : "sidebar-author",
              children: [
                /* @__PURE__ */ F.jsx(Xn, { color: "#1e95e5" }),
                ((x = t.bodies[0].creator) == null ? void 0 : x.name) || ((R = t.target.creator) == null ? void 0 : R.name)
              ]
            }
          ) : /* @__PURE__ */ F.jsx("div", { className: "sidebar-header-spacer" }),
          b.length > 0 && /* @__PURE__ */ F.jsx("div", { className: "sidebar-tag-container", children: b.map((A, P) => /* @__PURE__ */ F.jsxs("div", { className: "sidebar-tag-sub-container", children: [
            P === 0 && /* @__PURE__ */ F.jsx(kr, { color: "green", style: { paddingRight: 5 } }),
            /* @__PURE__ */ F.jsx("div", { className: "sidebar-tag", children: A })
          ] }, P)) })
        ] }),
        /* @__PURE__ */ F.jsxs("div", { className: "sidebar-content", children: [
          t ? /* @__PURE__ */ F.jsx("div", { className: "sidebar-quote", children: `"${t.target.selector[0].quote}"` }) : /* @__PURE__ */ F.jsx("div", { className: "sidebar-content-empty", children: "Annotation Details" }),
          /* @__PURE__ */ F.jsx("div", { className: "sidebar-annotation", children: t && t.bodies[0] ? t.bodies.map((A, P) => {
            var _, C, M;
            if (A.purpose !== "tagging") {
              const O = (_ = A.value) == null ? void 0 : _.split(`
`);
              return /* @__PURE__ */ F.jsxs("div", { children: [
                P !== 0 && /* @__PURE__ */ F.jsxs("div", { className: "sidebar-annotation-extra-author", children: [
                  /* @__PURE__ */ F.jsx(Xn, { color: "#1e95e5" }),
                  /* @__PURE__ */ F.jsx("div", { children: ((C = A.creator) == null ? void 0 : C.name) || ((M = t.target.creator) == null ? void 0 : M.name) })
                ] }),
                (O || []).map((S, $) => S.startsWith("http") && [".jpg", ".png"].includes(S.slice(-4)) ? /* @__PURE__ */ F.jsx(
                  "img",
                  {
                    src: S,
                    className: "popover-annotation-img",
                    alt: "image in annotation"
                  },
                  $
                ) : S.startsWith("http") ? /* @__PURE__ */ F.jsx("a", { href: S, children: S }, P) : /* @__PURE__ */ F.jsx(
                  "div",
                  {
                    className: "sidebar-annotation-anno",
                    children: S
                  },
                  $
                ))
              ] }, A.id);
            } else
              return /* @__PURE__ */ F.jsx("div", {}, A.id);
          }) : "Select an annotation, or click the 'filters' tab above to filter the document." })
        ] })
      ] }) : /* @__PURE__ */ F.jsxs("div", { className: "sidebar-filters", children: [
        /* @__PURE__ */ F.jsxs(
          "div",
          {
            className: g ? "sidebar-filter-header" : "sidebar-filter-header sidebar-filter-header-active",
            children: [
              /* @__PURE__ */ F.jsxs("div", { className: "sidebar-filter-header-toggle", children: [
                g ? /* @__PURE__ */ F.jsx(Ip, { size: 24 }) : /* @__PURE__ */ F.jsx(Lp, { size: 24 }),
                /* @__PURE__ */ F.jsx("div", { className: "sidebar-filter-toggle-text", children: g ? "Filter: ON" : "Filter: OFF" })
              ] }),
              /* @__PURE__ */ F.jsx("div", { className: "sidebar-filter-header-divider" }),
              r.tags.map((A) => /* @__PURE__ */ F.jsxs(
                "div",
                {
                  className: "sidebar-filter-option",
                  onClick: () => c(A),
                  onMouseEnter: () => h(A),
                  onMouseLeave: () => h(void 0),
                  children: [
                    p === A ? /* @__PURE__ */ F.jsx(jo, { color: "red", style: { paddingRight: 5 } }) : /* @__PURE__ */ F.jsx(kr, { color: "green", style: { paddingRight: 5 } }),
                    A
                  ]
                },
                A
              )),
              r.authors.map((A) => /* @__PURE__ */ F.jsxs(
                "div",
                {
                  className: "sidebar-filter-option",
                  onClick: () => u(A),
                  onMouseEnter: () => v(A),
                  onMouseLeave: () => v(void 0),
                  children: [
                    m === A ? /* @__PURE__ */ F.jsx(jo, { color: "red", style: { paddingRight: 5 } }) : /* @__PURE__ */ F.jsx(Xn, { color: "#1e95e5", style: { paddingRight: 5 } }),
                    A
                  ]
                },
                A
              ))
            ]
          }
        ),
        /* @__PURE__ */ F.jsxs("div", { className: "sidebar-filter-tag-set", children: [
          "Tags:",
          /* @__PURE__ */ F.jsx("div", { className: "sidebar-filter-tags", children: o.tags.map(
            (A) => r.tags.includes(A) ? /* @__PURE__ */ F.jsx("div", {}) : /* @__PURE__ */ F.jsxs(
              "div",
              {
                className: "sidebar-filter-option",
                onClick: () => c(A),
                onMouseEnter: () => h(A),
                onMouseLeave: () => h(void 0),
                children: [
                  p === A ? r.tags.includes(A) ? /* @__PURE__ */ F.jsx(
                    jo,
                    {
                      color: "red",
                      style: { paddingRight: 5 }
                    }
                  ) : /* @__PURE__ */ F.jsx(
                    Ta,
                    {
                      color: "green",
                      style: { paddingRight: 5 }
                    }
                  ) : /* @__PURE__ */ F.jsx(kr, { color: "green", style: { paddingRight: 5 } }),
                  A
                ]
              },
              A
            )
          ) })
        ] }),
        /* @__PURE__ */ F.jsxs("div", { className: "sidebar-filter-tag-set", children: [
          "People:",
          /* @__PURE__ */ F.jsx("div", { className: "sidebar-filter-tags", children: o.authors.map(
            (A) => r.authors.includes(A) ? /* @__PURE__ */ F.jsx("div", {}) : /* @__PURE__ */ F.jsxs(
              "div",
              {
                className: "sidebar-filter-option",
                onClick: () => u(A),
                onMouseEnter: () => v(A),
                onMouseLeave: () => v(void 0),
                children: [
                  m === A ? /* @__PURE__ */ F.jsx(
                    Ta,
                    {
                      color: "green",
                      style: { paddingRight: 5 }
                    }
                  ) : /* @__PURE__ */ F.jsx(Xn, { color: "#1e95e5", style: { paddingRight: 5 } }),
                  A
                ]
              },
              A
            )
          ) })
        ] })
      ] })
    ] })
  ] }) });
}, Fp = () => {
  const e = "0123456789ABCDEF";
  let t = "#";
  for (let n = 0; n < 6; n++)
    t += e[Math.floor(Math.random() * 16)];
  return t;
}, Bp = (e) => {
  const { annotation: t } = e;
  return t.bodies.length > 0 ? /* @__PURE__ */ F.jsx("div", { className: "popup popup-overrides", children: t.bodies.length > 0 && /* @__PURE__ */ F.jsx(jp, { annotation: e.selection, onClick: e.onClick }) }) : /* @__PURE__ */ F.jsx("div", {});
}, Up = (e) => {
  const [t, n] = Ue(), [r, o] = Ue(!1), [i, s] = Ue(!1), [l, c] = Ue(), [u, f] = Ue({ tags: [], authors: [] }), d = $a(), p = _a(), { annotations: h } = Ap(t || ""), m = $r(() => {
    const P = {
      tags: [],
      authors: []
    };
    return l && (P.tags = Object.keys(l.tags), P.authors = Object.keys(l.annotationAuthors)), P;
  }, [l]);
  Fe(() => {
    const P = () => {
      const _ = {
        tags: {},
        annotationAuthors: {},
        annotationTags: {},
        tagAnnotations: {},
        annotations: {}
      };
      return e.config.tagVocabulary.forEach((C) => {
        _.tags[C.tagName] = C.tagColor;
      }), h.forEach((C) => {
        _.annotations[C.id] = C, C.bodies.forEach((M) => {
          var O, S, $, T;
          (O = M.creator) != null && O.name && (_.annotationAuthors[(S = M.creator) == null ? void 0 : S.name] || (_.annotationAuthors[($ = M.creator) == null ? void 0 : $.name] = []), _.annotationAuthors[(T = M.creator) == null ? void 0 : T.name].push(C.id)), M.purpose === "tagging" && M.value && (_.annotationTags[M.value] || (_.annotationTags[M.value] = []), _.tagAnnotations[C.id] || (_.tagAnnotations[C.id] = []), _.annotationTags[M.value].push(C.id), _.tagAnnotations[C.id].push(M.value), _.tags[M.value] || (_.tags[M.value] = Fp()));
        });
      }), _;
    };
    d && h.length > 0 && (d.setAnnotations(h, !0), c(P()));
  }, [d, h, e.config]), Fe(() => {
    if (d && h.length > 0 && l)
      if (u.authors.length === 0 && u.tags.length === 0)
        d.setAnnotations(h, !0);
      else {
        let P = [];
        if (u.authors.length === 0 ? Object.keys(l.annotationAuthors).forEach((_) => {
          l.annotationAuthors[_] && (P = [...P, ...l.annotationAuthors[_]]);
        }) : u.authors.forEach((_) => {
          l.annotationAuthors[_] && (P = [...P, ...l.annotationAuthors[_]]);
        }), u.tags.length > 0) {
          let _ = [];
          u.tags.forEach((C) => {
            l.annotationTags[C] && (_ = [..._, ...l.annotationTags[C]]);
          }), P = P.filter((C) => _.includes(C));
        }
        d.setAnnotations(
          h.filter((_) => P.includes(_.id)),
          !0
        );
      }
  }, [u, d, h, l]), Fe(() => {
    fetch(e.config.teiUrl).then((P) => P.text()).then((P) => {
      n(P);
    });
  }, [e.config.teiUrl]);
  const v = (P, _) => {
    let C = "#feef3d";
    if (l) {
      const M = l.tagAnnotations[P.id];
      M && (C = l.tags[M[0]]);
    }
    return {
      fill: i ? "#AAAAAA33" : C,
      fillOpacity: _ != null && _.selected ? 0.75 : 0.5
    };
  }, w = () => {
    o(!0);
  }, b = () => {
    o(!0);
  }, g = () => {
    o(!1);
  }, x = (P) => {
    s(P);
  }, R = (P) => {
    const _ = JSON.parse(JSON.stringify(u)), C = _.tags.findIndex((M) => M === P);
    C > -1 ? _.tags.splice(C, 1) : _.tags.push(P), f(_);
  }, A = (P) => {
    const _ = JSON.parse(JSON.stringify(u)), C = _.authors.findIndex((M) => M === P);
    C > -1 ? _.authors.splice(C, 1) : _.authors.push(P), f(_);
  };
  return /* @__PURE__ */ F.jsxs("div", { className: "anno-view", children: [
    /* @__PURE__ */ F.jsx("div", { className: "anno-desktop ", children: /* @__PURE__ */ F.jsxs("div", { className: "content-wrapper-2", children: [
      /* @__PURE__ */ F.jsx(yd, { annotatingEnabled: !1, style: v, children: /* @__PURE__ */ F.jsx(rc, { tei: t }) }),
      /* @__PURE__ */ F.jsx(
        vp,
        {
          popup: (P) => /* @__PURE__ */ F.jsx(
            Bp,
            {
              onClick: w,
              selection: p.selected[0].annotation,
              ...P
            }
          )
        }
      )
    ] }) }),
    /* @__PURE__ */ F.jsx(
      Mp,
      {
        opened: r,
        adjust: i,
        filtered: u,
        filters: m,
        onClickClose: g,
        onClickOpen: b,
        annotation: p.selected[0] ? p.selected[0].annotation : void 0,
        onAdjust: x,
        onToggleTagFilter: R,
        onToggleAuthorFilter: A
      }
    )
  ] });
}, Kp = (e) => /* @__PURE__ */ F.jsx(qs, { children: /* @__PURE__ */ F.jsx(Up, { config: e.config }) });
export {
  Kp as CoveEdition
};
//# sourceMappingURL=index.es.js.map
