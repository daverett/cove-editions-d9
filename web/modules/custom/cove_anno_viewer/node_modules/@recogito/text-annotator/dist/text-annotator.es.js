const re = "not-annotatable", tt = `.${re}`, it = (t) => {
  var n;
  return !!(t instanceof HTMLElement ? t.closest(tt) : (n = t.parentElement) == null ? void 0 : n.closest(tt));
}, Ce = (t) => {
  const e = t.commonAncestorContainer;
  return !it(e);
}, Le = (t) => t.addEventListener("click", (e) => {
  // Allow clicks within not-annotatable elements
  !e.target.closest(tt) && !e.target.closest("a") && e.preventDefault();
}), xt = (t) => ({
  ...t,
  type: t.type,
  x: t.x,
  y: t.y,
  clientX: t.clientX,
  clientY: t.clientY,
  offsetX: t.offsetX,
  offsetY: t.offsetY,
  screenX: t.screenX,
  screenY: t.screenY,
  isPrimary: t.isPrimary,
  altKey: t.altKey,
  ctrlKey: t.ctrlKey,
  metaKey: t.metaKey,
  shiftKey: t.shiftKey,
  button: t.button,
  buttons: t.buttons,
  currentTarget: t.currentTarget,
  target: t.target,
  defaultPrevented: t.defaultPrevented,
  detail: t.detail,
  eventPhase: t.eventPhase,
  pointerId: t.pointerId,
  pointerType: t.pointerType,
  timeStamp: t.timeStamp
}), ft = (t) => ({
  ...t,
  type: t.type,
  key: t.key,
  code: t.code,
  location: t.location,
  repeat: t.repeat,
  altKey: t.altKey,
  ctrlKey: t.ctrlKey,
  metaKey: t.metaKey,
  shiftKey: t.shiftKey,
  currentTarget: t.currentTarget,
  target: t.target,
  defaultPrevented: t.defaultPrevented,
  detail: t.detail,
  timeStamp: t.timeStamp
}), Te = /mac/i.test(navigator.userAgentData ? navigator.userAgentData.platform : navigator.platform), Oe = (t) => {
  !t.hasAttribute("tabindex") && t.tabIndex < 0 && t.setAttribute("tabindex", "-1"), t.classList.add("no-focus-outline");
}, Yt = (t, e = 10) => {
  let n;
  return (...o) => {
    clearTimeout(n), n = setTimeout(() => t.apply(void 0, o), e);
  };
}, Be = function* (t) {
  const e = document.createNodeIterator(
    t.commonAncestorContainer,
    NodeFilter.SHOW_ELEMENT,
    (o) => o instanceof HTMLElement && o.classList.contains(re) && !o.parentElement.closest(tt) && t.intersectsNode(o) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
  );
  let n;
  for (; n = e.nextNode(); )
    n instanceof HTMLElement && (yield n);
}, Me = (t) => {
  if (!Ce(t)) return [];
  const e = [];
  let n = null;
  for (const o of Be(t)) {
    let i;
    n ? (i = document.createRange(), i.setStartAfter(n), i.setEndBefore(o)) : (i = t.cloneRange(), i.setEndBefore(o)), i.collapsed || e.push(i), n = o;
  }
  if (n) {
    const o = t.cloneRange();
    o.setStartAfter(n), o.collapsed || e.push(o);
  }
  return e.length > 0 ? e : [t];
}, Ut = (t) => {
  const e = t.cloneContents();
  return e.querySelectorAll(tt).forEach((n) => n.remove()), e;
}, Re = (t, e, n = 10, o) => {
  const i = o ? t.startContainer.parentElement.closest(o) : e, s = document.createRange();
  s.setStart(i, 0), s.setEnd(t.startContainer, t.startOffset);
  const a = Ut(s).textContent, r = document.createRange();
  r.setStart(t.endContainer, t.endOffset), i === document.body ? r.setEnd(i, i.childNodes.length) : r.setEndAfter(i);
  const d = Ut(r).textContent;
  return {
    prefix: a.substring(a.length - n),
    suffix: d.substring(0, n)
  };
}, F = (t) => t.every((e) => e.range instanceof Range && !e.range.collapsed), ke = /^\s*$/, Ie = (t) => ke.test(t.toString()), _e = (t, e) => {
  const n = (s) => Math.round(s * 10) / 10, o = {
    top: n(t.top),
    bottom: n(t.bottom),
    left: n(t.left),
    right: n(t.right)
  }, i = {
    top: n(e.top),
    bottom: n(e.bottom),
    left: n(e.left),
    right: n(e.right)
  };
  if (Math.abs(o.top - i.top) < 0.5 && Math.abs(o.bottom - i.bottom) < 0.5) {
    if (Math.abs(o.left - i.right) < 0.5 || Math.abs(o.right - i.left) < 0.5)
      return "inline-adjacent";
    if (o.left >= i.left && o.right <= i.right)
      return "inline-is-contained";
    if (o.left <= i.left && o.right >= i.right)
      return "inline-contains";
  } else if (o.top <= i.top && o.bottom >= i.bottom) {
    if (o.left <= i.left && o.right >= i.right)
      return "block-contains";
  } else if (o.top >= i.top && o.bottom <= i.bottom && o.left >= i.left && o.right <= i.right)
    return "block-is-contained";
}, Ne = (t, e) => {
  const n = Math.min(t.left, e.left), o = Math.max(t.right, e.right), i = Math.min(t.top, e.top), s = Math.max(t.bottom, e.bottom);
  return new DOMRect(n, i, o - n, s - i);
}, Ue = (t) => t.reduce((e, n) => {
  if (n.width === 0 || n.height === 0)
    return e;
  let o = [...e], i = !1;
  for (const s of e) {
    const a = _e(n, s);
    if (a === "inline-adjacent") {
      o = o.map((r) => r === s ? Ne(n, s) : r), i = !0;
      break;
    } else if (a === "inline-contains") {
      o = o.map((r) => r === s ? n : r), i = !0;
      break;
    } else if (a === "inline-is-contained") {
      i = !0;
      break;
    } else if (a === "block-contains" || a === "block-is-contained") {
      n.width < s.width && (o = o.map((r) => r === s ? n : r)), i = !0;
      break;
    }
  }
  return i ? o : [...o, n];
}, []), wo = (t) => ({
  length: t.length,
  item: (e) => t[e],
  [Symbol.iterator]: function* () {
    for (let e = 0; e < this.length; e++)
      yield this.item(e);
  }
}), Ve = (t, e, n) => {
  const o = document.createRange(), i = n ? t.startContainer.parentElement.closest(n) : e;
  o.setStart(i, 0), o.setEnd(t.startContainer, t.startOffset);
  const s = Ut(o).textContent, a = t.toString(), r = s.length || 0, d = r + a.length;
  return n ? { quote: a, start: r, end: d, range: t, offsetReference: i } : { quote: a, start: r, end: d, range: t };
}, ae = (t, e) => {
  var h, u;
  const { start: n, end: o } = t, i = t.offsetReference || e, s = document.createNodeIterator(
    e,
    NodeFilter.SHOW_TEXT,
    (g) => {
      var v;
      return (v = g.parentElement) != null && v.closest(tt) ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
    }
  );
  let a = 0;
  const r = document.createRange();
  let d = s.nextNode();
  d === null && console.error("Could not revive annotation target. Content missing.");
  let f = !i;
  for (; d !== null; ) {
    if (f || (f = i == null ? void 0 : i.contains(d)), f) {
      const g = ((h = d.textContent) == null ? void 0 : h.length) || 0;
      if (a + g > n) {
        r.setStart(d, n - a);
        break;
      }
      a += g;
    }
    d = s.nextNode();
  }
  for (; d !== null; ) {
    const g = ((u = d.textContent) == null ? void 0 : u.length) || 0;
    if (a + g >= o) {
      r.setEnd(d, o - a);
      break;
    }
    a += g, d = s.nextNode();
  }
  return {
    ...t,
    range: r
  };
}, wt = (t, e) => F(t.selector) ? t : {
  ...t,
  selector: t.selector.map((n) => n.range instanceof Range && !n.range.collapsed ? n : ae(n, e))
}, vt = (t, e) => F(t.target.selector) ? t : { ...t, target: wt(t.target, e) }, Ye = (t, e) => {
  const n = t.cloneRange();
  return e.contains(n.startContainer) || n.setStart(e, 0), e.contains(n.endContainer) || n.setEnd(e, e.childNodes.length), n;
}, ce = (t) => {
  if (t === null)
    return document.scrollingElement;
  const { overflowY: e } = window.getComputedStyle(t);
  return e !== "visible" && e !== "hidden" && t.scrollHeight > t.clientHeight ? t : ce(t.parentElement);
}, De = (t, e) => (n) => {
  const o = typeof n == "string" ? n : n.id, i = (a) => {
    const r = s.getBoundingClientRect(), d = s.clientHeight, f = s.clientWidth, h = a.selector[0].range.getBoundingClientRect(), { width: u, height: g } = e.getAnnotationBounds(o), v = h.top - r.top, p = h.left - r.left, y = s.parentElement ? s.scrollTop : 0, x = s.parentElement ? s.scrollLeft : 0, l = v + y - (d - g) / 2, c = p + x - (f - u) / 2;
    s.scroll({ top: l, left: c, behavior: "smooth" });
  }, s = ce(t);
  if (s) {
    const a = e.getAnnotation(o), { range: r } = a.target.selector[0];
    if (r && !r.collapsed)
      return i(a.target), !0;
    {
      const d = wt(a.target, t), { range: f } = d.selector[0];
      if (f && !f.collapsed)
        return i(d), !0;
    }
  }
  return !1;
}, W = {
  fill: "rgb(0, 128, 255)",
  fillOpacity: 0.18
}, At = {
  fill: "rgb(0, 128, 255)",
  fillOpacity: 0.45
}, Ke = (t, e, n, o, i) => {
  var a, r;
  const s = n ? typeof n == "function" ? n(t.annotation, t.state, i) || ((a = t.state) != null && a.selected ? At : W) : n : (r = t.state) != null && r.selected ? At : W;
  return o && o.paint(t, e) || s;
}, Xe = (t) => {
  const { top: e, left: n } = t.getBoundingClientRect(), { innerWidth: o, innerHeight: i } = window, s = -n, a = -e, r = o - n, d = i - e;
  return { top: e, left: n, minX: s, minY: a, maxX: r, maxY: d };
}, Pe = (t) => {
  let e = /* @__PURE__ */ new Set();
  return (o) => {
    const i = o.map((s) => s.id);
    (e.size !== i.length || i.some((s) => !e.has(s))) && t.set(i), e = new Set(i);
  };
}, Dt = (t, e, n, o) => {
  const { store: i, selection: s, hover: a } = e;
  let r, d, f;
  const h = Pe(n), u = (B) => {
    const { x: T, y: m } = t.getBoundingClientRect(), A = i.getAt(B.clientX - T, B.clientY - m, !1, d);
    A ? a.current !== A.id && (t.classList.add("hovered"), a.set(A.id)) : a.current && (t.classList.remove("hovered"), a.set(null));
  };
  t.addEventListener("pointermove", u);
  const g = (B = !1) => {
    f && f.clear();
    const T = Xe(t), { minX: m, minY: A, maxX: w, maxY: L } = T, M = d ? i.getIntersecting(m, A, w, L).filter(({ annotation: U }) => d(U)) : i.getIntersecting(m, A, w, L), R = s.selected.map(({ id: U }) => U), N = M.map(({ annotation: U, rects: et }) => {
      const q = R.includes(U.id), Se = U.id === a.current;
      return { annotation: U, rects: et, state: { selected: q, hover: Se } };
    });
    o.redraw(N, T, r, f, B), setTimeout(() => h(M.map(({ annotation: U }) => U)), 1);
  }, v = (B) => {
    f = B, g();
  }, p = (B) => {
    r = B, g();
  }, y = (B) => {
    d = B, g(!1);
  }, x = () => g();
  i.observe(x);
  const l = s.subscribe(() => g()), c = () => g(!0);
  document.addEventListener("scroll", c, { capture: !0, passive: !0 });
  const b = Yt(() => {
    i.recalculatePositions(), f && f.reset(), g();
  });
  window.addEventListener("resize", b);
  const S = new ResizeObserver(b);
  S.observe(t);
  const E = { attributes: !0, childList: !0, subtree: !0 }, C = new MutationObserver((B) => {
    B.every((m) => m.target === t || t.contains(m.target)) || g(!0);
  });
  return C.observe(document.body, E), {
    destroy: () => {
      t.removeEventListener("pointermove", u), o.destroy(), i.unobserve(x), l(), document.removeEventListener("scroll", c), window.removeEventListener("resize", b), S.disconnect(), C.disconnect();
    },
    redraw: g,
    setStyle: p,
    setFilter: y,
    setPainter: v,
    setVisible: o.setVisible
  };
}, $e = () => {
  const t = document.createElement("canvas");
  return t.width = window.innerWidth, t.height = window.innerHeight, t.className = "r6o-canvas-highlight-layer bg", t;
}, He = (t, e) => {
  t.width = window.innerWidth, t.height = window.innerHeight;
}, je = (t) => {
  t.classList.add("r6o-annotatable");
  const e = $e(), n = e.getContext("2d");
  document.body.appendChild(e);
  const o = (r, d, f, h) => requestAnimationFrame(() => {
    const { width: u, height: g } = e;
    n.clearRect(-0.5, -0.5, u + 1, g + 1), h && h.clear();
    const { top: v, left: p } = d;
    [...r].sort((x, l) => {
      const { annotation: { target: { created: c } } } = x, { annotation: { target: { created: b } } } = l;
      return c.getTime() - b.getTime();
    }).forEach((x) => {
      var S;
      const l = f ? typeof f == "function" ? f(x.annotation, x.state) : f : (S = x.state) != null && S.selected ? At : W, c = h && h.paint(x, d) || l, b = x.rects.map(({ x: E, y: C, width: O, height: B }) => ({
        x: E + p,
        y: C + v,
        width: O,
        height: B
      }));
      if (n.fillStyle = c.fill, n.globalAlpha = c.fillOpacity || 1, b.forEach(
        ({ x: E, y: C, width: O, height: B }) => n.fillRect(E, C, O, B)
      ), c.underlineColor) {
        n.globalAlpha = 1, n.strokeStyle = c.underlineColor, n.lineWidth = c.underlineThickness ?? 1;
        const E = c.underlineOffset ?? 0;
        b.forEach(({ x: C, y: O, width: B, height: T }) => {
          n.beginPath(), n.moveTo(C, O + T + E), n.lineTo(C + B, O + T + E), n.stroke();
        });
      }
    });
  }), i = Yt(() => {
    He(e);
  });
  return window.addEventListener("resize", i), {
    destroy: () => {
      e.remove(), window.removeEventListener("resize", i);
    },
    setVisible: (r) => {
      console.log("setVisible not implemented on Canvas renderer");
    },
    redraw: o
  };
}, ze = (t, e, n) => Dt(t, e, n, je(t));
var Fe = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) }, j = function(t) {
  return typeof t == "string" ? t.length > 0 : typeof t == "number";
}, V = function(t, e, n) {
  return e === void 0 && (e = 0), n === void 0 && (n = Math.pow(10, e)), Math.round(n * t) / n + 0;
}, X = function(t, e, n) {
  return e === void 0 && (e = 0), n === void 0 && (n = 1), t > n ? n : t > e ? t : e;
}, le = function(t) {
  return (t = isFinite(t) ? t % 360 : 0) > 0 ? t : t + 360;
}, Pt = function(t) {
  return { r: X(t.r, 0, 255), g: X(t.g, 0, 255), b: X(t.b, 0, 255), a: X(t.a) };
}, Et = function(t) {
  return { r: V(t.r), g: V(t.g), b: V(t.b), a: V(t.a, 3) };
}, We = /^#([0-9a-f]{3,8})$/i, ht = function(t) {
  var e = t.toString(16);
  return e.length < 2 ? "0" + e : e;
}, de = function(t) {
  var e = t.r, n = t.g, o = t.b, i = t.a, s = Math.max(e, n, o), a = s - Math.min(e, n, o), r = a ? s === e ? (n - o) / a : s === n ? 2 + (o - e) / a : 4 + (e - n) / a : 0;
  return { h: 60 * (r < 0 ? r + 6 : r), s: s ? a / s * 100 : 0, v: s / 255 * 100, a: i };
}, ue = function(t) {
  var e = t.h, n = t.s, o = t.v, i = t.a;
  e = e / 360 * 6, n /= 100, o /= 100;
  var s = Math.floor(e), a = o * (1 - n), r = o * (1 - (e - s) * n), d = o * (1 - (1 - e + s) * n), f = s % 6;
  return { r: 255 * [o, r, a, a, d, o][f], g: 255 * [d, o, o, r, a, a][f], b: 255 * [a, a, d, o, o, r][f], a: i };
}, $t = function(t) {
  return { h: le(t.h), s: X(t.s, 0, 100), l: X(t.l, 0, 100), a: X(t.a) };
}, Ht = function(t) {
  return { h: V(t.h), s: V(t.s), l: V(t.l), a: V(t.a, 3) };
}, jt = function(t) {
  return ue((n = (e = t).s, { h: e.h, s: (n *= ((o = e.l) < 50 ? o : 100 - o) / 100) > 0 ? 2 * n / (o + n) * 100 : 0, v: o + n, a: e.a }));
  var e, n, o;
}, at = function(t) {
  return { h: (e = de(t)).h, s: (i = (200 - (n = e.s)) * (o = e.v) / 100) > 0 && i < 200 ? n * o / 100 / (i <= 100 ? i : 200 - i) * 100 : 0, l: i / 2, a: e.a };
  var e, n, o, i;
}, qe = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, Ge = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, Qe = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, Je = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, zt = { string: [[function(t) {
  var e = We.exec(t);
  return e ? (t = e[1]).length <= 4 ? { r: parseInt(t[0] + t[0], 16), g: parseInt(t[1] + t[1], 16), b: parseInt(t[2] + t[2], 16), a: t.length === 4 ? V(parseInt(t[3] + t[3], 16) / 255, 2) : 1 } : t.length === 6 || t.length === 8 ? { r: parseInt(t.substr(0, 2), 16), g: parseInt(t.substr(2, 2), 16), b: parseInt(t.substr(4, 2), 16), a: t.length === 8 ? V(parseInt(t.substr(6, 2), 16) / 255, 2) : 1 } : null : null;
}, "hex"], [function(t) {
  var e = Qe.exec(t) || Je.exec(t);
  return e ? e[2] !== e[4] || e[4] !== e[6] ? null : Pt({ r: Number(e[1]) / (e[2] ? 100 / 255 : 1), g: Number(e[3]) / (e[4] ? 100 / 255 : 1), b: Number(e[5]) / (e[6] ? 100 / 255 : 1), a: e[7] === void 0 ? 1 : Number(e[7]) / (e[8] ? 100 : 1) }) : null;
}, "rgb"], [function(t) {
  var e = qe.exec(t) || Ge.exec(t);
  if (!e) return null;
  var n, o, i = $t({ h: (n = e[1], o = e[2], o === void 0 && (o = "deg"), Number(n) * (Fe[o] || 1)), s: Number(e[3]), l: Number(e[4]), a: e[5] === void 0 ? 1 : Number(e[5]) / (e[6] ? 100 : 1) });
  return jt(i);
}, "hsl"]], object: [[function(t) {
  var e = t.r, n = t.g, o = t.b, i = t.a, s = i === void 0 ? 1 : i;
  return j(e) && j(n) && j(o) ? Pt({ r: Number(e), g: Number(n), b: Number(o), a: Number(s) }) : null;
}, "rgb"], [function(t) {
  var e = t.h, n = t.s, o = t.l, i = t.a, s = i === void 0 ? 1 : i;
  if (!j(e) || !j(n) || !j(o)) return null;
  var a = $t({ h: Number(e), s: Number(n), l: Number(o), a: Number(s) });
  return jt(a);
}, "hsl"], [function(t) {
  var e = t.h, n = t.s, o = t.v, i = t.a, s = i === void 0 ? 1 : i;
  if (!j(e) || !j(n) || !j(o)) return null;
  var a = function(r) {
    return { h: le(r.h), s: X(r.s, 0, 100), v: X(r.v, 0, 100), a: X(r.a) };
  }({ h: Number(e), s: Number(n), v: Number(o), a: Number(s) });
  return ue(a);
}, "hsv"]] }, Ft = function(t, e) {
  for (var n = 0; n < e.length; n++) {
    var o = e[n][0](t);
    if (o) return [o, e[n][1]];
  }
  return [null, void 0];
}, Ze = function(t) {
  return typeof t == "string" ? Ft(t.trim(), zt.string) : typeof t == "object" && t !== null ? Ft(t, zt.object) : [null, void 0];
}, St = function(t, e) {
  var n = at(t);
  return { h: n.h, s: X(n.s + 100 * e, 0, 100), l: n.l, a: n.a };
}, Ct = function(t) {
  return (299 * t.r + 587 * t.g + 114 * t.b) / 1e3 / 255;
}, Wt = function(t, e) {
  var n = at(t);
  return { h: n.h, s: n.s, l: X(n.l + 100 * e, 0, 100), a: n.a };
}, qt = function() {
  function t(e) {
    this.parsed = Ze(e)[0], this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 };
  }
  return t.prototype.isValid = function() {
    return this.parsed !== null;
  }, t.prototype.brightness = function() {
    return V(Ct(this.rgba), 2);
  }, t.prototype.isDark = function() {
    return Ct(this.rgba) < 0.5;
  }, t.prototype.isLight = function() {
    return Ct(this.rgba) >= 0.5;
  }, t.prototype.toHex = function() {
    return e = Et(this.rgba), n = e.r, o = e.g, i = e.b, a = (s = e.a) < 1 ? ht(V(255 * s)) : "", "#" + ht(n) + ht(o) + ht(i) + a;
    var e, n, o, i, s, a;
  }, t.prototype.toRgb = function() {
    return Et(this.rgba);
  }, t.prototype.toRgbString = function() {
    return e = Et(this.rgba), n = e.r, o = e.g, i = e.b, (s = e.a) < 1 ? "rgba(" + n + ", " + o + ", " + i + ", " + s + ")" : "rgb(" + n + ", " + o + ", " + i + ")";
    var e, n, o, i, s;
  }, t.prototype.toHsl = function() {
    return Ht(at(this.rgba));
  }, t.prototype.toHslString = function() {
    return e = Ht(at(this.rgba)), n = e.h, o = e.s, i = e.l, (s = e.a) < 1 ? "hsla(" + n + ", " + o + "%, " + i + "%, " + s + ")" : "hsl(" + n + ", " + o + "%, " + i + "%)";
    var e, n, o, i, s;
  }, t.prototype.toHsv = function() {
    return e = de(this.rgba), { h: V(e.h), s: V(e.s), v: V(e.v), a: V(e.a, 3) };
    var e;
  }, t.prototype.invert = function() {
    return $({ r: 255 - (e = this.rgba).r, g: 255 - e.g, b: 255 - e.b, a: e.a });
    var e;
  }, t.prototype.saturate = function(e) {
    return e === void 0 && (e = 0.1), $(St(this.rgba, e));
  }, t.prototype.desaturate = function(e) {
    return e === void 0 && (e = 0.1), $(St(this.rgba, -e));
  }, t.prototype.grayscale = function() {
    return $(St(this.rgba, -1));
  }, t.prototype.lighten = function(e) {
    return e === void 0 && (e = 0.1), $(Wt(this.rgba, e));
  }, t.prototype.darken = function(e) {
    return e === void 0 && (e = 0.1), $(Wt(this.rgba, -e));
  }, t.prototype.rotate = function(e) {
    return e === void 0 && (e = 15), this.hue(this.hue() + e);
  }, t.prototype.alpha = function(e) {
    return typeof e == "number" ? $({ r: (n = this.rgba).r, g: n.g, b: n.b, a: e }) : V(this.rgba.a, 3);
    var n;
  }, t.prototype.hue = function(e) {
    var n = at(this.rgba);
    return typeof e == "number" ? $({ h: e, s: n.s, l: n.l, a: n.a }) : V(n.h);
  }, t.prototype.isEqual = function(e) {
    return this.toHex() === $(e).toHex();
  }, t;
}(), $ = function(t) {
  return t instanceof qt ? t : new qt(t);
};
const tn = (t) => [
  `background-color:${$((t == null ? void 0 : t.fill) || W.fill).alpha((t == null ? void 0 : t.fillOpacity) === void 0 ? W.fillOpacity : t.fillOpacity).toHex()}`,
  t != null && t.underlineThickness ? "text-decoration:underline" : void 0,
  t != null && t.underlineColor ? `text-decoration-color:${t.underlineColor}` : void 0,
  t != null && t.underlineOffset ? `text-underline-offset:${t.underlineOffset}px` : void 0,
  t != null && t.underlineThickness ? `text-decoration-thickness:${t.underlineThickness}px` : void 0
].filter(Boolean).join(";"), en = () => {
  const t = document.createElement("style");
  document.getElementsByTagName("head")[0].appendChild(t);
  let e = /* @__PURE__ */ new Set();
  return {
    destroy: () => {
      CSS.highlights.clear(), t.remove();
    },
    setVisible: (s) => {
      console.log("setVisible not implemented on CSS Custom Highlights renderer");
    },
    redraw: (s, a, r, d) => {
      d && d.clear();
      const f = new Set(s.map((u) => u.annotation.id));
      Array.from(e).filter((u) => !f.has(u));
      const h = s.map((u) => {
        var p;
        const g = r ? typeof r == "function" ? r(u.annotation, u.state) : r : (p = u.state) != null && p.selected ? At : W, v = d && d.paint(u, a) || g;
        return `::highlight(_${u.annotation.id}) { ${tn(v)} }`;
      });
      t.innerHTML = h.join(`
`), CSS.highlights.clear(), s.forEach(({ annotation: u }) => {
        const g = u.target.selector.map((p) => p.range), v = new Highlight(...g);
        CSS.highlights.set(`_${u.id}`, v);
      }), e = f;
    }
  };
}, nn = (t, e, n) => Dt(t, e, n, en());
var Gt = Object.prototype.hasOwnProperty;
function Vt(t, e) {
  var n, o;
  if (t === e) return !0;
  if (t && e && (n = t.constructor) === e.constructor) {
    if (n === Date) return t.getTime() === e.getTime();
    if (n === RegExp) return t.toString() === e.toString();
    if (n === Array) {
      if ((o = t.length) === e.length)
        for (; o-- && Vt(t[o], e[o]); ) ;
      return o === -1;
    }
    if (!n || typeof t == "object") {
      o = 0;
      for (n in t)
        if (Gt.call(t, n) && ++o && !Gt.call(e, n) || !(n in e) || !Vt(t[n], e[n])) return !1;
      return Object.keys(e).length === o;
    }
  }
  return t !== t && e !== e;
}
const on = (t, e) => {
  const n = (s, a) => s.x <= a.x + a.width && s.x + s.width >= a.x && s.y <= a.y + a.height && s.y + s.height >= a.y, o = (s) => s.rects.reduce((a, r) => a + r.width, 0), i = e.filter(({ rects: s }) => s.some((a) => n(t, a)));
  return i.sort((s, a) => o(a) - o(s)), i.findIndex((s) => s.rects.includes(t));
}, sn = (t) => {
  t.classList.add("r6o-annotatable");
  const e = document.createElement("div");
  e.className = "r6o-span-highlight-layer", t.insertBefore(e, t.firstChild);
  let n = [];
  return {
    destroy: () => {
      e.remove();
    },
    redraw: (a, r, d, f, h) => {
      const g = !(Vt(n, a) && h);
      if (!f && !g) return;
      g && (e.innerHTML = ""), [...a].sort((p, y) => {
        const { annotation: { target: { created: x } } } = p, { annotation: { target: { created: l } } } = y;
        return x && l ? x.getTime() - l.getTime() : 0;
      }).forEach((p) => {
        p.rects.map((y) => {
          const x = on(y, a), l = Ke(p, r, d, f, x);
          if (g) {
            const c = document.createElement("span");
            c.className = "r6o-annotation", c.dataset.annotation = p.annotation.id, c.style.left = `${y.x}px`, c.style.top = `${y.y}px`, c.style.width = `${y.width}px`, c.style.height = `${y.height}px`, c.style.backgroundColor = $((l == null ? void 0 : l.fill) || W.fill).alpha((l == null ? void 0 : l.fillOpacity) === void 0 ? W.fillOpacity : l.fillOpacity).toHex(), l.underlineStyle && (c.style.borderStyle = l.underlineStyle), l.underlineColor && (c.style.borderColor = l.underlineColor), l.underlineThickness && (c.style.borderBottomWidth = `${l.underlineThickness}px`), l.underlineOffset && (c.style.paddingBottom = `${l.underlineOffset}px`), e.appendChild(c);
          }
        });
      }), n = a;
    },
    setVisible: (a) => {
      a ? e.classList.remove("hidden") : e.classList.add("hidden");
    }
  };
}, rn = (t, e, n) => Dt(t, e, n, sn(t)), Y = [];
for (let t = 0; t < 256; ++t)
  Y.push((t + 256).toString(16).slice(1));
function an(t, e = 0) {
  return (Y[t[e + 0]] + Y[t[e + 1]] + Y[t[e + 2]] + Y[t[e + 3]] + "-" + Y[t[e + 4]] + Y[t[e + 5]] + "-" + Y[t[e + 6]] + Y[t[e + 7]] + "-" + Y[t[e + 8]] + Y[t[e + 9]] + "-" + Y[t[e + 10]] + Y[t[e + 11]] + Y[t[e + 12]] + Y[t[e + 13]] + Y[t[e + 14]] + Y[t[e + 15]]).toLowerCase();
}
let Lt;
const cn = new Uint8Array(16);
function ln() {
  if (!Lt) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    Lt = crypto.getRandomValues.bind(crypto);
  }
  return Lt(cn);
}
const dn = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), Qt = { randomUUID: dn };
function fe(t, e, n) {
  if (Qt.randomUUID && !e && !t)
    return Qt.randomUUID();
  t = t || {};
  const o = t.random || (t.rng || ln)();
  return o[6] = o[6] & 15 | 64, o[8] = o[8] & 63 | 128, an(o);
}
var Jt = Object.prototype.hasOwnProperty;
function G(t, e) {
  var n, o;
  if (t === e) return !0;
  if (t && e && (n = t.constructor) === e.constructor) {
    if (n === Date) return t.getTime() === e.getTime();
    if (n === RegExp) return t.toString() === e.toString();
    if (n === Array) {
      if ((o = t.length) === e.length)
        for (; o-- && G(t[o], e[o]); ) ;
      return o === -1;
    }
    if (!n || typeof t == "object") {
      o = 0;
      for (n in t)
        if (Jt.call(t, n) && ++o && !Jt.call(e, n) || !(n in e) || !G(t[n], e[n])) return !1;
      return Object.keys(e).length === o;
    }
  }
  return t !== t && e !== e;
}
function Tt() {
}
function un(t, e) {
  return t != t ? e == e : t !== e || t && typeof t == "object" || typeof t == "function";
}
const Q = [];
function Kt(t, e = Tt) {
  let n;
  const o = /* @__PURE__ */ new Set();
  function i(r) {
    if (un(t, r) && (t = r, n)) {
      const d = !Q.length;
      for (const f of o)
        f[1](), Q.push(f, t);
      if (d) {
        for (let f = 0; f < Q.length; f += 2)
          Q[f][0](Q[f + 1]);
        Q.length = 0;
      }
    }
  }
  function s(r) {
    i(r(t));
  }
  function a(r, d = Tt) {
    const f = [r, d];
    return o.add(f), o.size === 1 && (n = e(i, s) || Tt), r(t), () => {
      o.delete(f), o.size === 0 && n && (n(), n = null);
    };
  }
  return { set: i, update: s, subscribe: a };
}
const fn = (t) => {
  const { subscribe: e, set: n } = Kt();
  let o;
  return e((i) => o = i), t.observe(({ changes: i }) => {
    if (o) {
      (i.deleted || []).some((a) => a.id === o) && n(void 0);
      const s = (i.updated || []).find(({ oldValue: a }) => a.id === o);
      s && n(s.newValue.id);
    }
  }), {
    get current() {
      return o;
    },
    subscribe: e,
    set: n
  };
};
var hn = /* @__PURE__ */ ((t) => (t.EDIT = "EDIT", t.SELECT = "SELECT", t.NONE = "NONE", t))(hn || {});
const gt = { selected: [] }, gn = (t, e, n) => {
  const { subscribe: o, set: i } = Kt(gt);
  let s = e, a = gt;
  o((p) => a = p);
  const r = () => {
    G(a, gt) || i(gt);
  }, d = () => {
    var p;
    return ((p = a.selected) == null ? void 0 : p.length) === 0;
  }, f = (p) => {
    if (d())
      return !1;
    const y = typeof p == "string" ? p : p.id;
    return a.selected.some((x) => x.id === y);
  }, h = (p, y) => {
    let x;
    if (Array.isArray(p)) {
      if (x = p.map((c) => t.getAnnotation(c)).filter(Boolean), x.length < p.length) {
        console.warn("Invalid selection: " + p.filter((c) => !x.some((b) => b.id === c)));
        return;
      }
    } else {
      const c = t.getAnnotation(p);
      if (!c) {
        console.warn("Invalid selection: " + p);
        return;
      }
      x = [c];
    }
    const l = x.reduce((c, b) => {
      const S = Zt(b, s);
      return S === "EDIT" ? [...c, { id: b.id, editable: !0 }] : S === "SELECT" ? [...c, { id: b.id }] : c;
    }, []);
    i({ selected: l, event: y });
  }, u = (p, y) => {
    const x = Array.isArray(p) ? p : [p], l = x.map((c) => t.getAnnotation(c)).filter((c) => !!c);
    i({
      selected: l.map((c) => {
        const b = y === void 0 ? Zt(c, s) === "EDIT" : y;
        return { id: c.id, editable: b };
      })
    }), l.length !== x.length && console.warn("Invalid selection", p);
  }, g = (p) => {
    if (d())
      return !1;
    const { selected: y } = a;
    y.some(({ id: x }) => p.includes(x)) && i({ selected: y.filter(({ id: x }) => !p.includes(x)) });
  }, v = (p) => s = p;
  return t.observe(
    ({ changes: p }) => g((p.deleted || []).map((y) => y.id))
  ), {
    get event() {
      return a ? a.event : null;
    },
    get selected() {
      return a ? [...a.selected] : null;
    },
    get userSelectAction() {
      return s;
    },
    clear: r,
    isEmpty: d,
    isSelected: f,
    setSelected: u,
    setUserSelectAction: v,
    subscribe: o,
    userSelect: h
  };
}, Zt = (t, e, n) => typeof e == "function" ? e(t) : e || "EDIT", D = [];
for (let t = 0; t < 256; ++t)
  D.push((t + 256).toString(16).slice(1));
function pn(t, e = 0) {
  return (D[t[e + 0]] + D[t[e + 1]] + D[t[e + 2]] + D[t[e + 3]] + "-" + D[t[e + 4]] + D[t[e + 5]] + "-" + D[t[e + 6]] + D[t[e + 7]] + "-" + D[t[e + 8]] + D[t[e + 9]] + "-" + D[t[e + 10]] + D[t[e + 11]] + D[t[e + 12]] + D[t[e + 13]] + D[t[e + 14]] + D[t[e + 15]]).toLowerCase();
}
let Ot;
const mn = new Uint8Array(16);
function yn() {
  if (!Ot) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    Ot = crypto.getRandomValues.bind(crypto);
  }
  return Ot(mn);
}
const bn = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), te = { randomUUID: bn };
function he(t, e, n) {
  if (te.randomUUID && !e && !t)
    return te.randomUUID();
  t = t || {};
  const o = t.random || (t.rng || yn)();
  return o[6] = o[6] & 15 | 64, o[8] = o[8] & 63 | 128, pn(o);
}
const Bt = (t) => {
  const e = (n) => {
    const o = { ...n };
    return n.created && typeof n.created == "string" && (o.created = new Date(n.created)), n.updated && typeof n.updated == "string" && (o.updated = new Date(n.updated)), o;
  };
  return {
    ...t,
    bodies: (t.bodies || []).map(e),
    target: e(t.target)
  };
}, Ao = (t, e, n, o) => ({
  id: he(),
  annotation: typeof t == "string" ? t : t.id,
  created: n || /* @__PURE__ */ new Date(),
  creator: o,
  ...e
}), wn = (t, e) => {
  const n = new Set(t.bodies.map((o) => o.id));
  return e.bodies.filter((o) => !n.has(o.id));
}, An = (t, e) => {
  const n = new Set(e.bodies.map((o) => o.id));
  return t.bodies.filter((o) => !n.has(o.id));
}, xn = (t, e) => e.bodies.map((n) => {
  const o = t.bodies.find((i) => i.id === n.id);
  return { newBody: n, oldBody: o && !G(o, n) ? o : void 0 };
}).filter(({ oldBody: n }) => n).map(({ oldBody: n, newBody: o }) => ({ oldBody: n, newBody: o })), vn = (t, e) => !G(t.target, e.target), ge = (t, e) => {
  const n = wn(t, e), o = An(t, e), i = xn(t, e);
  return {
    oldValue: t,
    newValue: e,
    bodiesCreated: n.length > 0 ? n : void 0,
    bodiesDeleted: o.length > 0 ? o : void 0,
    bodiesUpdated: i.length > 0 ? i : void 0,
    targetUpdated: vn(t, e) ? { oldTarget: t.target, newTarget: e.target } : void 0
  };
};
var k = /* @__PURE__ */ ((t) => (t.LOCAL = "LOCAL", t.REMOTE = "REMOTE", t.SILENT = "SILENT", t))(k || {});
const En = (t, e) => {
  var n, o;
  const { changes: i, origin: s } = e;
  if (!(t.options.origin ? t.options.origin === s : s !== "SILENT"))
    return !1;
  if (t.options.ignore) {
    const { ignore: a } = t.options, r = (d) => d && d.length > 0;
    if (!(r(i.created) || r(i.deleted))) {
      const d = (n = i.updated) == null ? void 0 : n.some((h) => r(h.bodiesCreated) || r(h.bodiesDeleted) || r(h.bodiesUpdated)), f = (o = i.updated) == null ? void 0 : o.some((h) => h.targetUpdated);
      if (a === "BODY_ONLY" && d && !f || a === "TARGET_ONLY" && f && !d)
        return !1;
    }
  }
  if (t.options.annotations) {
    const a = /* @__PURE__ */ new Set([
      ...(i.created || []).map((r) => r.id),
      ...(i.deleted || []).map((r) => r.id),
      ...(i.updated || []).map(({ oldValue: r }) => r.id)
    ]);
    return !!(Array.isArray(t.options.annotations) ? t.options.annotations : [t.options.annotations]).find((r) => a.has(r));
  } else
    return !0;
}, Sn = (t, e) => {
  const n = new Set((t.created || []).map((u) => u.id)), o = new Set((t.updated || []).map(({ newValue: u }) => u.id)), i = new Set((e.created || []).map((u) => u.id)), s = new Set((e.deleted || []).map((u) => u.id)), a = new Set((e.updated || []).map(({ oldValue: u }) => u.id)), r = new Set((e.updated || []).filter(({ oldValue: u }) => n.has(u.id) || o.has(u.id)).map(({ oldValue: u }) => u.id)), d = [
    ...(t.created || []).filter((u) => !s.has(u.id)).map((u) => a.has(u.id) ? e.updated.find(({ oldValue: g }) => g.id === u.id).newValue : u),
    ...e.created || []
  ], f = [
    ...(t.deleted || []).filter((u) => !i.has(u.id)),
    ...(e.deleted || []).filter((u) => !n.has(u.id))
  ], h = [
    ...(t.updated || []).filter(({ newValue: u }) => !s.has(u.id)).map((u) => {
      const { oldValue: g, newValue: v } = u;
      if (a.has(v.id)) {
        const p = e.updated.find((y) => y.oldValue.id === v.id).newValue;
        return ge(g, p);
      } else
        return u;
    }),
    ...(e.updated || []).filter(({ oldValue: u }) => !r.has(u.id))
  ];
  return { created: d, deleted: f, updated: h };
}, Mt = (t) => {
  const e = t.id === void 0 ? he() : t.id;
  return {
    ...t,
    id: e,
    bodies: t.bodies === void 0 ? [] : t.bodies.map((n) => ({
      ...n,
      annotation: e
    })),
    target: {
      ...t.target,
      annotation: e
    }
  };
}, Cn = (t) => t.id !== void 0, Ln = () => {
  const t = /* @__PURE__ */ new Map(), e = /* @__PURE__ */ new Map(), n = [], o = (m, A = {}) => {
    n.push({ onChange: m, options: A });
  }, i = (m) => {
    const A = n.findIndex((w) => w.onChange == m);
    A > -1 && n.splice(A, 1);
  }, s = (m, A) => {
    const w = {
      origin: m,
      changes: {
        created: A.created || [],
        updated: A.updated || [],
        deleted: A.deleted || []
      },
      state: [...t.values()]
    };
    n.forEach((L) => {
      En(L, w) && L.onChange(w);
    });
  }, a = (m, A = k.LOCAL) => {
    if (m.id && t.get(m.id))
      throw Error(`Cannot add annotation ${m.id} - exists already`);
    {
      const w = Mt(m);
      t.set(w.id, w), w.bodies.forEach((L) => e.set(L.id, w.id)), s(A, { created: [w] });
    }
  }, r = (m, A) => {
    const w = Mt(typeof m == "string" ? A : m), L = typeof m == "string" ? m : m.id, M = L && t.get(L);
    if (M) {
      const R = ge(M, w);
      return L === w.id ? t.set(L, w) : (t.delete(L), t.set(w.id, w)), M.bodies.forEach((N) => e.delete(N.id)), w.bodies.forEach((N) => e.set(N.id, w.id)), R;
    } else
      console.warn(`Cannot update annotation ${L} - does not exist`);
  }, d = (m, A = k.LOCAL, w = k.LOCAL) => {
    const L = Cn(A) ? w : A, M = r(m, A);
    M && s(L, { updated: [M] });
  }, f = (m, A = k.LOCAL) => {
    const w = m.reduce((L, M) => {
      const R = r(M);
      return R ? [...L, R] : L;
    }, []);
    w.length > 0 && s(A, { updated: w });
  }, h = (m, A = k.LOCAL) => {
    const w = t.get(m.annotation);
    if (w) {
      const L = {
        ...w,
        bodies: [...w.bodies, m]
      };
      t.set(w.id, L), e.set(m.id, L.id), s(A, { updated: [{
        oldValue: w,
        newValue: L,
        bodiesCreated: [m]
      }] });
    } else
      console.warn(`Attempt to add body to missing annotation: ${m.annotation}`);
  }, u = () => [...t.values()], g = (m = k.LOCAL) => {
    const A = [...t.values()];
    t.clear(), e.clear(), s(m, { deleted: A });
  }, v = (m, A = !0, w = k.LOCAL) => {
    const L = m.map(Mt);
    if (A) {
      const M = [...t.values()];
      t.clear(), e.clear(), L.forEach((R) => {
        t.set(R.id, R), R.bodies.forEach((N) => e.set(N.id, R.id));
      }), s(w, { created: L, deleted: M });
    } else {
      const M = m.reduce((R, N) => {
        const U = N.id && t.get(N.id);
        return U ? [...R, U] : R;
      }, []);
      if (M.length > 0)
        throw Error(`Bulk insert would overwrite the following annotations: ${M.map((R) => R.id).join(", ")}`);
      L.forEach((R) => {
        t.set(R.id, R), R.bodies.forEach((N) => e.set(N.id, R.id));
      }), s(w, { created: L });
    }
  }, p = (m) => {
    const A = typeof m == "string" ? m : m.id, w = t.get(A);
    if (w)
      return t.delete(A), w.bodies.forEach((L) => e.delete(L.id)), w;
    console.warn(`Attempt to delete missing annotation: ${A}`);
  }, y = (m, A = k.LOCAL) => {
    const w = p(m);
    w && s(A, { deleted: [w] });
  }, x = (m, A = k.LOCAL) => {
    const w = m.reduce((L, M) => {
      const R = p(M);
      return R ? [...L, R] : L;
    }, []);
    w.length > 0 && s(A, { deleted: w });
  }, l = (m) => {
    const A = t.get(m.annotation);
    if (A) {
      const w = A.bodies.find((L) => L.id === m.id);
      if (w) {
        e.delete(w.id);
        const L = {
          ...A,
          bodies: A.bodies.filter((M) => M.id !== m.id)
        };
        return t.set(A.id, L), {
          oldValue: A,
          newValue: L,
          bodiesDeleted: [w]
        };
      } else
        console.warn(`Attempt to delete missing body ${m.id} from annotation ${m.annotation}`);
    } else
      console.warn(`Attempt to delete body from missing annotation ${m.annotation}`);
  }, c = (m, A = k.LOCAL) => {
    const w = l(m);
    w && s(A, { updated: [w] });
  }, b = (m, A = k.LOCAL) => {
    const w = m.map((L) => l(L)).filter(Boolean);
    w.length > 0 && s(A, { updated: w });
  }, S = (m) => {
    const A = t.get(m);
    return A ? { ...A } : void 0;
  }, E = (m) => {
    const A = e.get(m);
    if (A) {
      const w = S(A).bodies.find((L) => L.id === m);
      if (w)
        return w;
      console.error(`Store integrity error: body ${m} in index, but not in annotation`);
    } else
      console.warn(`Attempt to retrieve missing body: ${m}`);
  }, C = (m, A) => {
    if (m.annotation !== A.annotation)
      throw "Annotation integrity violation: annotation ID must be the same when updating bodies";
    const w = t.get(m.annotation);
    if (w) {
      const L = w.bodies.find((R) => R.id === m.id), M = {
        ...w,
        bodies: w.bodies.map((R) => R.id === L.id ? A : R)
      };
      return t.set(w.id, M), L.id !== A.id && (e.delete(L.id), e.set(A.id, M.id)), {
        oldValue: w,
        newValue: M,
        bodiesUpdated: [{ oldBody: L, newBody: A }]
      };
    } else
      console.warn(`Attempt to add body to missing annotation ${m.annotation}`);
  }, O = (m, A, w = k.LOCAL) => {
    const L = C(m, A);
    L && s(w, { updated: [L] });
  }, B = (m, A = k.LOCAL) => {
    const w = m.map((L) => C({ id: L.id, annotation: L.annotation }, L)).filter(Boolean);
    s(A, { updated: w });
  }, T = (m) => {
    const A = t.get(m.annotation);
    if (A) {
      const w = {
        ...A,
        target: {
          ...A.target,
          ...m
        }
      };
      return t.set(A.id, w), {
        oldValue: A,
        newValue: w,
        targetUpdated: {
          oldTarget: A.target,
          newTarget: m
        }
      };
    } else
      console.warn(`Attempt to update target on missing annotation: ${m.annotation}`);
  };
  return {
    addAnnotation: a,
    addBody: h,
    all: u,
    bulkAddAnnotation: v,
    bulkDeleteAnnotation: x,
    bulkDeleteBodies: b,
    bulkUpdateAnnotation: f,
    bulkUpdateBodies: B,
    bulkUpdateTargets: (m, A = k.LOCAL) => {
      const w = m.map((L) => T(L)).filter(Boolean);
      w.length > 0 && s(A, { updated: w });
    },
    clear: g,
    deleteAnnotation: y,
    deleteBody: c,
    getAnnotation: S,
    getBody: E,
    observe: o,
    unobserve: i,
    updateAnnotation: d,
    updateBody: O,
    updateTarget: (m, A = k.LOCAL) => {
      const w = T(m);
      w && s(A, { updated: [w] });
    }
  };
};
let Tn = () => ({
  emit(t, ...e) {
    for (let n = this.events[t] || [], o = 0, i = n.length; o < i; o++)
      n[o](...e);
  },
  events: {},
  on(t, e) {
    var n;
    return ((n = this.events)[t] || (n[t] = [])).push(e), () => {
      var o;
      this.events[t] = (o = this.events[t]) == null ? void 0 : o.filter((i) => e !== i);
    };
  }
});
const On = 250, Bn = (t, e) => {
  const n = Tn(), o = [];
  let i = -1, s = !1, a = 0;
  const r = (p) => {
    if (!s) {
      const { changes: y } = p, x = performance.now();
      if (x - a > On)
        o.splice(i + 1), o.push(y), i = o.length - 1;
      else {
        const l = o.length - 1;
        o[l] = Sn(o[l], y);
      }
      a = x;
    }
    s = !1;
  };
  t.observe(r, { origin: k.LOCAL });
  const d = (p) => p && p.length > 0 && t.bulkDeleteAnnotation(p), f = (p) => p && p.length > 0 && t.bulkAddAnnotation(p, !1), h = (p) => p && p.length > 0 && t.bulkUpdateAnnotation(p.map(({ oldValue: y }) => y)), u = (p) => p && p.length > 0 && t.bulkUpdateAnnotation(p.map(({ newValue: y }) => y)), g = (p) => p && p.length > 0 && t.bulkAddAnnotation(p, !1), v = (p) => p && p.length > 0 && t.bulkDeleteAnnotation(p);
  return {
    canRedo: () => o.length - 1 > i,
    canUndo: () => i > -1,
    destroy: () => t.unobserve(r),
    getHistory: () => ({ changes: [...o], pointer: i }),
    on: (p, y) => n.on(p, y),
    redo: () => {
      if (o.length - 1 > i) {
        s = !0;
        const { created: p, updated: y, deleted: x } = o[i + 1];
        f(p), u(y), v(x), n.emit("redo", o[i + 1]), i += 1;
      }
    },
    undo: () => {
      if (i > -1) {
        s = !0;
        const { created: p, updated: y, deleted: x } = o[i];
        d(p), h(y), g(x), n.emit("undo", o[i]), i -= 1;
      }
    }
  };
}, Mn = () => {
  const { subscribe: t, set: e } = Kt([]);
  return {
    subscribe: t,
    set: e
  };
}, Rn = (t, e, n, o) => {
  const { hover: i, selection: s, store: a, viewport: r } = t, d = /* @__PURE__ */ new Map();
  let f = [], h;
  const u = (y, x) => {
    d.has(y) ? d.get(y).push(x) : d.set(y, [x]);
  }, g = (y, x) => {
    const l = d.get(y);
    if (l) {
      const c = l.indexOf(x);
      c !== -1 && l.splice(c, 1);
    }
  }, v = (y, x, l) => {
    d.has(y) && setTimeout(() => {
      d.get(y).forEach((c) => {
        if (n) {
          const b = Array.isArray(x) ? x.map((E) => n.serialize(E)) : n.serialize(x), S = l ? l instanceof PointerEvent ? l : n.serialize(l) : void 0;
          c(b, S);
        } else
          c(x, l);
      });
    }, 1);
  };
  s.subscribe(({ selected: y }) => {
    if (!(f.length === 0 && y.length === 0)) {
      if (f.length === 0 && y.length > 0)
        f = y.map(({ id: x }) => a.getAnnotation(x));
      else if (f.length > 0 && y.length === 0)
        f.forEach((x) => {
          const l = a.getAnnotation(x.id);
          l && !G(l, x) && v("updateAnnotation", l, x);
        }), f = [];
      else {
        const x = new Set(f.map((c) => c.id)), l = new Set(y.map(({ id: c }) => c));
        f.filter((c) => !l.has(c.id)).forEach((c) => {
          const b = a.getAnnotation(c.id);
          b && !G(b, c) && v("updateAnnotation", b, c);
        }), f = [
          // Remove annotations that were deselected
          ...f.filter((c) => l.has(c.id)),
          // Add editable annotations that were selected
          ...y.filter(({ id: c }) => !x.has(c)).map(({ id: c }) => a.getAnnotation(c))
        ];
      }
      v("selectionChanged", f);
    }
  }), i.subscribe((y) => {
    !h && y ? v("mouseEnterAnnotation", a.getAnnotation(y)) : h && !y ? v("mouseLeaveAnnotation", a.getAnnotation(h)) : h && y && (v("mouseLeaveAnnotation", a.getAnnotation(h)), v("mouseEnterAnnotation", a.getAnnotation(y))), h = y;
  }), r == null || r.subscribe((y) => v("viewportIntersect", y.map((x) => a.getAnnotation(x)))), a.observe((y) => {
    const { created: x, deleted: l } = y.changes;
    (x || []).forEach((c) => v("createAnnotation", c)), (l || []).forEach((c) => v("deleteAnnotation", c)), (y.changes.updated || []).filter((c) => [
      ...c.bodiesCreated || [],
      ...c.bodiesDeleted || [],
      ...c.bodiesUpdated || []
    ].length > 0).forEach(({ oldValue: c, newValue: b }) => {
      const S = f.find((E) => E.id === c.id) || c;
      f = f.map((E) => E.id === c.id ? b : E), v("updateAnnotation", b, S);
    });
  }, { origin: k.LOCAL }), a.observe((y) => {
    if (f) {
      const x = new Set(f.map((c) => c.id)), l = (y.changes.updated || []).filter(({ newValue: c }) => x.has(c.id)).map(({ newValue: c }) => c);
      l.length > 0 && (f = f.map((c) => l.find((S) => S.id === c.id) || c));
    }
  }, { origin: k.REMOTE });
  const p = (y) => (x) => {
    const { updated: l } = x;
    y ? (l || []).forEach((c) => v("updateAnnotation", c.oldValue, c.newValue)) : (l || []).forEach((c) => v("updateAnnotation", c.newValue, c.oldValue));
  };
  return e.on("undo", p(!0)), e.on("redo", p(!1)), { on: u, off: g, emit: v };
}, kn = (t) => (e) => e.reduce((n, o) => {
  const { parsed: i, error: s } = t.parse(o);
  return s ? {
    parsed: n.parsed,
    failed: [...n.failed, o]
  } : i ? {
    parsed: [...n.parsed, i],
    failed: n.failed
  } : {
    ...n
  };
}, { parsed: [], failed: [] }), In = (t, e, n) => {
  const { store: o, selection: i } = t, s = (l) => {
    if (n) {
      const { parsed: c, error: b } = n.parse(l);
      c ? o.addAnnotation(c, k.REMOTE) : console.error(b);
    } else
      o.addAnnotation(Bt(l), k.REMOTE);
  }, a = () => i.clear(), r = () => o.clear(), d = (l) => {
    const c = o.getAnnotation(l);
    return n && c ? n.serialize(c) : c;
  }, f = () => n ? o.all().map(n.serialize) : o.all(), h = () => {
    var l;
    const c = (((l = i.selected) == null ? void 0 : l.map((b) => b.id)) || []).map((b) => o.getAnnotation(b)).filter(Boolean);
    return n ? c.map(n.serialize) : c;
  }, u = (l, c = !0) => fetch(l).then((b) => b.json()).then((b) => (v(b, c), b)), g = (l) => {
    if (typeof l == "string") {
      const c = o.getAnnotation(l);
      if (o.deleteAnnotation(l), c)
        return n ? n.serialize(c) : c;
    } else {
      const c = n ? n.parse(l).parsed : l;
      if (c)
        return o.deleteAnnotation(c), l;
    }
  }, v = (l, c = !0) => {
    if (n) {
      const b = n.parseAll || kn(n), { parsed: S, failed: E } = b(l);
      E.length > 0 && console.warn(`Discarded ${E.length} invalid annotations`, E), o.bulkAddAnnotation(S, c, k.REMOTE);
    } else
      o.bulkAddAnnotation(l.map(Bt), c, k.REMOTE);
  }, p = (l, c) => {
    l ? i.setSelected(l, c) : i.clear();
  }, y = (l) => {
    i.clear(), i.setUserSelectAction(l);
  }, x = (l) => {
    if (n) {
      const c = n.parse(l).parsed, b = n.serialize(o.getAnnotation(c.id));
      return o.updateAnnotation(c), b;
    } else {
      const c = o.getAnnotation(l.id);
      return o.updateAnnotation(Bt(l)), c;
    }
  };
  return {
    addAnnotation: s,
    cancelSelected: a,
    canRedo: e.canRedo,
    canUndo: e.canUndo,
    clearAnnotations: r,
    getAnnotationById: d,
    getAnnotations: f,
    getHistory: e.getHistory,
    getSelected: h,
    loadAnnotations: u,
    redo: e.redo,
    removeAnnotation: g,
    setAnnotations: v,
    setSelected: p,
    setUserSelectAction: y,
    undo: e.undo,
    updateAnnotation: x
  };
}, _n = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
let Nn = (t) => crypto.getRandomValues(new Uint8Array(t)), Un = (t, e, n) => {
  let o = (2 << Math.log2(t.length - 1)) - 1, i = -~(1.6 * o * e / t.length);
  return (s = e) => {
    let a = "";
    for (; ; ) {
      let r = n(i), d = i | 0;
      for (; d--; )
        if (a += t[r[d] & o] || "", a.length >= s) return a;
    }
  };
}, Vn = (t, e = 21) => Un(t, e | 0, Nn), Yn = (t = 21) => {
  let e = "", n = crypto.getRandomValues(new Uint8Array(t |= 0));
  for (; t--; )
    e += _n[n[t] & 63];
  return e;
};
const Dn = () => ({ isGuest: !0, id: Vn("1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_", 20)() }), Kn = (t) => {
  const e = JSON.stringify(t);
  let n = 0;
  for (let o = 0, i = e.length; o < i; o++) {
    let s = e.charCodeAt(o);
    n = (n << 5) - n + s, n |= 0;
  }
  return `${n}`;
}, pe = (t) => t ? typeof t == "object" ? { ...t } : t : void 0, Xn = (t, e) => (Array.isArray(t) ? t : [t]).map((n) => {
  const { id: o, type: i, purpose: s, value: a, created: r, modified: d, creator: f, ...h } = n;
  return {
    id: o || `temp-${Kn(n)}`,
    annotation: e,
    type: i,
    purpose: s,
    value: a,
    creator: pe(f),
    created: r ? new Date(r) : void 0,
    updated: d ? new Date(d) : void 0,
    ...h
  };
}), Pn = (t) => t.map((e) => {
  var n;
  const { annotation: o, created: i, updated: s, ...a } = e, r = {
    ...a,
    created: i == null ? void 0 : i.toISOString(),
    modified: s == null ? void 0 : s.toISOString()
  };
  return (n = r.id) != null && n.startsWith("temp-") && delete r.id, r;
});
Yn();
const xo = (t, e) => ({
  parse: (n) => jn(n),
  serialize: (n) => zn(n, t, e)
}), $n = (t) => t.quote !== void 0 && t.start !== void 0 && t.end !== void 0, Hn = (t) => {
  const {
    id: e,
    creator: n,
    created: o,
    modified: i,
    target: s
  } = t, a = Array.isArray(s) ? s : [s];
  if (a.length === 0)
    return { error: Error(`No targets found for annotation: ${t.id}`) };
  const r = {
    creator: pe(n),
    created: o ? new Date(o) : void 0,
    updated: i ? new Date(i) : void 0,
    annotation: e,
    selector: [],
    // @ts-expect-error: `styleClass` is not part of the core `TextAnnotationTarget` type
    styleClass: "styleClass" in a[0] ? a[0].styleClass : void 0
  };
  for (const d of a) {
    const h = (Array.isArray(d.selector) ? d.selector : [d.selector]).reduce((u, g) => {
      switch (g.type) {
        case "TextQuoteSelector":
          u.quote = g.exact;
          break;
        case "TextPositionSelector":
          u.start = g.start, u.end = g.end;
          break;
      }
      return u;
    }, {});
    if ($n(h))
      r.selector.push(
        {
          ...h,
          id: d.id,
          // @ts-expect-error: `scope` is not part of the core `TextSelector` type
          scope: d.scope
        }
      );
    else {
      const u = [
        h.start ? void 0 : "TextPositionSelector",
        h.quote ? void 0 : "TextQuoteSelector"
      ].filter(Boolean);
      return { error: Error(`Missing selector types: ${u.join(" and ")} for annotation: ${t.id}`) };
    }
  }
  return { parsed: r };
}, jn = (t) => {
  const e = t.id || fe(), {
    creator: n,
    created: o,
    modified: i,
    body: s,
    ...a
  } = t, r = Xn(s, e), d = Hn(t);
  return "error" in d ? { error: d.error } : {
    parsed: {
      ...a,
      id: e,
      bodies: r,
      target: d.parsed
    }
  };
}, zn = (t, e, n) => {
  const { bodies: o, target: i, ...s } = t, {
    selector: a,
    creator: r,
    created: d,
    updated: f,
    ...h
  } = i, u = a.map((g) => {
    const { id: v, quote: p, start: y, end: x, range: l } = g, { prefix: c, suffix: b } = Re(l, n), S = [{
      type: "TextQuoteSelector",
      exact: p,
      prefix: c,
      suffix: b
    }, {
      type: "TextPositionSelector",
      start: y,
      end: x
    }];
    return {
      ...h,
      id: v,
      // @ts-expect-error: `scope` is not part of the core `TextSelector` type
      scope: "scope" in g ? g.scope : void 0,
      source: e,
      selector: S
    };
  });
  return {
    ...s,
    "@context": "http://www.w3.org/ns/anno.jsonld",
    id: t.id,
    type: "Annotation",
    body: Pn(t.bodies),
    creator: r,
    created: d == null ? void 0 : d.toISOString(),
    modified: f == null ? void 0 : f.toISOString(),
    target: u
  };
};
function me(t, e, n = 0, o = t.length - 1, i = Fn) {
  for (; o > n; ) {
    if (o - n > 600) {
      const d = o - n + 1, f = e - n + 1, h = Math.log(d), u = 0.5 * Math.exp(2 * h / 3), g = 0.5 * Math.sqrt(h * u * (d - u) / d) * (f - d / 2 < 0 ? -1 : 1), v = Math.max(n, Math.floor(e - f * u / d + g)), p = Math.min(o, Math.floor(e + (d - f) * u / d + g));
      me(t, e, v, p, i);
    }
    const s = t[e];
    let a = n, r = o;
    for (nt(t, n, e), i(t[o], s) > 0 && nt(t, n, o); a < r; ) {
      for (nt(t, a, r), a++, r--; i(t[a], s) < 0; ) a++;
      for (; i(t[r], s) > 0; ) r--;
    }
    i(t[n], s) === 0 ? nt(t, n, r) : (r++, nt(t, r, o)), r <= e && (n = r + 1), e <= r && (o = r - 1);
  }
}
function nt(t, e, n) {
  const o = t[e];
  t[e] = t[n], t[n] = o;
}
function Fn(t, e) {
  return t < e ? -1 : t > e ? 1 : 0;
}
class Wn {
  constructor(e = 9) {
    this._maxEntries = Math.max(4, e), this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4)), this.clear();
  }
  all() {
    return this._all(this.data, []);
  }
  search(e) {
    let n = this.data;
    const o = [];
    if (!mt(e, n)) return o;
    const i = this.toBBox, s = [];
    for (; n; ) {
      for (let a = 0; a < n.children.length; a++) {
        const r = n.children[a], d = n.leaf ? i(r) : r;
        mt(e, d) && (n.leaf ? o.push(r) : kt(e, d) ? this._all(r, o) : s.push(r));
      }
      n = s.pop();
    }
    return o;
  }
  collides(e) {
    let n = this.data;
    if (!mt(e, n)) return !1;
    const o = [];
    for (; n; ) {
      for (let i = 0; i < n.children.length; i++) {
        const s = n.children[i], a = n.leaf ? this.toBBox(s) : s;
        if (mt(e, a)) {
          if (n.leaf || kt(e, a)) return !0;
          o.push(s);
        }
      }
      n = o.pop();
    }
    return !1;
  }
  load(e) {
    if (!(e && e.length)) return this;
    if (e.length < this._minEntries) {
      for (let o = 0; o < e.length; o++)
        this.insert(e[o]);
      return this;
    }
    let n = this._build(e.slice(), 0, e.length - 1, 0);
    if (!this.data.children.length)
      this.data = n;
    else if (this.data.height === n.height)
      this._splitRoot(this.data, n);
    else {
      if (this.data.height < n.height) {
        const o = this.data;
        this.data = n, n = o;
      }
      this._insert(n, this.data.height - n.height - 1, !0);
    }
    return this;
  }
  insert(e) {
    return e && this._insert(e, this.data.height - 1), this;
  }
  clear() {
    return this.data = Z([]), this;
  }
  remove(e, n) {
    if (!e) return this;
    let o = this.data;
    const i = this.toBBox(e), s = [], a = [];
    let r, d, f;
    for (; o || s.length; ) {
      if (o || (o = s.pop(), d = s[s.length - 1], r = a.pop(), f = !0), o.leaf) {
        const h = qn(e, o.children, n);
        if (h !== -1)
          return o.children.splice(h, 1), s.push(o), this._condense(s), this;
      }
      !f && !o.leaf && kt(o, i) ? (s.push(o), a.push(r), r = 0, d = o, o = o.children[0]) : d ? (r++, o = d.children[r], f = !1) : o = null;
    }
    return this;
  }
  toBBox(e) {
    return e;
  }
  compareMinX(e, n) {
    return e.minX - n.minX;
  }
  compareMinY(e, n) {
    return e.minY - n.minY;
  }
  toJSON() {
    return this.data;
  }
  fromJSON(e) {
    return this.data = e, this;
  }
  _all(e, n) {
    const o = [];
    for (; e; )
      e.leaf ? n.push(...e.children) : o.push(...e.children), e = o.pop();
    return n;
  }
  _build(e, n, o, i) {
    const s = o - n + 1;
    let a = this._maxEntries, r;
    if (s <= a)
      return r = Z(e.slice(n, o + 1)), J(r, this.toBBox), r;
    i || (i = Math.ceil(Math.log(s) / Math.log(a)), a = Math.ceil(s / Math.pow(a, i - 1))), r = Z([]), r.leaf = !1, r.height = i;
    const d = Math.ceil(s / a), f = d * Math.ceil(Math.sqrt(a));
    ee(e, n, o, f, this.compareMinX);
    for (let h = n; h <= o; h += f) {
      const u = Math.min(h + f - 1, o);
      ee(e, h, u, d, this.compareMinY);
      for (let g = h; g <= u; g += d) {
        const v = Math.min(g + d - 1, u);
        r.children.push(this._build(e, g, v, i - 1));
      }
    }
    return J(r, this.toBBox), r;
  }
  _chooseSubtree(e, n, o, i) {
    for (; i.push(n), !(n.leaf || i.length - 1 === o); ) {
      let s = 1 / 0, a = 1 / 0, r;
      for (let d = 0; d < n.children.length; d++) {
        const f = n.children[d], h = Rt(f), u = Jn(e, f) - h;
        u < a ? (a = u, s = h < s ? h : s, r = f) : u === a && h < s && (s = h, r = f);
      }
      n = r || n.children[0];
    }
    return n;
  }
  _insert(e, n, o) {
    const i = o ? e : this.toBBox(e), s = [], a = this._chooseSubtree(i, this.data, n, s);
    for (a.children.push(e), rt(a, i); n >= 0 && s[n].children.length > this._maxEntries; )
      this._split(s, n), n--;
    this._adjustParentBBoxes(i, s, n);
  }
  // split overflowed node into two
  _split(e, n) {
    const o = e[n], i = o.children.length, s = this._minEntries;
    this._chooseSplitAxis(o, s, i);
    const a = this._chooseSplitIndex(o, s, i), r = Z(o.children.splice(a, o.children.length - a));
    r.height = o.height, r.leaf = o.leaf, J(o, this.toBBox), J(r, this.toBBox), n ? e[n - 1].children.push(r) : this._splitRoot(o, r);
  }
  _splitRoot(e, n) {
    this.data = Z([e, n]), this.data.height = e.height + 1, this.data.leaf = !1, J(this.data, this.toBBox);
  }
  _chooseSplitIndex(e, n, o) {
    let i, s = 1 / 0, a = 1 / 0;
    for (let r = n; r <= o - n; r++) {
      const d = st(e, 0, r, this.toBBox), f = st(e, r, o, this.toBBox), h = Zn(d, f), u = Rt(d) + Rt(f);
      h < s ? (s = h, i = r, a = u < a ? u : a) : h === s && u < a && (a = u, i = r);
    }
    return i || o - n;
  }
  // sorts node children by the best axis for split
  _chooseSplitAxis(e, n, o) {
    const i = e.leaf ? this.compareMinX : Gn, s = e.leaf ? this.compareMinY : Qn, a = this._allDistMargin(e, n, o, i), r = this._allDistMargin(e, n, o, s);
    a < r && e.children.sort(i);
  }
  // total margin of all possible split distributions where each node is at least m full
  _allDistMargin(e, n, o, i) {
    e.children.sort(i);
    const s = this.toBBox, a = st(e, 0, n, s), r = st(e, o - n, o, s);
    let d = pt(a) + pt(r);
    for (let f = n; f < o - n; f++) {
      const h = e.children[f];
      rt(a, e.leaf ? s(h) : h), d += pt(a);
    }
    for (let f = o - n - 1; f >= n; f--) {
      const h = e.children[f];
      rt(r, e.leaf ? s(h) : h), d += pt(r);
    }
    return d;
  }
  _adjustParentBBoxes(e, n, o) {
    for (let i = o; i >= 0; i--)
      rt(n[i], e);
  }
  _condense(e) {
    for (let n = e.length - 1, o; n >= 0; n--)
      e[n].children.length === 0 ? n > 0 ? (o = e[n - 1].children, o.splice(o.indexOf(e[n]), 1)) : this.clear() : J(e[n], this.toBBox);
  }
}
function qn(t, e, n) {
  if (!n) return e.indexOf(t);
  for (let o = 0; o < e.length; o++)
    if (n(t, e[o])) return o;
  return -1;
}
function J(t, e) {
  st(t, 0, t.children.length, e, t);
}
function st(t, e, n, o, i) {
  i || (i = Z(null)), i.minX = 1 / 0, i.minY = 1 / 0, i.maxX = -1 / 0, i.maxY = -1 / 0;
  for (let s = e; s < n; s++) {
    const a = t.children[s];
    rt(i, t.leaf ? o(a) : a);
  }
  return i;
}
function rt(t, e) {
  return t.minX = Math.min(t.minX, e.minX), t.minY = Math.min(t.minY, e.minY), t.maxX = Math.max(t.maxX, e.maxX), t.maxY = Math.max(t.maxY, e.maxY), t;
}
function Gn(t, e) {
  return t.minX - e.minX;
}
function Qn(t, e) {
  return t.minY - e.minY;
}
function Rt(t) {
  return (t.maxX - t.minX) * (t.maxY - t.minY);
}
function pt(t) {
  return t.maxX - t.minX + (t.maxY - t.minY);
}
function Jn(t, e) {
  return (Math.max(e.maxX, t.maxX) - Math.min(e.minX, t.minX)) * (Math.max(e.maxY, t.maxY) - Math.min(e.minY, t.minY));
}
function Zn(t, e) {
  const n = Math.max(t.minX, e.minX), o = Math.max(t.minY, e.minY), i = Math.min(t.maxX, e.maxX), s = Math.min(t.maxY, e.maxY);
  return Math.max(0, i - n) * Math.max(0, s - o);
}
function kt(t, e) {
  return t.minX <= e.minX && t.minY <= e.minY && e.maxX <= t.maxX && e.maxY <= t.maxY;
}
function mt(t, e) {
  return e.minX <= t.maxX && e.minY <= t.maxY && e.maxX >= t.minX && e.maxY >= t.minY;
}
function Z(t) {
  return {
    children: t,
    height: 1,
    leaf: !0,
    minX: 1 / 0,
    minY: 1 / 0,
    maxX: -1 / 0,
    maxY: -1 / 0
  };
}
function ee(t, e, n, o, i) {
  const s = [e, n];
  for (; s.length; ) {
    if (n = s.pop(), e = s.pop(), n - e <= o) continue;
    const a = e + Math.ceil((n - e) / o / 2) * o;
    me(t, a, e, n, i), s.push(e, a, a, n);
  }
}
const to = (t, e) => {
  const n = new Wn(), o = /* @__PURE__ */ new Map(), i = (l, c) => {
    const b = l.selector.flatMap((E) => {
      const C = F([E]) ? E.range : ae(E, e).range;
      return Array.from(C.getClientRects());
    }), S = Ue(b).map(({ left: E, top: C, right: O, bottom: B }) => new DOMRect(E - c.left, C - c.top, O - E, B - C));
    return S.map((E) => {
      const { x: C, y: O, width: B, height: T } = E;
      return {
        minX: C,
        minY: O,
        maxX: C + B,
        maxY: O + T,
        annotation: {
          id: l.annotation,
          rects: S
        }
      };
    });
  }, s = () => [...o.values()], a = () => {
    n.clear(), o.clear();
  }, r = (l) => {
    const c = i(l, e.getBoundingClientRect());
    c.length !== 0 && (c.forEach((b) => n.insert(b)), o.set(l.annotation, c));
  }, d = (l) => {
    const c = o.get(l.annotation);
    c && (c.forEach((b) => n.remove(b)), o.delete(l.annotation));
  }, f = (l) => {
    d(l), r(l);
  }, h = (l, c = !0) => {
    c && a();
    const b = e.getBoundingClientRect(), S = l.map((C) => ({ target: C, rects: i(C, b) }));
    S.forEach(({ target: C, rects: O }) => {
      O.length > 0 && o.set(C.annotation, O);
    });
    const E = S.flatMap(({ rects: C }) => C);
    n.load(E);
  }, u = (l, c, b = !1) => {
    const S = n.search({
      minX: l,
      minY: c,
      maxX: l,
      maxY: c
    }), E = (C) => C.annotation.rects.reduce((O, B) => O + B.width * B.height, 0);
    return S.length > 0 ? (S.sort((C, O) => E(C) - E(O)), b ? S.map((C) => C.annotation.id) : [S[0].annotation.id]) : [];
  }, g = (l) => {
    const c = v(l);
    if (c.length === 0)
      return;
    let b = c[0].left, S = c[0].top, E = c[0].right, C = c[0].bottom;
    for (let O = 1; O < c.length; O++) {
      const B = c[O];
      b = Math.min(b, B.left), S = Math.min(S, B.top), E = Math.max(E, B.right), C = Math.max(C, B.bottom);
    }
    return new DOMRect(b, S, E - b, C - S);
  }, v = (l) => {
    const c = o.get(l);
    return c ? c[0].annotation.rects : [];
  };
  return {
    all: s,
    clear: a,
    getAt: u,
    getAnnotationBounds: g,
    getAnnotationRects: v,
    getIntersecting: (l, c, b, S) => {
      const E = n.search({ minX: l, minY: c, maxX: b, maxY: S }), C = new Set(E.map((O) => O.annotation.id));
      return Array.from(C).map((O) => ({
        annotation: t.getAnnotation(O),
        rects: v(O)
      })).filter((O) => !!O.annotation);
    },
    insert: r,
    recalculate: () => h(t.all().map((l) => l.target), !0),
    remove: d,
    set: h,
    size: () => n.all().length,
    update: f
  };
}, eo = (t, e) => {
  const n = Ln(), o = to(n, t), i = gn(n);
  i.setUserSelectAction(e);
  const s = fn(n), a = Mn(), r = (l, c = k.LOCAL) => {
    const b = vt(l, t), S = F(b.target.selector);
    return S && n.addAnnotation(b, c), S;
  }, d = (l, c = !0, b = k.LOCAL) => {
    const S = l.map((C) => vt(C, t)), E = S.filter((C) => !F(C.target.selector));
    return n.bulkAddAnnotation(S, c, b), E;
  }, f = (l, c = k.LOCAL) => {
    const b = l.map((E) => vt(E, t)), S = b.filter((E) => !F(E.target.selector));
    return b.forEach((E) => {
      n.getAnnotation(E.id) ? n.updateAnnotation(E, c) : n.addAnnotation(E, c);
    }), S;
  }, h = (l, c = k.LOCAL) => {
    const b = wt(l, t);
    n.updateTarget(b, c);
  }, u = (l, c = k.LOCAL) => {
    const b = l.map((S) => wt(S, t));
    n.bulkUpdateTargets(b, c);
  };
  function g(l, c, b, S) {
    const E = b || !!S, C = o.getAt(l, c, E).map((B) => n.getAnnotation(B)), O = S ? C.filter(S) : C;
    if (O.length !== 0)
      return b ? O : O[0];
  }
  const v = (l) => {
    if (o.getAnnotationRects(l).length !== 0)
      return o.getAnnotationBounds(l);
  }, p = (l, c, b, S) => o.getIntersecting(l, c, b, S), y = (l) => o.getAnnotationRects(l), x = () => o.recalculate();
  return n.observe(({ changes: l }) => {
    const c = (l.deleted || []).filter((E) => F(E.target.selector)), b = (l.created || []).filter((E) => F(E.target.selector)), S = (l.updated || []).filter((E) => F(E.newValue.target.selector));
    (c == null ? void 0 : c.length) > 0 && c.forEach((E) => o.remove(E.target)), b.length > 0 && o.set(b.map((E) => E.target), !1), (S == null ? void 0 : S.length) > 0 && S.forEach(({ newValue: E }) => o.update(E.target));
  }), {
    store: {
      ...n,
      addAnnotation: r,
      bulkAddAnnotation: d,
      bulkUpdateTargets: u,
      bulkUpsertAnnotations: f,
      getAnnotationBounds: v,
      getAnnotationRects: y,
      getIntersecting: p,
      getAt: g,
      recalculatePositions: x,
      updateTarget: h
    },
    selection: i,
    hover: s,
    viewport: a
  };
}, no = () => {
  const t = document.createElement("canvas");
  t.width = 2 * window.innerWidth, t.height = 2 * window.innerHeight, t.className = "r6o-presence-layer";
  const e = t.getContext("2d");
  return e.scale(2, 2), e.translate(0.5, 0.5), t;
}, oo = (t, e = {}) => {
  const n = no(), o = n.getContext("2d");
  document.body.appendChild(n);
  const i = /* @__PURE__ */ new Map(), s = (h) => Array.from(i.entries()).filter(([u, g]) => g.presenceKey === h.presenceKey).map(([u, g]) => u);
  return t.on("selectionChange", (h, u) => {
    s(h).forEach((v) => i.delete(v)), u && u.forEach((v) => i.set(v, h));
  }), {
    clear: () => {
      const { width: h, height: u } = n;
      o.clearRect(-0.5, -0.5, h + 1, u + 1);
    },
    destroy: () => {
      n.remove();
    },
    paint: (h, u, g) => {
      e.font && (o.font = e.font);
      const v = i.get(h.annotation.id);
      if (v) {
        const { height: p } = h.rects[0], y = h.rects[0].x + u.left, x = h.rects[0].y + u.top;
        o.fillStyle = v.appearance.color, o.fillRect(y - 2, x - 2.5, 2, p + 5);
        const l = o.measureText(v.appearance.label), c = l.width + 6, b = l.actualBoundingBoxAscent + l.actualBoundingBoxDescent + 8, S = l.fontBoundingBoxAscent ? 8 : 6.5;
        return o.fillRect(y - 2, x - 2.5 - b, c, b), o.fillStyle = "#fff", o.fillText(v.appearance.label, y + 1, x - S), {
          fill: v.appearance.color,
          fillOpacity: g ? 0.45 : 0.18
        };
      }
    },
    reset: () => {
      n.width = 2 * window.innerWidth, n.height = 2 * window.innerHeight;
      const h = n.getContext("2d");
      h.scale(2, 2), h.translate(0.5, 0.5);
    }
  };
}, It = typeof navigator < "u" ? navigator.userAgent.toLowerCase().indexOf("firefox") > 0 : !1;
function _t(t, e, n, o) {
  t.addEventListener ? t.addEventListener(e, n, o) : t.attachEvent && t.attachEvent("on".concat(e), n);
}
function ot(t, e, n, o) {
  t.removeEventListener ? t.removeEventListener(e, n, o) : t.detachEvent && t.detachEvent("on".concat(e), n);
}
function ye(t, e) {
  const n = e.slice(0, e.length - 1);
  for (let o = 0; o < n.length; o++) n[o] = t[n[o].toLowerCase()];
  return n;
}
function be(t) {
  typeof t != "string" && (t = ""), t = t.replace(/\s/g, "");
  const e = t.split(",");
  let n = e.lastIndexOf("");
  for (; n >= 0; )
    e[n - 1] += ",", e.splice(n, 1), n = e.lastIndexOf("");
  return e;
}
function io(t, e) {
  const n = t.length >= e.length ? t : e, o = t.length >= e.length ? e : t;
  let i = !0;
  for (let s = 0; s < n.length; s++)
    o.indexOf(n[s]) === -1 && (i = !1);
  return i;
}
const lt = {
  backspace: 8,
  "": 8,
  tab: 9,
  clear: 12,
  enter: 13,
  "": 13,
  return: 13,
  esc: 27,
  escape: 27,
  space: 32,
  left: 37,
  up: 38,
  right: 39,
  down: 40,
  del: 46,
  delete: 46,
  ins: 45,
  insert: 45,
  home: 36,
  end: 35,
  pageup: 33,
  pagedown: 34,
  capslock: 20,
  num_0: 96,
  num_1: 97,
  num_2: 98,
  num_3: 99,
  num_4: 100,
  num_5: 101,
  num_6: 102,
  num_7: 103,
  num_8: 104,
  num_9: 105,
  num_multiply: 106,
  num_add: 107,
  num_enter: 108,
  num_subtract: 109,
  num_decimal: 110,
  num_divide: 111,
  "": 20,
  ",": 188,
  ".": 190,
  "/": 191,
  "`": 192,
  "-": It ? 173 : 189,
  "=": It ? 61 : 187,
  ";": It ? 59 : 186,
  "'": 222,
  "[": 219,
  "]": 221,
  "\\": 220
}, H = {
  // shiftKey
  "": 16,
  shift: 16,
  // altKey
  "": 18,
  alt: 18,
  option: 18,
  // ctrlKey
  "": 17,
  ctrl: 17,
  control: 17,
  // metaKey
  "": 91,
  cmd: 91,
  command: 91
}, bt = {
  16: "shiftKey",
  18: "altKey",
  17: "ctrlKey",
  91: "metaKey",
  shiftKey: 16,
  ctrlKey: 17,
  altKey: 18,
  metaKey: 91
}, K = {
  16: !1,
  18: !1,
  17: !1,
  91: !1
}, _ = {};
for (let t = 1; t < 20; t++)
  lt["f".concat(t)] = 111 + t;
let I = [], ct = null, we = "all";
const z = /* @__PURE__ */ new Map(), ut = (t) => lt[t.toLowerCase()] || H[t.toLowerCase()] || t.toUpperCase().charCodeAt(0), so = (t) => Object.keys(lt).find((e) => lt[e] === t), ro = (t) => Object.keys(H).find((e) => H[e] === t);
function Ae(t) {
  we = t || "all";
}
function dt() {
  return we || "all";
}
function ao() {
  return I.slice(0);
}
function co() {
  return I.map((t) => so(t) || ro(t) || String.fromCharCode(t));
}
function lo() {
  const t = [];
  return Object.keys(_).forEach((e) => {
    _[e].forEach((n) => {
      let {
        key: o,
        scope: i,
        mods: s,
        shortcut: a
      } = n;
      t.push({
        scope: i,
        shortcut: a,
        mods: s,
        keys: o.split("+").map((r) => ut(r))
      });
    });
  }), t;
}
function uo(t) {
  const e = t.target || t.srcElement, {
    tagName: n
  } = e;
  let o = !0;
  const i = n === "INPUT" && !["checkbox", "radio", "range", "button", "file", "reset", "submit", "color"].includes(e.type);
  return (e.isContentEditable || (i || n === "TEXTAREA" || n === "SELECT") && !e.readOnly) && (o = !1), o;
}
function fo(t) {
  return typeof t == "string" && (t = ut(t)), I.indexOf(t) !== -1;
}
function ho(t, e) {
  let n, o;
  t || (t = dt());
  for (const i in _)
    if (Object.prototype.hasOwnProperty.call(_, i))
      for (n = _[i], o = 0; o < n.length; )
        n[o].scope === t ? n.splice(o, 1).forEach((a) => {
          let {
            element: r
          } = a;
          return Xt(r);
        }) : o++;
  dt() === t && Ae(e || "all");
}
function go(t) {
  let e = t.keyCode || t.which || t.charCode;
  const n = I.indexOf(e);
  if (n >= 0 && I.splice(n, 1), t.key && t.key.toLowerCase() === "meta" && I.splice(0, I.length), (e === 93 || e === 224) && (e = 91), e in K) {
    K[e] = !1;
    for (const o in H) H[o] === e && (P[o] = !1);
  }
}
function xe(t) {
  if (typeof t > "u")
    Object.keys(_).forEach((i) => {
      Array.isArray(_[i]) && _[i].forEach((s) => yt(s)), delete _[i];
    }), Xt(null);
  else if (Array.isArray(t))
    t.forEach((i) => {
      i.key && yt(i);
    });
  else if (typeof t == "object")
    t.key && yt(t);
  else if (typeof t == "string") {
    for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), o = 1; o < e; o++)
      n[o - 1] = arguments[o];
    let [i, s] = n;
    typeof i == "function" && (s = i, i = ""), yt({
      key: t,
      scope: i,
      method: s,
      splitKey: "+"
    });
  }
}
const yt = (t) => {
  let {
    key: e,
    scope: n,
    method: o,
    splitKey: i = "+"
  } = t;
  be(e).forEach((a) => {
    const r = a.split(i), d = r.length, f = r[d - 1], h = f === "*" ? "*" : ut(f);
    if (!_[h]) return;
    n || (n = dt());
    const u = d > 1 ? ye(H, r) : [], g = [];
    _[h] = _[h].filter((v) => {
      const y = (o ? v.method === o : !0) && v.scope === n && io(v.mods, u);
      return y && g.push(v.element), !y;
    }), g.forEach((v) => Xt(v));
  });
};
function ne(t, e, n, o) {
  if (e.element !== o)
    return;
  let i;
  if (e.scope === n || e.scope === "all") {
    i = e.mods.length > 0;
    for (const s in K)
      Object.prototype.hasOwnProperty.call(K, s) && (!K[s] && e.mods.indexOf(+s) > -1 || K[s] && e.mods.indexOf(+s) === -1) && (i = !1);
    (e.mods.length === 0 && !K[16] && !K[18] && !K[17] && !K[91] || i || e.shortcut === "*") && (e.keys = [], e.keys = e.keys.concat(I), e.method(t, e) === !1 && (t.preventDefault ? t.preventDefault() : t.returnValue = !1, t.stopPropagation && t.stopPropagation(), t.cancelBubble && (t.cancelBubble = !0)));
  }
}
function oe(t, e) {
  const n = _["*"];
  let o = t.keyCode || t.which || t.charCode;
  if (!P.filter.call(this, t)) return;
  if ((o === 93 || o === 224) && (o = 91), I.indexOf(o) === -1 && o !== 229 && I.push(o), ["metaKey", "ctrlKey", "altKey", "shiftKey"].forEach((r) => {
    const d = bt[r];
    t[r] && I.indexOf(d) === -1 ? I.push(d) : !t[r] && I.indexOf(d) > -1 ? I.splice(I.indexOf(d), 1) : r === "metaKey" && t[r] && (I = I.filter((f) => f in bt || f === o));
  }), o in K) {
    K[o] = !0;
    for (const r in H)
      H[r] === o && (P[r] = !0);
    if (!n) return;
  }
  for (const r in K)
    Object.prototype.hasOwnProperty.call(K, r) && (K[r] = t[bt[r]]);
  t.getModifierState && !(t.altKey && !t.ctrlKey) && t.getModifierState("AltGraph") && (I.indexOf(17) === -1 && I.push(17), I.indexOf(18) === -1 && I.push(18), K[17] = !0, K[18] = !0);
  const i = dt();
  if (n)
    for (let r = 0; r < n.length; r++)
      n[r].scope === i && (t.type === "keydown" && n[r].keydown || t.type === "keyup" && n[r].keyup) && ne(t, n[r], i, e);
  if (!(o in _)) return;
  const s = _[o], a = s.length;
  for (let r = 0; r < a; r++)
    if ((t.type === "keydown" && s[r].keydown || t.type === "keyup" && s[r].keyup) && s[r].key) {
      const d = s[r], {
        splitKey: f
      } = d, h = d.key.split(f), u = [];
      for (let g = 0; g < h.length; g++)
        u.push(ut(h[g]));
      u.sort().join("") === I.sort().join("") && ne(t, d, i, e);
    }
}
function P(t, e, n) {
  I = [];
  const o = be(t);
  let i = [], s = "all", a = document, r = 0, d = !1, f = !0, h = "+", u = !1, g = !1;
  for (n === void 0 && typeof e == "function" && (n = e), Object.prototype.toString.call(e) === "[object Object]" && (e.scope && (s = e.scope), e.element && (a = e.element), e.keyup && (d = e.keyup), e.keydown !== void 0 && (f = e.keydown), e.capture !== void 0 && (u = e.capture), typeof e.splitKey == "string" && (h = e.splitKey), e.single === !0 && (g = !0)), typeof e == "string" && (s = e), g && xe(t, s); r < o.length; r++)
    t = o[r].split(h), i = [], t.length > 1 && (i = ye(H, t)), t = t[t.length - 1], t = t === "*" ? "*" : ut(t), t in _ || (_[t] = []), _[t].push({
      keyup: d,
      keydown: f,
      scope: s,
      mods: i,
      shortcut: o[r],
      method: n,
      key: o[r],
      splitKey: h,
      element: a
    });
  if (typeof a < "u" && window) {
    if (!z.has(a)) {
      const v = function() {
        let y = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.event;
        return oe(y, a);
      }, p = function() {
        let y = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.event;
        oe(y, a), go(y);
      };
      z.set(a, {
        keydownListener: v,
        keyupListenr: p,
        capture: u
      }), _t(a, "keydown", v, u), _t(a, "keyup", p, u);
    }
    if (!ct) {
      const v = () => {
        I = [];
      };
      ct = {
        listener: v,
        capture: u
      }, _t(window, "focus", v, u);
    }
  }
}
function po(t) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "all";
  Object.keys(_).forEach((n) => {
    _[n].filter((i) => i.scope === e && i.shortcut === t).forEach((i) => {
      i && i.method && i.method();
    });
  });
}
function Xt(t) {
  const e = Object.values(_).flat();
  if (e.findIndex((o) => {
    let {
      element: i
    } = o;
    return i === t;
  }) < 0) {
    const {
      keydownListener: o,
      keyupListenr: i,
      capture: s
    } = z.get(t) || {};
    o && i && (ot(t, "keyup", i, s), ot(t, "keydown", o, s), z.delete(t));
  }
  if ((e.length <= 0 || z.size <= 0) && (Object.keys(z).forEach((i) => {
    const {
      keydownListener: s,
      keyupListenr: a,
      capture: r
    } = z.get(i) || {};
    s && a && (ot(i, "keyup", a, r), ot(i, "keydown", s, r), z.delete(i));
  }), z.clear(), Object.keys(_).forEach((i) => delete _[i]), ct)) {
    const {
      listener: i,
      capture: s
    } = ct;
    ot(window, "focus", i, s), ct = null;
  }
}
const Nt = {
  getPressedKeyString: co,
  setScope: Ae,
  getScope: dt,
  deleteScope: ho,
  getPressedKeyCodes: ao,
  getAllKeyCodes: lo,
  isPressed: fo,
  filter: uo,
  trigger: po,
  unbind: xe,
  keyMap: lt,
  modifier: H,
  modifierMap: bt
};
for (const t in Nt)
  Object.prototype.hasOwnProperty.call(Nt, t) && (P[t] = Nt[t]);
if (typeof window < "u") {
  const t = window.hotkeys;
  P.noConflict = (e) => (e && window.hotkeys === P && (window.hotkeys = t), P), window.hotkeys = P;
}
const ie = 300, ve = ["up", "down", "left", "right"], Ee = Te ? "+a" : "ctrl+a", mo = [
  ...ve.map((t) => `shift+${t}`),
  Ee
], yo = (t, e, n) => {
  let o;
  const { annotatingEnabled: i, offsetReferenceSelector: s, selectionMode: a } = n, r = (T) => o = T;
  let d;
  const f = (T) => d = T, { store: h, selection: u } = e;
  let g, v, p;
  const y = (T) => {
    v !== !1 && (g = it(T.target) ? void 0 : {
      annotation: fe(),
      selector: [],
      creator: o,
      created: /* @__PURE__ */ new Date()
    });
  }, x = Yt((T) => {
    const m = document.getSelection();
    if (!(m != null && m.anchorNode))
      return;
    if (it(m.anchorNode)) {
      g = void 0;
      return;
    }
    const A = T.timeStamp - ((p == null ? void 0 : p.timeStamp) || T.timeStamp);
    if ((p == null ? void 0 : p.type) === "pointerdown" && (A < 1e3 && !g || m.isCollapsed && A < ie) && y(p || T), !g) return;
    if (m.isCollapsed) {
      h.getAnnotation(g.annotation) && (u.clear(), h.deleteAnnotation(g.annotation));
      return;
    }
    const w = m.getRangeAt(0), L = Ye(w, t);
    if (Ie(L)) return;
    const M = Me(L.cloneRange());
    (M.length !== g.selector.length || M.some((N, U) => {
      var et;
      return N.toString() !== ((et = g.selector[U]) == null ? void 0 : et.quote);
    })) && (g = {
      ...g,
      selector: M.map((N) => Ve(N, t, s)),
      updated: /* @__PURE__ */ new Date()
    }, h.getAnnotation(g.annotation) ? h.updateTarget(g, k.LOCAL) : u.clear());
  }), l = (T) => {
    it(T.target) || (p = xt(T), v = p.button === 0);
  }, c = (T) => {
    if (it(T.target) || !v) return;
    const m = () => {
      const { x: w, y: L } = t.getBoundingClientRect(), M = T.target instanceof Node && t.contains(T.target) && h.getAt(T.clientX - w, T.clientY - L, a === "all", d);
      if (M) {
        const { selected: R } = u, N = new Set(R.map((q) => q.id)), U = Array.isArray(M) ? M.map((q) => q.id) : [M.id];
        (N.size !== U.length || !U.every((q) => N.has(q))) && u.userSelect(U, T);
      } else
        u.clear();
    }, A = T.timeStamp - p.timeStamp;
    setTimeout(() => {
      const w = document.getSelection();
      w != null && w.isCollapsed && A < ie ? (g = void 0, m()) : g && g.selector.length > 0 && (O(), u.userSelect(g.annotation, xt(T)));
    });
  }, b = (T) => {
    const m = document.getSelection();
    m != null && m.isCollapsed || ((!g || g.selector.length === 0) && x(T), O(), u.userSelect(g.annotation, xt(T)));
  }, S = (T) => {
    T.key === "Shift" && g && (document.getSelection().isCollapsed || (O(), u.userSelect(g.annotation, ft(T))));
  }, E = (T) => {
    const m = () => setTimeout(() => {
      (g == null ? void 0 : g.selector.length) > 0 && (u.clear(), h.addAnnotation({
        id: g.annotation,
        bodies: [],
        target: g
      }), u.userSelect(g.annotation, ft(T))), document.removeEventListener("selectionchange", m);
    }, 100);
    document.addEventListener("selectionchange", m), y(T);
  };
  P(mo.join(","), { element: t, keydown: !0, keyup: !1 }, (T) => {
    T.repeat || (p = ft(T));
  }), P(Ee, { keydown: !0, keyup: !1 }, (T) => {
    p = ft(T), E(T);
  });
  const C = (T) => {
    T.repeat || T.target !== t && T.target !== document.body || (g = void 0, u.clear());
  };
  P(ve.join(","), { keydown: !0, keyup: !1 }, C);
  const O = () => {
    const T = h.getAnnotation(g.annotation);
    if (!T) {
      h.addAnnotation({
        id: g.annotation,
        bodies: [],
        target: g
      });
      return;
    }
    const { target: { updated: m } } = T, { updated: A } = g;
    (!m || !A || m < A) && h.updateTarget(g);
  };
  return t.addEventListener("pointerdown", l), document.addEventListener("pointerup", c), document.addEventListener("contextmenu", b), i && (t.addEventListener("keyup", S), t.addEventListener("selectstart", y), document.addEventListener("selectionchange", x)), {
    destroy: () => {
      t.removeEventListener("pointerdown", l), document.removeEventListener("pointerup", c), document.removeEventListener("contextmenu", b), t.removeEventListener("keyup", S), t.removeEventListener("selectstart", y), document.removeEventListener("selectionchange", x), P.unbind();
    },
    setFilter: f,
    setUser: r
  };
}, bo = (t, e) => ({
  ...t,
  annotatingEnabled: t.annotatingEnabled ?? e.annotatingEnabled,
  user: t.user || e.user
}), se = "SPANS", vo = (t, e = {}) => {
  Le(t), Oe(t);
  const n = bo(e, {
    annotatingEnabled: !0,
    user: Dn()
  }), o = eo(t, n.userSelectAction), { selection: i, viewport: s } = o, a = o.store, r = Bn(a), d = Rn(o, r, n.adapter);
  let f = n.user;
  const h = n.renderer === "CSS_HIGHLIGHTS" ? CSS.highlights ? "CSS_HIGHLIGHTS" : se : n.renderer || se, u = h === "SPANS" ? rn(t, o, s) : h === "CSS_HIGHLIGHTS" ? nn(t, o, s) : h === "CANVAS" ? ze(t, o, s) : void 0;
  if (!u)
    throw `Unknown renderer implementation: ${h}`;
  console.debug(`Using ${h} renderer`), n.style && u.setStyle(n.style);
  const g = yo(t, o, n);
  return g.setUser(f), {
    ...In(o, r, n.adapter),
    destroy: () => {
      u.destroy(), g.destroy(), r.destroy();
    },
    element: t,
    getUser: () => f,
    setFilter: (C) => {
      u.setFilter(C), g.setFilter(C);
    },
    setStyle: (C) => u.setStyle(C),
    setUser: (C) => {
      f = C, g.setUser(C);
    },
    setSelected: (C) => {
      C ? i.setSelected(C) : i.clear();
    },
    setPresenceProvider: (C) => {
      C && (u.setPainter(oo(C, n.presence)), C.on("selectionChange", () => u.redraw()));
    },
    setVisible: (C) => u.setVisible(C),
    on: d.on,
    off: d.off,
    scrollIntoView: De(t, a),
    state: o
  };
};
export {
  At as DEFAULT_SELECTED_STYLE,
  W as DEFAULT_STYLE,
  re as NOT_ANNOTATABLE_CLASS,
  tt as NOT_ANNOTATABLE_SELECTOR,
  k as Origin,
  yo as SelectionHandler,
  hn as UserSelectAction,
  xo as W3CTextFormat,
  Le as cancelSingleClickEvents,
  ft as cloneKeyboardEvent,
  xt as clonePointerEvent,
  Ao as createBody,
  ze as createCanvasRenderer,
  nn as createHighlightsRenderer,
  oo as createPresencePainter,
  en as createRenderer,
  rn as createSpansRenderer,
  vo as createTextAnnotator,
  eo as createTextAnnotatorState,
  Yt as debounce,
  bo as fillDefaults,
  Re as getQuoteContext,
  Ut as getRangeAnnotatableContents,
  Te as isMac,
  it as isNotAnnotatable,
  Ce as isRangeAnnotatable,
  F as isRevived,
  Ie as isWhitespaceOrEmpty,
  Ue as mergeClientRects,
  Ke as paint,
  jn as parseW3CTextAnnotation,
  Oe as programmaticallyFocusable,
  Ve as rangeToSelector,
  vt as reviveAnnotation,
  ae as reviveSelector,
  wt as reviveTarget,
  De as scrollIntoView,
  zn as serializeW3CTextAnnotation,
  Me as splitAnnotatableRanges,
  wo as toDomRectList,
  Ye as trimRangeToContainer,
  ke as whitespaceOrEmptyRegex
};
//# sourceMappingURL=text-annotator.es.js.map
