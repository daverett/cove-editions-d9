import { j as jsxRuntimeExports } from "./react-text-annotator.es6.js";
import { useState, useRef, useEffect, useMemo } from "react";
import { useAnnotator, useSelection } from "@annotorious/react";
import { toDomRectList, NOT_ANNOTATABLE_CLASS } from "@recogito/text-annotator";
import { isMobile } from "./react-text-annotator.es9.js";
import { useFloating, useDismiss, useRole, useInteractions, FloatingPortal, FloatingFocusManager, FloatingArrow } from "./react-text-annotator.es10.js";
/* empty css                          */
import { inline, offset, flip, shift, arrow } from "./react-text-annotator.es12.js";
import { autoUpdate } from "./react-text-annotator.es13.js";
const toViewportBounds = (annotationBounds, container) => {
  const { left, top, right, bottom } = annotationBounds;
  const containerBounds = container.getBoundingClientRect();
  return new DOMRect(left + containerBounds.left, top + containerBounds.top, right - left, bottom - top);
};
const TextAnnotationPopup = (props) => {
  var _a;
  const r = useAnnotator();
  const { selected, event } = useSelection();
  const annotation = (_a = selected[0]) == null ? void 0 : _a.annotation;
  const [isOpen, setOpen] = useState((selected == null ? void 0 : selected.length) > 0);
  const arrowRef = useRef(null);
  const { refs, floatingStyles, update, context } = useFloating({
    placement: isMobile() ? "bottom" : "top",
    open: isOpen,
    onOpenChange: (open, _event, reason) => {
      if (!open && (reason === "escape-key" || reason === "focus-out")) {
        setOpen(open);
        r == null ? void 0 : r.cancelSelected();
      }
    },
    middleware: [
      inline(),
      offset(10),
      flip({ crossAxis: true }),
      shift({ crossAxis: true, padding: 10 }),
      arrow({ element: arrowRef })
    ],
    whileElementsMounted: autoUpdate
  });
  const dismiss = useDismiss(context);
  const role = useRole(context, { role: "dialog" });
  const { getFloatingProps } = useInteractions([dismiss, role]);
  useEffect(() => {
    if (annotation == null ? void 0 : annotation.id) {
      const bounds = r == null ? void 0 : r.state.store.getAnnotationBounds(annotation.id);
      setOpen(Boolean(bounds));
    } else {
      setOpen(false);
    }
  }, [annotation == null ? void 0 : annotation.id, r == null ? void 0 : r.state.store]);
  useEffect(() => {
    if (!r) return;
    if (isOpen && (annotation == null ? void 0 : annotation.id)) {
      refs.setPositionReference({
        getBoundingClientRect: () => {
          const bounds = r.state.store.getAnnotationBounds(annotation.id);
          return bounds ? toViewportBounds(bounds, r.element) : new DOMRect();
        },
        getClientRects: () => {
          const rects = r.state.store.getAnnotationRects(annotation.id);
          const viewportRects = rects.map((rect) => toViewportBounds(rect, r.element));
          return toDomRectList(viewportRects);
        }
      });
    } else {
      refs.setPositionReference(null);
    }
  }, [isOpen, annotation == null ? void 0 : annotation.id, annotation == null ? void 0 : annotation.target, r]);
  useEffect(() => {
    const config = { attributes: true, childList: true, subtree: true };
    const mutationObserver = new MutationObserver(() => update());
    mutationObserver.observe(document.body, config);
    window.document.addEventListener("scroll", update, true);
    return () => {
      mutationObserver.disconnect();
      window.document.removeEventListener("scroll", update, true);
    };
  }, [update]);
  const initialFocus = useMemo(() => {
    return (event == null ? void 0 : event.type) === "keyup" || (event == null ? void 0 : event.type) === "contextmenu" || isMobile() ? -1 : 0;
  }, [event]);
  const onClose = () => r == null ? void 0 : r.cancelSelected();
  return isOpen && annotation ? /* @__PURE__ */ jsxRuntimeExports.jsx(FloatingPortal, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    FloatingFocusManager,
    {
      context,
      modal: false,
      closeOnFocusOut: true,
      returnFocus: false,
      initialFocus,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: `a9s-popup r6o-popup annotation-popup r6o-text-popup ${NOT_ANNOTATABLE_CLASS}`,
          ref: refs.setFloating,
          style: floatingStyles,
          ...getFloatingProps(getStopEventsPropagationProps()),
          children: [
            props.popup({
              annotation: selected[0].annotation,
              editable: selected[0].editable,
              event
            }),
            props.arrow && /* @__PURE__ */ jsxRuntimeExports.jsx(
              FloatingArrow,
              {
                ref: arrowRef,
                context,
                ...props.arrowProps || {}
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "r6o-popup-sr-only", "aria-live": "assertive", onClick: onClose, children: props.ariaCloseWarning || "Click or leave this dialog to close it." })
          ]
        }
      )
    }
  ) }) : null;
};
const getStopEventsPropagationProps = () => ({
  onPointerUp: (event) => event.stopPropagation(),
  onPointerDown: (event) => event.stopPropagation(),
  onMouseDown: (event) => event.stopPropagation(),
  onMouseUp: (event) => event.stopPropagation()
});
const TextAnnotatorPopup = (props) => {
  useEffect(() => {
    console.warn("TextAnnotatorPopup is deprecated and will be removed in a future version. Please use TextAnnotationPopup instead.");
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TextAnnotationPopup, { ...props });
};
export {
  TextAnnotationPopup,
  TextAnnotatorPopup
};
//# sourceMappingURL=react-text-annotator.es5.js.map
