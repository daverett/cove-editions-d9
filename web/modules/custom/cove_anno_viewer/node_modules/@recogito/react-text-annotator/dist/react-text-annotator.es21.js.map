{"version":3,"file":"react-text-annotator.es21.js","sources":["../../../node_modules/CETEIcean/src/utilities.js"],"sourcesContent":["export function getOrdinality(elt, name) {\n  let pos = 1;\n  let e = elt;\n  while (e && e.previousElementSibling !== null && (name ? e.previousElementSibling.localName == name : true)) {\n    pos++;\n    e = e.previousElementSibling;\n    if (!e.previousElementSibling) {\n      break;\n    }\n  }\n  return pos;\n}\n\n/* \n  Performs a deep copy operation of the input node while stripping\n  out child elements introduced by CETEIcean.\n*/ \nexport function copyAndReset(node) {\n  const doc = node.ownerDocument;\n  let clone = (n) => {    \n    let result;\n    switch (n.nodeType) {\n      case 1: // nodeType 1 is Node.ELEMENT_NODE\n        result = doc.createElement(n.nodeName);\n        break;\n      case 9: // nodeType 9 is Node.DOCUMENT_NODE\n        result = doc.implementation.createDocument();\n        break;\n      case 11: // nodeType 11 is Node.DOCUMENT_FRAGMENT_NODE\n        result = doc.createDocumentFragment();\n        break;\n      default:\n        result = n.cloneNode(true);\n    }\n    if (n.attributes) {\n      for (let att of Array.from(n.attributes)) {\n        if (att.name !== \"data-processed\") {\n          result.setAttribute(att.name,att.value);\n        }\n      }\n    }\n    for (let nd of Array.from(n.childNodes)){\n      // nodeType 1 is Node.ELEMENT_NODE\n      if (nd.nodeType == 1) {\n        if (nd.hasAttribute(\"data-original\")) {\n          for (let childNode of Array.from(nd.childNodes)) {\n            let child = result.appendChild(clone(childNode));\n            // nodeType 1 is Node.ELEMENT_NODE\n            if (child.nodeType === 1 && child.hasAttribute(\"data-origid\")) {\n              child.setAttribute(\"id\", child.getAttribute(\"data-origid\"));\n              child.removeAttribute(\"data-origid\");\n            }\n          }\n          return result;\n        } else if (nd.hasAttribute(\"data-origname\")) {\n          result.appendChild(clone(nd));\n        }\n      } else {\n        result.appendChild(nd.cloneNode());\n      }\n    }\n    return result;\n  }\n  return clone(node);\n}\n\n/* \n  Given a space-separated list of URLs (e.g. in a ref with multiple\n  targets), returns just the first one.\n*/\nexport function first(urls) {\n  return urls.replace(/ .*$/, \"\");\n}\n\n/* \n  Wraps the content of the element parameter in a hidden <cetei-original data-original>\n*/\nexport function hideContent(elt, rewriteIds = true) {\n  const doc = elt.ownerDocument;\n  if (elt.childNodes.length > 0) {\n    let hidden = doc.createElement(\"cetei-original\");\n    elt.appendChild(hidden);\n    hidden.setAttribute(\"hidden\", \"\");\n    hidden.setAttribute(\"data-original\", \"\");\n    for (let node of Array.from(elt.childNodes)) {\n      if (node !== hidden) {\n        // nodeType 1 is Node.ELEMENT_NODE\n        if (node.nodeType === 1) {\n          node.setAttribute(\"data-processed\", \"\");\n          for (let e of node.querySelectorAll(\"*\")) {\n            e.setAttribute(\"data-processed\", \"\");\n          }\n        }\n        hidden.appendChild(elt.removeChild(node));\n      }\n    }\n    if (rewriteIds) {\n      for (let e of Array.from(hidden.querySelectorAll(\"*\"))) {\n        if (e.hasAttribute(\"id\")) {\n          e.setAttribute(\"data-origid\", e.getAttribute(\"id\"));\n          e.removeAttribute(\"id\");\n        }\n      }\n    }\n  }\n}\n\nexport function normalizeURI(urls) {\n  return this.rw(this.first(urls))\n}\n\n/* \n  Takes a string and a number and returns the original string\n  printed that number of times.\n*/\nexport function repeat(str, times) {\n  let result = \"\";\n  for (let i = 0; i < times; i++) {\n    result += str;\n  }\n  return result;\n}\n\n/* \n  Resolves URIs that use TEI prefixDefs into full URIs.\n  See https://www.tei-c.org/release/doc/tei-p5-doc/en/html/ref-prefixDef.html\n*/\nexport function resolveURI(uri) {\n  let prefixdef = this.prefixDefs[uri.substring(0,uri.indexOf(\":\"))];\n  return uri.replace(new RegExp(prefixdef[\"matchPattern\"]), prefixdef[\"replacementPattern\"]);\n}\n\n/*\n  Convenience function for getting prefix definitions, Takes a prefix\n  and returns an object with \"matchPattern\" and \"replacementPattern\"\n  keys.\n*/\nexport function getPrefixDef(prefix) {\n  return this.prefixDefs[prefix];\n}\n\n/* \n  Takes a relative URL and rewrites it based on the base URL of the\n  HTML document\n*/\nexport function rw(url) {\n  if (!url.match(/^(?:http|mailto|file|\\/|#).*$/)) {\n    return this.base + first(url);\n  } else {\n    return url;\n  }\n}\n\n/*\n  Combines the functionality of copyAndReset() and serialize() to return\n  a \"clean\" version of the XML markup.\n */\nexport function resetAndSerialize(el, stripElt, ws) {\n  return serialize(copyAndReset(el), stripElt, ws);\n}\n\n/* \n  Takes an element and serializes it to an XML string or, if the stripElt\n  parameter is set, serializes the element's content. The ws parameter, if\n  set, will switch on minimal \"pretty-printing\" and indenting of the serialized\n  result.\n*/\nexport function serialize(el, stripElt, ws) {\n  let str = \"\";\n  const ignorable = (txt) => {\n    return !(/[^\\t\\n\\r ]/.test(txt));\n  }\n  if (el.nodeType === 9 || el.nodeType === 11) { // nodeType 9 is Node.DOCUMENT_NODE; nodeType 11 is Node.DOCUMENT_FRAGMENT_NODE\n    str += \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\";\n  }\n  // nodeType 1 is Node.ELEMENT_NODE\n  if (!stripElt && el.nodeType == 1) {\n    if ((typeof ws === \"string\") && ws !== \"\") {\n      str += \"\\n\" + ws + \"<\";\n    } else  {\n      str += \"<\";\n    }\n    str += el.getAttribute(\"data-origname\");\n    // HTML5 lowercases all attribute names; @data-origatts contains the original names\n    let attrNames = el.hasAttribute(\"data-origatts\") ? el.getAttribute(\"data-origatts\").split(\" \") : [];\n    for (let attr of Array.from(el.attributes)) {\n      if (!attr.name.startsWith(\"data-\") && !([\"id\", \"lang\", \"class\"].includes(attr.name))) {\n        str += \" \" + attrNames.find(function(e) {return e.toLowerCase() == attr.name}) + \"=\\\"\" + attr.value + \"\\\"\";\n      }\n      if (attr.name == \"data-xmlns\") {\n        str += \" xmlns=\\\"\" + attr.value +\"\\\"\";\n      }\n    }\n    if (el.childNodes.length > 0) {\n      str += \">\";\n    } else {\n      str += \"/>\";\n    }\n  }\n  for (let node of Array.from(el.childNodes)) {\n    // nodeType 1 is Node.ELEMENT_NODE\n    // nodeType 7 is Node.PROCESSING_INSTRUCTION_NODE\n    // nodeType 8 is Node.COMMENT_NODE\n    switch (node.nodeType) {\n      case 1:\n        if (typeof ws === \"string\") {\n          str += serialize(node, false, ws + \"  \");\n        } else {\n          str += serialize(node, false, ws);\n        }\n        break;\n      case 7:\n        str += `<?${node.nodeName} ${node.nodeValue}?>`;\n        if (el.nodeType === 9 || el.nodeType === 11) {\n          str += \"\\n\";\n        }\n        break;\n      case 8:\n        str += `<!--${node.nodeValue}-->`;\n        if (el.nodeType === 9 || el.nodeType === 11) {\n          str += \"\\n\";\n        }\n        break;\n      default:\n        if (stripElt && ignorable(node.nodeValue)) {\n          str += node.nodeValue.replace(/^\\s*\\n/, \"\");\n        }\n        if ((typeof ws === \"string\") && ignorable(node.nodeValue)) {\n          break;\n        }\n        str += node.nodeValue;\n    }\n  }\n  if (!stripElt && el.nodeType == 1 && el.childNodes.length > 0) {\n    if (typeof ws === \"string\") {\n      str += \"\\n\" + ws + \"</\";\n    } else  {\n      str += \"</\";\n    }\n    str += el.getAttribute(\"data-origname\") + \">\";\n  }\n  if (el.nodeType === 9 || el.nodeType === 11) {\n    str += \"\\n\";\n  }\n  return str;\n}\n\n/* \n  Write out the HTML markup to a string, using HTML conventions.\n */\nexport function serializeHTML(el, stripElt, ws) {\n  const EMPTY_ELEMENTS = ['area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'link', 'meta', 'param', 'source', 'track', 'wbr'];\n  let str = \"\";\n  const ignorable = (txt) => {\n    return !(/[^\\t\\n\\r ]/.test(txt));\n  }\n  // nodeType 1 is Node.ELEMENT_NODE\n  if (!stripElt && el.nodeType == 1) {\n    if ((typeof ws === \"string\") && ws !== \"\") {\n      str += \"\\n\" + ws + \"<\";\n    } else  {\n      str += \"<\";\n    }\n    str += el.nodeName;\n    for (let attr of Array.from(el.attributes)) {\n      str += \" \" + attr.name + \"=\\\"\" + attr.value + \"\\\"\";\n    }\n    str += \">\";\n  }\n  for (let node of Array.from(el.childNodes)) {\n    // nodeType 1 is Node.ELEMENT_NODE\n    // nodeType 7 is Node.PROCESSING_INSTRUCTION_NODE\n    // nodeType 8 is Node.COMMENT_NODE\n    switch (node.nodeType) {\n      case 1:\n        if (typeof ws === \"string\") {\n          str += serializeHTML(node, false, ws + \"  \");\n        } else {\n          str += serializeHTML(node, false, ws);\n        }\n        break;\n      case 7:\n        str += `<?${node.nodeName} ${node.nodeValue}?>`;\n        if (el.nodeType === 9 || el.nodeType === 11) {\n          str += \"\\n\";\n        }\n        break;\n      case 8:\n        str += `<!--${node.nodeValue}-->`;\n        if (el.nodeType === 9 || el.nodeType === 11) {\n          str += \"\\n\";\n        }\n        break;\n      default:\n        if (stripElt && ignorable(node.nodeValue)) {\n          str += node.nodeValue.replace(/^\\s*\\n/, \"\");\n        }\n        if ((typeof ws === \"string\") && ignorable(node.nodeValue)) {\n          break;\n        }\n        str += node.nodeValue.replace(/</g, \"&lt;\");\n    }\n  }\n  if (!EMPTY_ELEMENTS.includes(el.nodeName)) {\n    if (!stripElt && el.nodeType == 1) {\n      if (typeof ws === \"string\") {\n        str += `\\n${ws}</`;\n      } else  {\n        str += \"</\";\n      }\n      str += `${el.nodeName}>`;\n    }\n  }\n  if (el.nodeType === 9 || el.nodeType === 11) {\n    str += \"\\n\";\n  }\n  return str;\n}\n\nexport function unEscapeEntities(str) {\n  return str.replace(/&gt;/, \">\")\n            .replace(/&quot;/, \"\\\"\")\n            .replace(/&apos;/, \"'\")\n            .replace(/&amp;/, \"&\");\n}\n\n// Given a qualified name (e.g. tei:text), return the element name\nexport function tagName(name) {\n  if (name.includes(\":\"), 1) {\n    return name.replace(/:/,\"-\").toLowerCase();\n  } else {\n    return \"ceteicean-\" + name.toLowerCase();\n  }\n}\n\nexport function defineCustomElement(name, behavior = null, debug = false) {\n  /* \n  Registers the list of elements provided with the browser.\n  Called by makeHTML5(), but can be called independently if, for example,\n  you've created Custom Elements via an XSLT transformation instead.\n  */\n  try {\n    window.customElements.define(tagName(name), class extends HTMLElement {\n      constructor() {\n        super(); \n        if (!this.matches(\":defined\")) { // \"Upgraded\" undefined elements can have attributes & children; new elements can't\n          if (behavior) {\n            behavior.call(this);\n            // We don't want to double-process elements, so add a flag\n            this.setAttribute(\"data-processed\", \"\");\n          }\n        }\n      }\n      // Process new elements when they are connected to the browser DOM\n      connectedCallback() {\n        if (!this.hasAttribute(\"data-processed\")) {\n          if (behavior) {\n            behavior.call(this);\n            this.setAttribute(\"data-processed\", \"\");\n          }\n        }\n      };\n    });\n  } catch (error) {\n    // When using the same CETEIcean instance for multiple TEI files, this error becomes very common. \n    // It's muted by default unless the debug option is set.\n    if (debug) {\n        console.log(tagName(name) + \" couldn't be registered or is already registered.\");\n        console.log(error);\n    }\n  }\n}\n"],"names":[],"mappings":"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","x_google_ignoreList":[0]}