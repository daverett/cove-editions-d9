function getOrdinality(elt, name) {
  let pos = 1;
  let e = elt;
  while (e && e.previousElementSibling !== null && (name ? e.previousElementSibling.localName == name : true)) {
    pos++;
    e = e.previousElementSibling;
    if (!e.previousElementSibling) {
      break;
    }
  }
  return pos;
}
function copyAndReset(node) {
  const doc = node.ownerDocument;
  let clone = (n) => {
    let result;
    switch (n.nodeType) {
      case 1:
        result = doc.createElement(n.nodeName);
        break;
      case 9:
        result = doc.implementation.createDocument();
        break;
      case 11:
        result = doc.createDocumentFragment();
        break;
      default:
        result = n.cloneNode(true);
    }
    if (n.attributes) {
      for (let att of Array.from(n.attributes)) {
        if (att.name !== "data-processed") {
          result.setAttribute(att.name, att.value);
        }
      }
    }
    for (let nd of Array.from(n.childNodes)) {
      if (nd.nodeType == 1) {
        if (nd.hasAttribute("data-original")) {
          for (let childNode of Array.from(nd.childNodes)) {
            let child = result.appendChild(clone(childNode));
            if (child.nodeType === 1 && child.hasAttribute("data-origid")) {
              child.setAttribute("id", child.getAttribute("data-origid"));
              child.removeAttribute("data-origid");
            }
          }
          return result;
        } else if (nd.hasAttribute("data-origname")) {
          result.appendChild(clone(nd));
        }
      } else {
        result.appendChild(nd.cloneNode());
      }
    }
    return result;
  };
  return clone(node);
}
function first(urls) {
  return urls.replace(/ .*$/, "");
}
function hideContent(elt, rewriteIds = true) {
  const doc = elt.ownerDocument;
  if (elt.childNodes.length > 0) {
    let hidden = doc.createElement("cetei-original");
    elt.appendChild(hidden);
    hidden.setAttribute("hidden", "");
    hidden.setAttribute("data-original", "");
    for (let node of Array.from(elt.childNodes)) {
      if (node !== hidden) {
        if (node.nodeType === 1) {
          node.setAttribute("data-processed", "");
          for (let e of node.querySelectorAll("*")) {
            e.setAttribute("data-processed", "");
          }
        }
        hidden.appendChild(elt.removeChild(node));
      }
    }
    if (rewriteIds) {
      for (let e of Array.from(hidden.querySelectorAll("*"))) {
        if (e.hasAttribute("id")) {
          e.setAttribute("data-origid", e.getAttribute("id"));
          e.removeAttribute("id");
        }
      }
    }
  }
}
function normalizeURI(urls) {
  return this.rw(this.first(urls));
}
function repeat(str, times) {
  let result = "";
  for (let i = 0; i < times; i++) {
    result += str;
  }
  return result;
}
function resolveURI(uri) {
  let prefixdef = this.prefixDefs[uri.substring(0, uri.indexOf(":"))];
  return uri.replace(new RegExp(prefixdef["matchPattern"]), prefixdef["replacementPattern"]);
}
function getPrefixDef(prefix) {
  return this.prefixDefs[prefix];
}
function rw(url) {
  if (!url.match(/^(?:http|mailto|file|\/|#).*$/)) {
    return this.base + first(url);
  } else {
    return url;
  }
}
function resetAndSerialize(el, stripElt, ws) {
  return serialize(copyAndReset(el), stripElt, ws);
}
function serialize(el, stripElt, ws) {
  let str = "";
  const ignorable = (txt) => {
    return !/[^\t\n\r ]/.test(txt);
  };
  if (el.nodeType === 9 || el.nodeType === 11) {
    str += '<?xml version="1.0" encoding="UTF-8"?>\n';
  }
  if (!stripElt && el.nodeType == 1) {
    if (typeof ws === "string" && ws !== "") {
      str += "\n" + ws + "<";
    } else {
      str += "<";
    }
    str += el.getAttribute("data-origname");
    let attrNames = el.hasAttribute("data-origatts") ? el.getAttribute("data-origatts").split(" ") : [];
    for (let attr of Array.from(el.attributes)) {
      if (!attr.name.startsWith("data-") && !["id", "lang", "class"].includes(attr.name)) {
        str += " " + attrNames.find(function(e) {
          return e.toLowerCase() == attr.name;
        }) + '="' + attr.value + '"';
      }
      if (attr.name == "data-xmlns") {
        str += ' xmlns="' + attr.value + '"';
      }
    }
    if (el.childNodes.length > 0) {
      str += ">";
    } else {
      str += "/>";
    }
  }
  for (let node of Array.from(el.childNodes)) {
    switch (node.nodeType) {
      case 1:
        if (typeof ws === "string") {
          str += serialize(node, false, ws + "  ");
        } else {
          str += serialize(node, false, ws);
        }
        break;
      case 7:
        str += `<?${node.nodeName} ${node.nodeValue}?>`;
        if (el.nodeType === 9 || el.nodeType === 11) {
          str += "\n";
        }
        break;
      case 8:
        str += `<!--${node.nodeValue}-->`;
        if (el.nodeType === 9 || el.nodeType === 11) {
          str += "\n";
        }
        break;
      default:
        if (stripElt && ignorable(node.nodeValue)) {
          str += node.nodeValue.replace(/^\s*\n/, "");
        }
        if (typeof ws === "string" && ignorable(node.nodeValue)) {
          break;
        }
        str += node.nodeValue;
    }
  }
  if (!stripElt && el.nodeType == 1 && el.childNodes.length > 0) {
    if (typeof ws === "string") {
      str += "\n" + ws + "</";
    } else {
      str += "</";
    }
    str += el.getAttribute("data-origname") + ">";
  }
  if (el.nodeType === 9 || el.nodeType === 11) {
    str += "\n";
  }
  return str;
}
function serializeHTML(el, stripElt, ws) {
  const EMPTY_ELEMENTS = ["area", "base", "br", "col", "embed", "hr", "img", "input", "link", "meta", "param", "source", "track", "wbr"];
  let str = "";
  const ignorable = (txt) => {
    return !/[^\t\n\r ]/.test(txt);
  };
  if (!stripElt && el.nodeType == 1) {
    if (typeof ws === "string" && ws !== "") {
      str += "\n" + ws + "<";
    } else {
      str += "<";
    }
    str += el.nodeName;
    for (let attr of Array.from(el.attributes)) {
      str += " " + attr.name + '="' + attr.value + '"';
    }
    str += ">";
  }
  for (let node of Array.from(el.childNodes)) {
    switch (node.nodeType) {
      case 1:
        if (typeof ws === "string") {
          str += serializeHTML(node, false, ws + "  ");
        } else {
          str += serializeHTML(node, false, ws);
        }
        break;
      case 7:
        str += `<?${node.nodeName} ${node.nodeValue}?>`;
        if (el.nodeType === 9 || el.nodeType === 11) {
          str += "\n";
        }
        break;
      case 8:
        str += `<!--${node.nodeValue}-->`;
        if (el.nodeType === 9 || el.nodeType === 11) {
          str += "\n";
        }
        break;
      default:
        if (stripElt && ignorable(node.nodeValue)) {
          str += node.nodeValue.replace(/^\s*\n/, "");
        }
        if (typeof ws === "string" && ignorable(node.nodeValue)) {
          break;
        }
        str += node.nodeValue.replace(/</g, "&lt;");
    }
  }
  if (!EMPTY_ELEMENTS.includes(el.nodeName)) {
    if (!stripElt && el.nodeType == 1) {
      if (typeof ws === "string") {
        str += `
${ws}</`;
      } else {
        str += "</";
      }
      str += `${el.nodeName}>`;
    }
  }
  if (el.nodeType === 9 || el.nodeType === 11) {
    str += "\n";
  }
  return str;
}
function unEscapeEntities(str) {
  return str.replace(/&gt;/, ">").replace(/&quot;/, '"').replace(/&apos;/, "'").replace(/&amp;/, "&");
}
function tagName(name) {
  if (name.includes(":"), 1) {
    return name.replace(/:/, "-").toLowerCase();
  }
}
function defineCustomElement(name, behavior = null, debug = false) {
  try {
    window.customElements.define(tagName(name), class extends HTMLElement {
      constructor() {
        super();
        if (!this.matches(":defined")) {
          if (behavior) {
            behavior.call(this);
            this.setAttribute("data-processed", "");
          }
        }
      }
      // Process new elements when they are connected to the browser DOM
      connectedCallback() {
        if (!this.hasAttribute("data-processed")) {
          if (behavior) {
            behavior.call(this);
            this.setAttribute("data-processed", "");
          }
        }
      }
    });
  } catch (error) {
    if (debug) {
      console.log(tagName(name) + " couldn't be registered or is already registered.");
      console.log(error);
    }
  }
}
export {
  copyAndReset,
  defineCustomElement,
  first,
  getOrdinality,
  getPrefixDef,
  hideContent,
  normalizeURI,
  repeat,
  resetAndSerialize,
  resolveURI,
  rw,
  serialize,
  serializeHTML,
  tagName,
  unEscapeEntities
};
//# sourceMappingURL=react-text-annotator.es21.js.map
