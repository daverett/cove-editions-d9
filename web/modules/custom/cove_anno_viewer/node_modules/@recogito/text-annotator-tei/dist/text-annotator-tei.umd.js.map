{"version":3,"file":"text-annotator-tei.umd.js","sources":["../../text-annotator/dist/text-annotator.es.js","../src/crosswalk/utils/reanchor.ts","../src/crosswalk/forward.ts","../src/TEIPlugin.ts"],"sourcesContent":["const re = \"not-annotatable\", tt = `.${re}`, it = (t) => {\n  var n;\n  return !!(t instanceof HTMLElement ? t.closest(tt) : (n = t.parentElement) == null ? void 0 : n.closest(tt));\n}, Ce = (t) => {\n  const e = t.commonAncestorContainer;\n  return !it(e);\n}, Le = (t) => t.addEventListener(\"click\", (e) => {\n  // Allow clicks within not-annotatable elements\n  !e.target.closest(tt) && !e.target.closest(\"a\") && e.preventDefault();\n}), xt = (t) => ({\n  ...t,\n  type: t.type,\n  x: t.x,\n  y: t.y,\n  clientX: t.clientX,\n  clientY: t.clientY,\n  offsetX: t.offsetX,\n  offsetY: t.offsetY,\n  screenX: t.screenX,\n  screenY: t.screenY,\n  isPrimary: t.isPrimary,\n  altKey: t.altKey,\n  ctrlKey: t.ctrlKey,\n  metaKey: t.metaKey,\n  shiftKey: t.shiftKey,\n  button: t.button,\n  buttons: t.buttons,\n  currentTarget: t.currentTarget,\n  target: t.target,\n  defaultPrevented: t.defaultPrevented,\n  detail: t.detail,\n  eventPhase: t.eventPhase,\n  pointerId: t.pointerId,\n  pointerType: t.pointerType,\n  timeStamp: t.timeStamp\n}), ft = (t) => ({\n  ...t,\n  type: t.type,\n  key: t.key,\n  code: t.code,\n  location: t.location,\n  repeat: t.repeat,\n  altKey: t.altKey,\n  ctrlKey: t.ctrlKey,\n  metaKey: t.metaKey,\n  shiftKey: t.shiftKey,\n  currentTarget: t.currentTarget,\n  target: t.target,\n  defaultPrevented: t.defaultPrevented,\n  detail: t.detail,\n  timeStamp: t.timeStamp\n}), Te = /mac/i.test(navigator.userAgentData ? navigator.userAgentData.platform : navigator.platform), Oe = (t) => {\n  !t.hasAttribute(\"tabindex\") && t.tabIndex < 0 && t.setAttribute(\"tabindex\", \"-1\"), t.classList.add(\"no-focus-outline\");\n}, Yt = (t, e = 10) => {\n  let n;\n  return (...o) => {\n    clearTimeout(n), n = setTimeout(() => t.apply(void 0, o), e);\n  };\n}, Be = function* (t) {\n  const e = document.createNodeIterator(\n    t.commonAncestorContainer,\n    NodeFilter.SHOW_ELEMENT,\n    (o) => o instanceof HTMLElement && o.classList.contains(re) && !o.parentElement.closest(tt) && t.intersectsNode(o) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP\n  );\n  let n;\n  for (; n = e.nextNode(); )\n    n instanceof HTMLElement && (yield n);\n}, Me = (t) => {\n  if (!Ce(t)) return [];\n  const e = [];\n  let n = null;\n  for (const o of Be(t)) {\n    let i;\n    n ? (i = document.createRange(), i.setStartAfter(n), i.setEndBefore(o)) : (i = t.cloneRange(), i.setEndBefore(o)), i.collapsed || e.push(i), n = o;\n  }\n  if (n) {\n    const o = t.cloneRange();\n    o.setStartAfter(n), o.collapsed || e.push(o);\n  }\n  return e.length > 0 ? e : [t];\n}, Ut = (t) => {\n  const e = t.cloneContents();\n  return e.querySelectorAll(tt).forEach((n) => n.remove()), e;\n}, Re = (t, e, n = 10, o) => {\n  const i = o ? t.startContainer.parentElement.closest(o) : e, s = document.createRange();\n  s.setStart(i, 0), s.setEnd(t.startContainer, t.startOffset);\n  const a = Ut(s).textContent, r = document.createRange();\n  r.setStart(t.endContainer, t.endOffset), i === document.body ? r.setEnd(i, i.childNodes.length) : r.setEndAfter(i);\n  const d = Ut(r).textContent;\n  return {\n    prefix: a.substring(a.length - n),\n    suffix: d.substring(0, n)\n  };\n}, F = (t) => t.every((e) => e.range instanceof Range && !e.range.collapsed), ke = /^\\s*$/, Ie = (t) => ke.test(t.toString()), _e = (t, e) => {\n  const n = (s) => Math.round(s * 10) / 10, o = {\n    top: n(t.top),\n    bottom: n(t.bottom),\n    left: n(t.left),\n    right: n(t.right)\n  }, i = {\n    top: n(e.top),\n    bottom: n(e.bottom),\n    left: n(e.left),\n    right: n(e.right)\n  };\n  if (Math.abs(o.top - i.top) < 0.5 && Math.abs(o.bottom - i.bottom) < 0.5) {\n    if (Math.abs(o.left - i.right) < 0.5 || Math.abs(o.right - i.left) < 0.5)\n      return \"inline-adjacent\";\n    if (o.left >= i.left && o.right <= i.right)\n      return \"inline-is-contained\";\n    if (o.left <= i.left && o.right >= i.right)\n      return \"inline-contains\";\n  } else if (o.top <= i.top && o.bottom >= i.bottom) {\n    if (o.left <= i.left && o.right >= i.right)\n      return \"block-contains\";\n  } else if (o.top >= i.top && o.bottom <= i.bottom && o.left >= i.left && o.right <= i.right)\n    return \"block-is-contained\";\n}, Ne = (t, e) => {\n  const n = Math.min(t.left, e.left), o = Math.max(t.right, e.right), i = Math.min(t.top, e.top), s = Math.max(t.bottom, e.bottom);\n  return new DOMRect(n, i, o - n, s - i);\n}, Ue = (t) => t.reduce((e, n) => {\n  if (n.width === 0 || n.height === 0)\n    return e;\n  let o = [...e], i = !1;\n  for (const s of e) {\n    const a = _e(n, s);\n    if (a === \"inline-adjacent\") {\n      o = o.map((r) => r === s ? Ne(n, s) : r), i = !0;\n      break;\n    } else if (a === \"inline-contains\") {\n      o = o.map((r) => r === s ? n : r), i = !0;\n      break;\n    } else if (a === \"inline-is-contained\") {\n      i = !0;\n      break;\n    } else if (a === \"block-contains\" || a === \"block-is-contained\") {\n      n.width < s.width && (o = o.map((r) => r === s ? n : r)), i = !0;\n      break;\n    }\n  }\n  return i ? o : [...o, n];\n}, []), wo = (t) => ({\n  length: t.length,\n  item: (e) => t[e],\n  [Symbol.iterator]: function* () {\n    for (let e = 0; e < this.length; e++)\n      yield this.item(e);\n  }\n}), Ve = (t, e, n) => {\n  const o = document.createRange(), i = n ? t.startContainer.parentElement.closest(n) : e;\n  o.setStart(i, 0), o.setEnd(t.startContainer, t.startOffset);\n  const s = Ut(o).textContent, a = t.toString(), r = s.length || 0, d = r + a.length;\n  return n ? { quote: a, start: r, end: d, range: t, offsetReference: i } : { quote: a, start: r, end: d, range: t };\n}, ae = (t, e) => {\n  var h, u;\n  const { start: n, end: o } = t, i = t.offsetReference || e, s = document.createNodeIterator(\n    e,\n    NodeFilter.SHOW_TEXT,\n    (g) => {\n      var v;\n      return (v = g.parentElement) != null && v.closest(tt) ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;\n    }\n  );\n  let a = 0;\n  const r = document.createRange();\n  let d = s.nextNode();\n  d === null && console.error(\"Could not revive annotation target. Content missing.\");\n  let f = !i;\n  for (; d !== null; ) {\n    if (f || (f = i == null ? void 0 : i.contains(d)), f) {\n      const g = ((h = d.textContent) == null ? void 0 : h.length) || 0;\n      if (a + g > n) {\n        r.setStart(d, n - a);\n        break;\n      }\n      a += g;\n    }\n    d = s.nextNode();\n  }\n  for (; d !== null; ) {\n    const g = ((u = d.textContent) == null ? void 0 : u.length) || 0;\n    if (a + g >= o) {\n      r.setEnd(d, o - a);\n      break;\n    }\n    a += g, d = s.nextNode();\n  }\n  return {\n    ...t,\n    range: r\n  };\n}, wt = (t, e) => F(t.selector) ? t : {\n  ...t,\n  selector: t.selector.map((n) => n.range instanceof Range && !n.range.collapsed ? n : ae(n, e))\n}, vt = (t, e) => F(t.target.selector) ? t : { ...t, target: wt(t.target, e) }, Ye = (t, e) => {\n  const n = t.cloneRange();\n  return e.contains(n.startContainer) || n.setStart(e, 0), e.contains(n.endContainer) || n.setEnd(e, e.childNodes.length), n;\n}, ce = (t) => {\n  if (t === null)\n    return document.scrollingElement;\n  const { overflowY: e } = window.getComputedStyle(t);\n  return e !== \"visible\" && e !== \"hidden\" && t.scrollHeight > t.clientHeight ? t : ce(t.parentElement);\n}, De = (t, e) => (n) => {\n  const o = typeof n == \"string\" ? n : n.id, i = (a) => {\n    const r = s.getBoundingClientRect(), d = s.clientHeight, f = s.clientWidth, h = a.selector[0].range.getBoundingClientRect(), { width: u, height: g } = e.getAnnotationBounds(o), v = h.top - r.top, p = h.left - r.left, y = s.parentElement ? s.scrollTop : 0, x = s.parentElement ? s.scrollLeft : 0, l = v + y - (d - g) / 2, c = p + x - (f - u) / 2;\n    s.scroll({ top: l, left: c, behavior: \"smooth\" });\n  }, s = ce(t);\n  if (s) {\n    const a = e.getAnnotation(o), { range: r } = a.target.selector[0];\n    if (r && !r.collapsed)\n      return i(a.target), !0;\n    {\n      const d = wt(a.target, t), { range: f } = d.selector[0];\n      if (f && !f.collapsed)\n        return i(d), !0;\n    }\n  }\n  return !1;\n}, W = {\n  fill: \"rgb(0, 128, 255)\",\n  fillOpacity: 0.18\n}, At = {\n  fill: \"rgb(0, 128, 255)\",\n  fillOpacity: 0.45\n}, Ke = (t, e, n, o, i) => {\n  var a, r;\n  const s = n ? typeof n == \"function\" ? n(t.annotation, t.state, i) || ((a = t.state) != null && a.selected ? At : W) : n : (r = t.state) != null && r.selected ? At : W;\n  return o && o.paint(t, e) || s;\n}, Xe = (t) => {\n  const { top: e, left: n } = t.getBoundingClientRect(), { innerWidth: o, innerHeight: i } = window, s = -n, a = -e, r = o - n, d = i - e;\n  return { top: e, left: n, minX: s, minY: a, maxX: r, maxY: d };\n}, Pe = (t) => {\n  let e = /* @__PURE__ */ new Set();\n  return (o) => {\n    const i = o.map((s) => s.id);\n    (e.size !== i.length || i.some((s) => !e.has(s))) && t.set(i), e = new Set(i);\n  };\n}, Dt = (t, e, n, o) => {\n  const { store: i, selection: s, hover: a } = e;\n  let r, d, f;\n  const h = Pe(n), u = (B) => {\n    const { x: T, y: m } = t.getBoundingClientRect(), A = i.getAt(B.clientX - T, B.clientY - m, !1, d);\n    A ? a.current !== A.id && (t.classList.add(\"hovered\"), a.set(A.id)) : a.current && (t.classList.remove(\"hovered\"), a.set(null));\n  };\n  t.addEventListener(\"pointermove\", u);\n  const g = (B = !1) => {\n    f && f.clear();\n    const T = Xe(t), { minX: m, minY: A, maxX: w, maxY: L } = T, M = d ? i.getIntersecting(m, A, w, L).filter(({ annotation: U }) => d(U)) : i.getIntersecting(m, A, w, L), R = s.selected.map(({ id: U }) => U), N = M.map(({ annotation: U, rects: et }) => {\n      const q = R.includes(U.id), Se = U.id === a.current;\n      return { annotation: U, rects: et, state: { selected: q, hover: Se } };\n    });\n    o.redraw(N, T, r, f, B), setTimeout(() => h(M.map(({ annotation: U }) => U)), 1);\n  }, v = (B) => {\n    f = B, g();\n  }, p = (B) => {\n    r = B, g();\n  }, y = (B) => {\n    d = B, g(!1);\n  }, x = () => g();\n  i.observe(x);\n  const l = s.subscribe(() => g()), c = () => g(!0);\n  document.addEventListener(\"scroll\", c, { capture: !0, passive: !0 });\n  const b = Yt(() => {\n    i.recalculatePositions(), f && f.reset(), g();\n  });\n  window.addEventListener(\"resize\", b);\n  const S = new ResizeObserver(b);\n  S.observe(t);\n  const E = { attributes: !0, childList: !0, subtree: !0 }, C = new MutationObserver((B) => {\n    B.every((m) => m.target === t || t.contains(m.target)) || g(!0);\n  });\n  return C.observe(document.body, E), {\n    destroy: () => {\n      t.removeEventListener(\"pointermove\", u), o.destroy(), i.unobserve(x), l(), document.removeEventListener(\"scroll\", c), window.removeEventListener(\"resize\", b), S.disconnect(), C.disconnect();\n    },\n    redraw: g,\n    setStyle: p,\n    setFilter: y,\n    setPainter: v,\n    setVisible: o.setVisible\n  };\n}, $e = () => {\n  const t = document.createElement(\"canvas\");\n  return t.width = window.innerWidth, t.height = window.innerHeight, t.className = \"r6o-canvas-highlight-layer bg\", t;\n}, He = (t, e) => {\n  t.width = window.innerWidth, t.height = window.innerHeight;\n}, je = (t) => {\n  t.classList.add(\"r6o-annotatable\");\n  const e = $e(), n = e.getContext(\"2d\");\n  document.body.appendChild(e);\n  const o = (r, d, f, h) => requestAnimationFrame(() => {\n    const { width: u, height: g } = e;\n    n.clearRect(-0.5, -0.5, u + 1, g + 1), h && h.clear();\n    const { top: v, left: p } = d;\n    [...r].sort((x, l) => {\n      const { annotation: { target: { created: c } } } = x, { annotation: { target: { created: b } } } = l;\n      return c.getTime() - b.getTime();\n    }).forEach((x) => {\n      var S;\n      const l = f ? typeof f == \"function\" ? f(x.annotation, x.state) : f : (S = x.state) != null && S.selected ? At : W, c = h && h.paint(x, d) || l, b = x.rects.map(({ x: E, y: C, width: O, height: B }) => ({\n        x: E + p,\n        y: C + v,\n        width: O,\n        height: B\n      }));\n      if (n.fillStyle = c.fill, n.globalAlpha = c.fillOpacity || 1, b.forEach(\n        ({ x: E, y: C, width: O, height: B }) => n.fillRect(E, C, O, B)\n      ), c.underlineColor) {\n        n.globalAlpha = 1, n.strokeStyle = c.underlineColor, n.lineWidth = c.underlineThickness ?? 1;\n        const E = c.underlineOffset ?? 0;\n        b.forEach(({ x: C, y: O, width: B, height: T }) => {\n          n.beginPath(), n.moveTo(C, O + T + E), n.lineTo(C + B, O + T + E), n.stroke();\n        });\n      }\n    });\n  }), i = Yt(() => {\n    He(e);\n  });\n  return window.addEventListener(\"resize\", i), {\n    destroy: () => {\n      e.remove(), window.removeEventListener(\"resize\", i);\n    },\n    setVisible: (r) => {\n      console.log(\"setVisible not implemented on Canvas renderer\");\n    },\n    redraw: o\n  };\n}, ze = (t, e, n) => Dt(t, e, n, je(t));\nvar Fe = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) }, j = function(t) {\n  return typeof t == \"string\" ? t.length > 0 : typeof t == \"number\";\n}, V = function(t, e, n) {\n  return e === void 0 && (e = 0), n === void 0 && (n = Math.pow(10, e)), Math.round(n * t) / n + 0;\n}, X = function(t, e, n) {\n  return e === void 0 && (e = 0), n === void 0 && (n = 1), t > n ? n : t > e ? t : e;\n}, le = function(t) {\n  return (t = isFinite(t) ? t % 360 : 0) > 0 ? t : t + 360;\n}, Pt = function(t) {\n  return { r: X(t.r, 0, 255), g: X(t.g, 0, 255), b: X(t.b, 0, 255), a: X(t.a) };\n}, Et = function(t) {\n  return { r: V(t.r), g: V(t.g), b: V(t.b), a: V(t.a, 3) };\n}, We = /^#([0-9a-f]{3,8})$/i, ht = function(t) {\n  var e = t.toString(16);\n  return e.length < 2 ? \"0\" + e : e;\n}, de = function(t) {\n  var e = t.r, n = t.g, o = t.b, i = t.a, s = Math.max(e, n, o), a = s - Math.min(e, n, o), r = a ? s === e ? (n - o) / a : s === n ? 2 + (o - e) / a : 4 + (e - n) / a : 0;\n  return { h: 60 * (r < 0 ? r + 6 : r), s: s ? a / s * 100 : 0, v: s / 255 * 100, a: i };\n}, ue = function(t) {\n  var e = t.h, n = t.s, o = t.v, i = t.a;\n  e = e / 360 * 6, n /= 100, o /= 100;\n  var s = Math.floor(e), a = o * (1 - n), r = o * (1 - (e - s) * n), d = o * (1 - (1 - e + s) * n), f = s % 6;\n  return { r: 255 * [o, r, a, a, d, o][f], g: 255 * [d, o, o, r, a, a][f], b: 255 * [a, a, d, o, o, r][f], a: i };\n}, $t = function(t) {\n  return { h: le(t.h), s: X(t.s, 0, 100), l: X(t.l, 0, 100), a: X(t.a) };\n}, Ht = function(t) {\n  return { h: V(t.h), s: V(t.s), l: V(t.l), a: V(t.a, 3) };\n}, jt = function(t) {\n  return ue((n = (e = t).s, { h: e.h, s: (n *= ((o = e.l) < 50 ? o : 100 - o) / 100) > 0 ? 2 * n / (o + n) * 100 : 0, v: o + n, a: e.a }));\n  var e, n, o;\n}, at = function(t) {\n  return { h: (e = de(t)).h, s: (i = (200 - (n = e.s)) * (o = e.v) / 100) > 0 && i < 200 ? n * o / 100 / (i <= 100 ? i : 200 - i) * 100 : 0, l: i / 2, a: e.a };\n  var e, n, o, i;\n}, qe = /^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(deg|rad|grad|turn)?\\s*,\\s*([+-]?\\d*\\.?\\d+)%\\s*,\\s*([+-]?\\d*\\.?\\d+)%\\s*(?:,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i, Ge = /^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(deg|rad|grad|turn)?\\s+([+-]?\\d*\\.?\\d+)%\\s+([+-]?\\d*\\.?\\d+)%\\s*(?:\\/\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i, Qe = /^rgba?\\(\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*(?:,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i, Je = /^rgba?\\(\\s*([+-]?\\d*\\.?\\d+)(%)?\\s+([+-]?\\d*\\.?\\d+)(%)?\\s+([+-]?\\d*\\.?\\d+)(%)?\\s*(?:\\/\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i, zt = { string: [[function(t) {\n  var e = We.exec(t);\n  return e ? (t = e[1]).length <= 4 ? { r: parseInt(t[0] + t[0], 16), g: parseInt(t[1] + t[1], 16), b: parseInt(t[2] + t[2], 16), a: t.length === 4 ? V(parseInt(t[3] + t[3], 16) / 255, 2) : 1 } : t.length === 6 || t.length === 8 ? { r: parseInt(t.substr(0, 2), 16), g: parseInt(t.substr(2, 2), 16), b: parseInt(t.substr(4, 2), 16), a: t.length === 8 ? V(parseInt(t.substr(6, 2), 16) / 255, 2) : 1 } : null : null;\n}, \"hex\"], [function(t) {\n  var e = Qe.exec(t) || Je.exec(t);\n  return e ? e[2] !== e[4] || e[4] !== e[6] ? null : Pt({ r: Number(e[1]) / (e[2] ? 100 / 255 : 1), g: Number(e[3]) / (e[4] ? 100 / 255 : 1), b: Number(e[5]) / (e[6] ? 100 / 255 : 1), a: e[7] === void 0 ? 1 : Number(e[7]) / (e[8] ? 100 : 1) }) : null;\n}, \"rgb\"], [function(t) {\n  var e = qe.exec(t) || Ge.exec(t);\n  if (!e) return null;\n  var n, o, i = $t({ h: (n = e[1], o = e[2], o === void 0 && (o = \"deg\"), Number(n) * (Fe[o] || 1)), s: Number(e[3]), l: Number(e[4]), a: e[5] === void 0 ? 1 : Number(e[5]) / (e[6] ? 100 : 1) });\n  return jt(i);\n}, \"hsl\"]], object: [[function(t) {\n  var e = t.r, n = t.g, o = t.b, i = t.a, s = i === void 0 ? 1 : i;\n  return j(e) && j(n) && j(o) ? Pt({ r: Number(e), g: Number(n), b: Number(o), a: Number(s) }) : null;\n}, \"rgb\"], [function(t) {\n  var e = t.h, n = t.s, o = t.l, i = t.a, s = i === void 0 ? 1 : i;\n  if (!j(e) || !j(n) || !j(o)) return null;\n  var a = $t({ h: Number(e), s: Number(n), l: Number(o), a: Number(s) });\n  return jt(a);\n}, \"hsl\"], [function(t) {\n  var e = t.h, n = t.s, o = t.v, i = t.a, s = i === void 0 ? 1 : i;\n  if (!j(e) || !j(n) || !j(o)) return null;\n  var a = function(r) {\n    return { h: le(r.h), s: X(r.s, 0, 100), v: X(r.v, 0, 100), a: X(r.a) };\n  }({ h: Number(e), s: Number(n), v: Number(o), a: Number(s) });\n  return ue(a);\n}, \"hsv\"]] }, Ft = function(t, e) {\n  for (var n = 0; n < e.length; n++) {\n    var o = e[n][0](t);\n    if (o) return [o, e[n][1]];\n  }\n  return [null, void 0];\n}, Ze = function(t) {\n  return typeof t == \"string\" ? Ft(t.trim(), zt.string) : typeof t == \"object\" && t !== null ? Ft(t, zt.object) : [null, void 0];\n}, St = function(t, e) {\n  var n = at(t);\n  return { h: n.h, s: X(n.s + 100 * e, 0, 100), l: n.l, a: n.a };\n}, Ct = function(t) {\n  return (299 * t.r + 587 * t.g + 114 * t.b) / 1e3 / 255;\n}, Wt = function(t, e) {\n  var n = at(t);\n  return { h: n.h, s: n.s, l: X(n.l + 100 * e, 0, 100), a: n.a };\n}, qt = function() {\n  function t(e) {\n    this.parsed = Ze(e)[0], this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 };\n  }\n  return t.prototype.isValid = function() {\n    return this.parsed !== null;\n  }, t.prototype.brightness = function() {\n    return V(Ct(this.rgba), 2);\n  }, t.prototype.isDark = function() {\n    return Ct(this.rgba) < 0.5;\n  }, t.prototype.isLight = function() {\n    return Ct(this.rgba) >= 0.5;\n  }, t.prototype.toHex = function() {\n    return e = Et(this.rgba), n = e.r, o = e.g, i = e.b, a = (s = e.a) < 1 ? ht(V(255 * s)) : \"\", \"#\" + ht(n) + ht(o) + ht(i) + a;\n    var e, n, o, i, s, a;\n  }, t.prototype.toRgb = function() {\n    return Et(this.rgba);\n  }, t.prototype.toRgbString = function() {\n    return e = Et(this.rgba), n = e.r, o = e.g, i = e.b, (s = e.a) < 1 ? \"rgba(\" + n + \", \" + o + \", \" + i + \", \" + s + \")\" : \"rgb(\" + n + \", \" + o + \", \" + i + \")\";\n    var e, n, o, i, s;\n  }, t.prototype.toHsl = function() {\n    return Ht(at(this.rgba));\n  }, t.prototype.toHslString = function() {\n    return e = Ht(at(this.rgba)), n = e.h, o = e.s, i = e.l, (s = e.a) < 1 ? \"hsla(\" + n + \", \" + o + \"%, \" + i + \"%, \" + s + \")\" : \"hsl(\" + n + \", \" + o + \"%, \" + i + \"%)\";\n    var e, n, o, i, s;\n  }, t.prototype.toHsv = function() {\n    return e = de(this.rgba), { h: V(e.h), s: V(e.s), v: V(e.v), a: V(e.a, 3) };\n    var e;\n  }, t.prototype.invert = function() {\n    return $({ r: 255 - (e = this.rgba).r, g: 255 - e.g, b: 255 - e.b, a: e.a });\n    var e;\n  }, t.prototype.saturate = function(e) {\n    return e === void 0 && (e = 0.1), $(St(this.rgba, e));\n  }, t.prototype.desaturate = function(e) {\n    return e === void 0 && (e = 0.1), $(St(this.rgba, -e));\n  }, t.prototype.grayscale = function() {\n    return $(St(this.rgba, -1));\n  }, t.prototype.lighten = function(e) {\n    return e === void 0 && (e = 0.1), $(Wt(this.rgba, e));\n  }, t.prototype.darken = function(e) {\n    return e === void 0 && (e = 0.1), $(Wt(this.rgba, -e));\n  }, t.prototype.rotate = function(e) {\n    return e === void 0 && (e = 15), this.hue(this.hue() + e);\n  }, t.prototype.alpha = function(e) {\n    return typeof e == \"number\" ? $({ r: (n = this.rgba).r, g: n.g, b: n.b, a: e }) : V(this.rgba.a, 3);\n    var n;\n  }, t.prototype.hue = function(e) {\n    var n = at(this.rgba);\n    return typeof e == \"number\" ? $({ h: e, s: n.s, l: n.l, a: n.a }) : V(n.h);\n  }, t.prototype.isEqual = function(e) {\n    return this.toHex() === $(e).toHex();\n  }, t;\n}(), $ = function(t) {\n  return t instanceof qt ? t : new qt(t);\n};\nconst tn = (t) => [\n  `background-color:${$((t == null ? void 0 : t.fill) || W.fill).alpha((t == null ? void 0 : t.fillOpacity) === void 0 ? W.fillOpacity : t.fillOpacity).toHex()}`,\n  t != null && t.underlineThickness ? \"text-decoration:underline\" : void 0,\n  t != null && t.underlineColor ? `text-decoration-color:${t.underlineColor}` : void 0,\n  t != null && t.underlineOffset ? `text-underline-offset:${t.underlineOffset}px` : void 0,\n  t != null && t.underlineThickness ? `text-decoration-thickness:${t.underlineThickness}px` : void 0\n].filter(Boolean).join(\";\"), en = () => {\n  const t = document.createElement(\"style\");\n  document.getElementsByTagName(\"head\")[0].appendChild(t);\n  let e = /* @__PURE__ */ new Set();\n  return {\n    destroy: () => {\n      CSS.highlights.clear(), t.remove();\n    },\n    setVisible: (s) => {\n      console.log(\"setVisible not implemented on CSS Custom Highlights renderer\");\n    },\n    redraw: (s, a, r, d) => {\n      d && d.clear();\n      const f = new Set(s.map((u) => u.annotation.id));\n      Array.from(e).filter((u) => !f.has(u));\n      const h = s.map((u) => {\n        var p;\n        const g = r ? typeof r == \"function\" ? r(u.annotation, u.state) : r : (p = u.state) != null && p.selected ? At : W, v = d && d.paint(u, a) || g;\n        return `::highlight(_${u.annotation.id}) { ${tn(v)} }`;\n      });\n      t.innerHTML = h.join(`\n`), CSS.highlights.clear(), s.forEach(({ annotation: u }) => {\n        const g = u.target.selector.map((p) => p.range), v = new Highlight(...g);\n        CSS.highlights.set(`_${u.id}`, v);\n      }), e = f;\n    }\n  };\n}, nn = (t, e, n) => Dt(t, e, n, en());\nvar Gt = Object.prototype.hasOwnProperty;\nfunction Vt(t, e) {\n  var n, o;\n  if (t === e) return !0;\n  if (t && e && (n = t.constructor) === e.constructor) {\n    if (n === Date) return t.getTime() === e.getTime();\n    if (n === RegExp) return t.toString() === e.toString();\n    if (n === Array) {\n      if ((o = t.length) === e.length)\n        for (; o-- && Vt(t[o], e[o]); ) ;\n      return o === -1;\n    }\n    if (!n || typeof t == \"object\") {\n      o = 0;\n      for (n in t)\n        if (Gt.call(t, n) && ++o && !Gt.call(e, n) || !(n in e) || !Vt(t[n], e[n])) return !1;\n      return Object.keys(e).length === o;\n    }\n  }\n  return t !== t && e !== e;\n}\nconst on = (t, e) => {\n  const n = (s, a) => s.x <= a.x + a.width && s.x + s.width >= a.x && s.y <= a.y + a.height && s.y + s.height >= a.y, o = (s) => s.rects.reduce((a, r) => a + r.width, 0), i = e.filter(({ rects: s }) => s.some((a) => n(t, a)));\n  return i.sort((s, a) => o(a) - o(s)), i.findIndex((s) => s.rects.includes(t));\n}, sn = (t) => {\n  t.classList.add(\"r6o-annotatable\");\n  const e = document.createElement(\"div\");\n  e.className = \"r6o-span-highlight-layer\", t.insertBefore(e, t.firstChild);\n  let n = [];\n  return {\n    destroy: () => {\n      e.remove();\n    },\n    redraw: (a, r, d, f, h) => {\n      const g = !(Vt(n, a) && h);\n      if (!f && !g) return;\n      g && (e.innerHTML = \"\"), [...a].sort((p, y) => {\n        const { annotation: { target: { created: x } } } = p, { annotation: { target: { created: l } } } = y;\n        return x && l ? x.getTime() - l.getTime() : 0;\n      }).forEach((p) => {\n        p.rects.map((y) => {\n          const x = on(y, a), l = Ke(p, r, d, f, x);\n          if (g) {\n            const c = document.createElement(\"span\");\n            c.className = \"r6o-annotation\", c.dataset.annotation = p.annotation.id, c.style.left = `${y.x}px`, c.style.top = `${y.y}px`, c.style.width = `${y.width}px`, c.style.height = `${y.height}px`, c.style.backgroundColor = $((l == null ? void 0 : l.fill) || W.fill).alpha((l == null ? void 0 : l.fillOpacity) === void 0 ? W.fillOpacity : l.fillOpacity).toHex(), l.underlineStyle && (c.style.borderStyle = l.underlineStyle), l.underlineColor && (c.style.borderColor = l.underlineColor), l.underlineThickness && (c.style.borderBottomWidth = `${l.underlineThickness}px`), l.underlineOffset && (c.style.paddingBottom = `${l.underlineOffset}px`), e.appendChild(c);\n          }\n        });\n      }), n = a;\n    },\n    setVisible: (a) => {\n      a ? e.classList.remove(\"hidden\") : e.classList.add(\"hidden\");\n    }\n  };\n}, rn = (t, e, n) => Dt(t, e, n, sn(t)), Y = [];\nfor (let t = 0; t < 256; ++t)\n  Y.push((t + 256).toString(16).slice(1));\nfunction an(t, e = 0) {\n  return (Y[t[e + 0]] + Y[t[e + 1]] + Y[t[e + 2]] + Y[t[e + 3]] + \"-\" + Y[t[e + 4]] + Y[t[e + 5]] + \"-\" + Y[t[e + 6]] + Y[t[e + 7]] + \"-\" + Y[t[e + 8]] + Y[t[e + 9]] + \"-\" + Y[t[e + 10]] + Y[t[e + 11]] + Y[t[e + 12]] + Y[t[e + 13]] + Y[t[e + 14]] + Y[t[e + 15]]).toLowerCase();\n}\nlet Lt;\nconst cn = new Uint8Array(16);\nfunction ln() {\n  if (!Lt) {\n    if (typeof crypto > \"u\" || !crypto.getRandomValues)\n      throw new Error(\"crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported\");\n    Lt = crypto.getRandomValues.bind(crypto);\n  }\n  return Lt(cn);\n}\nconst dn = typeof crypto < \"u\" && crypto.randomUUID && crypto.randomUUID.bind(crypto), Qt = { randomUUID: dn };\nfunction fe(t, e, n) {\n  if (Qt.randomUUID && !e && !t)\n    return Qt.randomUUID();\n  t = t || {};\n  const o = t.random || (t.rng || ln)();\n  return o[6] = o[6] & 15 | 64, o[8] = o[8] & 63 | 128, an(o);\n}\nvar Jt = Object.prototype.hasOwnProperty;\nfunction G(t, e) {\n  var n, o;\n  if (t === e) return !0;\n  if (t && e && (n = t.constructor) === e.constructor) {\n    if (n === Date) return t.getTime() === e.getTime();\n    if (n === RegExp) return t.toString() === e.toString();\n    if (n === Array) {\n      if ((o = t.length) === e.length)\n        for (; o-- && G(t[o], e[o]); ) ;\n      return o === -1;\n    }\n    if (!n || typeof t == \"object\") {\n      o = 0;\n      for (n in t)\n        if (Jt.call(t, n) && ++o && !Jt.call(e, n) || !(n in e) || !G(t[n], e[n])) return !1;\n      return Object.keys(e).length === o;\n    }\n  }\n  return t !== t && e !== e;\n}\nfunction Tt() {\n}\nfunction un(t, e) {\n  return t != t ? e == e : t !== e || t && typeof t == \"object\" || typeof t == \"function\";\n}\nconst Q = [];\nfunction Kt(t, e = Tt) {\n  let n;\n  const o = /* @__PURE__ */ new Set();\n  function i(r) {\n    if (un(t, r) && (t = r, n)) {\n      const d = !Q.length;\n      for (const f of o)\n        f[1](), Q.push(f, t);\n      if (d) {\n        for (let f = 0; f < Q.length; f += 2)\n          Q[f][0](Q[f + 1]);\n        Q.length = 0;\n      }\n    }\n  }\n  function s(r) {\n    i(r(t));\n  }\n  function a(r, d = Tt) {\n    const f = [r, d];\n    return o.add(f), o.size === 1 && (n = e(i, s) || Tt), r(t), () => {\n      o.delete(f), o.size === 0 && n && (n(), n = null);\n    };\n  }\n  return { set: i, update: s, subscribe: a };\n}\nconst fn = (t) => {\n  const { subscribe: e, set: n } = Kt();\n  let o;\n  return e((i) => o = i), t.observe(({ changes: i }) => {\n    if (o) {\n      (i.deleted || []).some((a) => a.id === o) && n(void 0);\n      const s = (i.updated || []).find(({ oldValue: a }) => a.id === o);\n      s && n(s.newValue.id);\n    }\n  }), {\n    get current() {\n      return o;\n    },\n    subscribe: e,\n    set: n\n  };\n};\nvar hn = /* @__PURE__ */ ((t) => (t.EDIT = \"EDIT\", t.SELECT = \"SELECT\", t.NONE = \"NONE\", t))(hn || {});\nconst gt = { selected: [] }, gn = (t, e, n) => {\n  const { subscribe: o, set: i } = Kt(gt);\n  let s = e, a = gt;\n  o((p) => a = p);\n  const r = () => {\n    G(a, gt) || i(gt);\n  }, d = () => {\n    var p;\n    return ((p = a.selected) == null ? void 0 : p.length) === 0;\n  }, f = (p) => {\n    if (d())\n      return !1;\n    const y = typeof p == \"string\" ? p : p.id;\n    return a.selected.some((x) => x.id === y);\n  }, h = (p, y) => {\n    let x;\n    if (Array.isArray(p)) {\n      if (x = p.map((c) => t.getAnnotation(c)).filter(Boolean), x.length < p.length) {\n        console.warn(\"Invalid selection: \" + p.filter((c) => !x.some((b) => b.id === c)));\n        return;\n      }\n    } else {\n      const c = t.getAnnotation(p);\n      if (!c) {\n        console.warn(\"Invalid selection: \" + p);\n        return;\n      }\n      x = [c];\n    }\n    const l = x.reduce((c, b) => {\n      const S = Zt(b, s);\n      return S === \"EDIT\" ? [...c, { id: b.id, editable: !0 }] : S === \"SELECT\" ? [...c, { id: b.id }] : c;\n    }, []);\n    i({ selected: l, event: y });\n  }, u = (p, y) => {\n    const x = Array.isArray(p) ? p : [p], l = x.map((c) => t.getAnnotation(c)).filter((c) => !!c);\n    i({\n      selected: l.map((c) => {\n        const b = y === void 0 ? Zt(c, s) === \"EDIT\" : y;\n        return { id: c.id, editable: b };\n      })\n    }), l.length !== x.length && console.warn(\"Invalid selection\", p);\n  }, g = (p) => {\n    if (d())\n      return !1;\n    const { selected: y } = a;\n    y.some(({ id: x }) => p.includes(x)) && i({ selected: y.filter(({ id: x }) => !p.includes(x)) });\n  }, v = (p) => s = p;\n  return t.observe(\n    ({ changes: p }) => g((p.deleted || []).map((y) => y.id))\n  ), {\n    get event() {\n      return a ? a.event : null;\n    },\n    get selected() {\n      return a ? [...a.selected] : null;\n    },\n    get userSelectAction() {\n      return s;\n    },\n    clear: r,\n    isEmpty: d,\n    isSelected: f,\n    setSelected: u,\n    setUserSelectAction: v,\n    subscribe: o,\n    userSelect: h\n  };\n}, Zt = (t, e, n) => typeof e == \"function\" ? e(t) : e || \"EDIT\", D = [];\nfor (let t = 0; t < 256; ++t)\n  D.push((t + 256).toString(16).slice(1));\nfunction pn(t, e = 0) {\n  return (D[t[e + 0]] + D[t[e + 1]] + D[t[e + 2]] + D[t[e + 3]] + \"-\" + D[t[e + 4]] + D[t[e + 5]] + \"-\" + D[t[e + 6]] + D[t[e + 7]] + \"-\" + D[t[e + 8]] + D[t[e + 9]] + \"-\" + D[t[e + 10]] + D[t[e + 11]] + D[t[e + 12]] + D[t[e + 13]] + D[t[e + 14]] + D[t[e + 15]]).toLowerCase();\n}\nlet Ot;\nconst mn = new Uint8Array(16);\nfunction yn() {\n  if (!Ot) {\n    if (typeof crypto > \"u\" || !crypto.getRandomValues)\n      throw new Error(\"crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported\");\n    Ot = crypto.getRandomValues.bind(crypto);\n  }\n  return Ot(mn);\n}\nconst bn = typeof crypto < \"u\" && crypto.randomUUID && crypto.randomUUID.bind(crypto), te = { randomUUID: bn };\nfunction he(t, e, n) {\n  if (te.randomUUID && !e && !t)\n    return te.randomUUID();\n  t = t || {};\n  const o = t.random || (t.rng || yn)();\n  return o[6] = o[6] & 15 | 64, o[8] = o[8] & 63 | 128, pn(o);\n}\nconst Bt = (t) => {\n  const e = (n) => {\n    const o = { ...n };\n    return n.created && typeof n.created == \"string\" && (o.created = new Date(n.created)), n.updated && typeof n.updated == \"string\" && (o.updated = new Date(n.updated)), o;\n  };\n  return {\n    ...t,\n    bodies: (t.bodies || []).map(e),\n    target: e(t.target)\n  };\n}, Ao = (t, e, n, o) => ({\n  id: he(),\n  annotation: typeof t == \"string\" ? t : t.id,\n  created: n || /* @__PURE__ */ new Date(),\n  creator: o,\n  ...e\n}), wn = (t, e) => {\n  const n = new Set(t.bodies.map((o) => o.id));\n  return e.bodies.filter((o) => !n.has(o.id));\n}, An = (t, e) => {\n  const n = new Set(e.bodies.map((o) => o.id));\n  return t.bodies.filter((o) => !n.has(o.id));\n}, xn = (t, e) => e.bodies.map((n) => {\n  const o = t.bodies.find((i) => i.id === n.id);\n  return { newBody: n, oldBody: o && !G(o, n) ? o : void 0 };\n}).filter(({ oldBody: n }) => n).map(({ oldBody: n, newBody: o }) => ({ oldBody: n, newBody: o })), vn = (t, e) => !G(t.target, e.target), ge = (t, e) => {\n  const n = wn(t, e), o = An(t, e), i = xn(t, e);\n  return {\n    oldValue: t,\n    newValue: e,\n    bodiesCreated: n.length > 0 ? n : void 0,\n    bodiesDeleted: o.length > 0 ? o : void 0,\n    bodiesUpdated: i.length > 0 ? i : void 0,\n    targetUpdated: vn(t, e) ? { oldTarget: t.target, newTarget: e.target } : void 0\n  };\n};\nvar k = /* @__PURE__ */ ((t) => (t.LOCAL = \"LOCAL\", t.REMOTE = \"REMOTE\", t.SILENT = \"SILENT\", t))(k || {});\nconst En = (t, e) => {\n  var n, o;\n  const { changes: i, origin: s } = e;\n  if (!(t.options.origin ? t.options.origin === s : s !== \"SILENT\"))\n    return !1;\n  if (t.options.ignore) {\n    const { ignore: a } = t.options, r = (d) => d && d.length > 0;\n    if (!(r(i.created) || r(i.deleted))) {\n      const d = (n = i.updated) == null ? void 0 : n.some((h) => r(h.bodiesCreated) || r(h.bodiesDeleted) || r(h.bodiesUpdated)), f = (o = i.updated) == null ? void 0 : o.some((h) => h.targetUpdated);\n      if (a === \"BODY_ONLY\" && d && !f || a === \"TARGET_ONLY\" && f && !d)\n        return !1;\n    }\n  }\n  if (t.options.annotations) {\n    const a = /* @__PURE__ */ new Set([\n      ...(i.created || []).map((r) => r.id),\n      ...(i.deleted || []).map((r) => r.id),\n      ...(i.updated || []).map(({ oldValue: r }) => r.id)\n    ]);\n    return !!(Array.isArray(t.options.annotations) ? t.options.annotations : [t.options.annotations]).find((r) => a.has(r));\n  } else\n    return !0;\n}, Sn = (t, e) => {\n  const n = new Set((t.created || []).map((u) => u.id)), o = new Set((t.updated || []).map(({ newValue: u }) => u.id)), i = new Set((e.created || []).map((u) => u.id)), s = new Set((e.deleted || []).map((u) => u.id)), a = new Set((e.updated || []).map(({ oldValue: u }) => u.id)), r = new Set((e.updated || []).filter(({ oldValue: u }) => n.has(u.id) || o.has(u.id)).map(({ oldValue: u }) => u.id)), d = [\n    ...(t.created || []).filter((u) => !s.has(u.id)).map((u) => a.has(u.id) ? e.updated.find(({ oldValue: g }) => g.id === u.id).newValue : u),\n    ...e.created || []\n  ], f = [\n    ...(t.deleted || []).filter((u) => !i.has(u.id)),\n    ...(e.deleted || []).filter((u) => !n.has(u.id))\n  ], h = [\n    ...(t.updated || []).filter(({ newValue: u }) => !s.has(u.id)).map((u) => {\n      const { oldValue: g, newValue: v } = u;\n      if (a.has(v.id)) {\n        const p = e.updated.find((y) => y.oldValue.id === v.id).newValue;\n        return ge(g, p);\n      } else\n        return u;\n    }),\n    ...(e.updated || []).filter(({ oldValue: u }) => !r.has(u.id))\n  ];\n  return { created: d, deleted: f, updated: h };\n}, Mt = (t) => {\n  const e = t.id === void 0 ? he() : t.id;\n  return {\n    ...t,\n    id: e,\n    bodies: t.bodies === void 0 ? [] : t.bodies.map((n) => ({\n      ...n,\n      annotation: e\n    })),\n    target: {\n      ...t.target,\n      annotation: e\n    }\n  };\n}, Cn = (t) => t.id !== void 0, Ln = () => {\n  const t = /* @__PURE__ */ new Map(), e = /* @__PURE__ */ new Map(), n = [], o = (m, A = {}) => {\n    n.push({ onChange: m, options: A });\n  }, i = (m) => {\n    const A = n.findIndex((w) => w.onChange == m);\n    A > -1 && n.splice(A, 1);\n  }, s = (m, A) => {\n    const w = {\n      origin: m,\n      changes: {\n        created: A.created || [],\n        updated: A.updated || [],\n        deleted: A.deleted || []\n      },\n      state: [...t.values()]\n    };\n    n.forEach((L) => {\n      En(L, w) && L.onChange(w);\n    });\n  }, a = (m, A = k.LOCAL) => {\n    if (m.id && t.get(m.id))\n      throw Error(`Cannot add annotation ${m.id} - exists already`);\n    {\n      const w = Mt(m);\n      t.set(w.id, w), w.bodies.forEach((L) => e.set(L.id, w.id)), s(A, { created: [w] });\n    }\n  }, r = (m, A) => {\n    const w = Mt(typeof m == \"string\" ? A : m), L = typeof m == \"string\" ? m : m.id, M = L && t.get(L);\n    if (M) {\n      const R = ge(M, w);\n      return L === w.id ? t.set(L, w) : (t.delete(L), t.set(w.id, w)), M.bodies.forEach((N) => e.delete(N.id)), w.bodies.forEach((N) => e.set(N.id, w.id)), R;\n    } else\n      console.warn(`Cannot update annotation ${L} - does not exist`);\n  }, d = (m, A = k.LOCAL, w = k.LOCAL) => {\n    const L = Cn(A) ? w : A, M = r(m, A);\n    M && s(L, { updated: [M] });\n  }, f = (m, A = k.LOCAL) => {\n    const w = m.reduce((L, M) => {\n      const R = r(M);\n      return R ? [...L, R] : L;\n    }, []);\n    w.length > 0 && s(A, { updated: w });\n  }, h = (m, A = k.LOCAL) => {\n    const w = t.get(m.annotation);\n    if (w) {\n      const L = {\n        ...w,\n        bodies: [...w.bodies, m]\n      };\n      t.set(w.id, L), e.set(m.id, L.id), s(A, { updated: [{\n        oldValue: w,\n        newValue: L,\n        bodiesCreated: [m]\n      }] });\n    } else\n      console.warn(`Attempt to add body to missing annotation: ${m.annotation}`);\n  }, u = () => [...t.values()], g = (m = k.LOCAL) => {\n    const A = [...t.values()];\n    t.clear(), e.clear(), s(m, { deleted: A });\n  }, v = (m, A = !0, w = k.LOCAL) => {\n    const L = m.map(Mt);\n    if (A) {\n      const M = [...t.values()];\n      t.clear(), e.clear(), L.forEach((R) => {\n        t.set(R.id, R), R.bodies.forEach((N) => e.set(N.id, R.id));\n      }), s(w, { created: L, deleted: M });\n    } else {\n      const M = m.reduce((R, N) => {\n        const U = N.id && t.get(N.id);\n        return U ? [...R, U] : R;\n      }, []);\n      if (M.length > 0)\n        throw Error(`Bulk insert would overwrite the following annotations: ${M.map((R) => R.id).join(\", \")}`);\n      L.forEach((R) => {\n        t.set(R.id, R), R.bodies.forEach((N) => e.set(N.id, R.id));\n      }), s(w, { created: L });\n    }\n  }, p = (m) => {\n    const A = typeof m == \"string\" ? m : m.id, w = t.get(A);\n    if (w)\n      return t.delete(A), w.bodies.forEach((L) => e.delete(L.id)), w;\n    console.warn(`Attempt to delete missing annotation: ${A}`);\n  }, y = (m, A = k.LOCAL) => {\n    const w = p(m);\n    w && s(A, { deleted: [w] });\n  }, x = (m, A = k.LOCAL) => {\n    const w = m.reduce((L, M) => {\n      const R = p(M);\n      return R ? [...L, R] : L;\n    }, []);\n    w.length > 0 && s(A, { deleted: w });\n  }, l = (m) => {\n    const A = t.get(m.annotation);\n    if (A) {\n      const w = A.bodies.find((L) => L.id === m.id);\n      if (w) {\n        e.delete(w.id);\n        const L = {\n          ...A,\n          bodies: A.bodies.filter((M) => M.id !== m.id)\n        };\n        return t.set(A.id, L), {\n          oldValue: A,\n          newValue: L,\n          bodiesDeleted: [w]\n        };\n      } else\n        console.warn(`Attempt to delete missing body ${m.id} from annotation ${m.annotation}`);\n    } else\n      console.warn(`Attempt to delete body from missing annotation ${m.annotation}`);\n  }, c = (m, A = k.LOCAL) => {\n    const w = l(m);\n    w && s(A, { updated: [w] });\n  }, b = (m, A = k.LOCAL) => {\n    const w = m.map((L) => l(L)).filter(Boolean);\n    w.length > 0 && s(A, { updated: w });\n  }, S = (m) => {\n    const A = t.get(m);\n    return A ? { ...A } : void 0;\n  }, E = (m) => {\n    const A = e.get(m);\n    if (A) {\n      const w = S(A).bodies.find((L) => L.id === m);\n      if (w)\n        return w;\n      console.error(`Store integrity error: body ${m} in index, but not in annotation`);\n    } else\n      console.warn(`Attempt to retrieve missing body: ${m}`);\n  }, C = (m, A) => {\n    if (m.annotation !== A.annotation)\n      throw \"Annotation integrity violation: annotation ID must be the same when updating bodies\";\n    const w = t.get(m.annotation);\n    if (w) {\n      const L = w.bodies.find((R) => R.id === m.id), M = {\n        ...w,\n        bodies: w.bodies.map((R) => R.id === L.id ? A : R)\n      };\n      return t.set(w.id, M), L.id !== A.id && (e.delete(L.id), e.set(A.id, M.id)), {\n        oldValue: w,\n        newValue: M,\n        bodiesUpdated: [{ oldBody: L, newBody: A }]\n      };\n    } else\n      console.warn(`Attempt to add body to missing annotation ${m.annotation}`);\n  }, O = (m, A, w = k.LOCAL) => {\n    const L = C(m, A);\n    L && s(w, { updated: [L] });\n  }, B = (m, A = k.LOCAL) => {\n    const w = m.map((L) => C({ id: L.id, annotation: L.annotation }, L)).filter(Boolean);\n    s(A, { updated: w });\n  }, T = (m) => {\n    const A = t.get(m.annotation);\n    if (A) {\n      const w = {\n        ...A,\n        target: {\n          ...A.target,\n          ...m\n        }\n      };\n      return t.set(A.id, w), {\n        oldValue: A,\n        newValue: w,\n        targetUpdated: {\n          oldTarget: A.target,\n          newTarget: m\n        }\n      };\n    } else\n      console.warn(`Attempt to update target on missing annotation: ${m.annotation}`);\n  };\n  return {\n    addAnnotation: a,\n    addBody: h,\n    all: u,\n    bulkAddAnnotation: v,\n    bulkDeleteAnnotation: x,\n    bulkDeleteBodies: b,\n    bulkUpdateAnnotation: f,\n    bulkUpdateBodies: B,\n    bulkUpdateTargets: (m, A = k.LOCAL) => {\n      const w = m.map((L) => T(L)).filter(Boolean);\n      w.length > 0 && s(A, { updated: w });\n    },\n    clear: g,\n    deleteAnnotation: y,\n    deleteBody: c,\n    getAnnotation: S,\n    getBody: E,\n    observe: o,\n    unobserve: i,\n    updateAnnotation: d,\n    updateBody: O,\n    updateTarget: (m, A = k.LOCAL) => {\n      const w = T(m);\n      w && s(A, { updated: [w] });\n    }\n  };\n};\nlet Tn = () => ({\n  emit(t, ...e) {\n    for (let n = this.events[t] || [], o = 0, i = n.length; o < i; o++)\n      n[o](...e);\n  },\n  events: {},\n  on(t, e) {\n    var n;\n    return ((n = this.events)[t] || (n[t] = [])).push(e), () => {\n      var o;\n      this.events[t] = (o = this.events[t]) == null ? void 0 : o.filter((i) => e !== i);\n    };\n  }\n});\nconst On = 250, Bn = (t, e) => {\n  const n = Tn(), o = [];\n  let i = -1, s = !1, a = 0;\n  const r = (p) => {\n    if (!s) {\n      const { changes: y } = p, x = performance.now();\n      if (x - a > On)\n        o.splice(i + 1), o.push(y), i = o.length - 1;\n      else {\n        const l = o.length - 1;\n        o[l] = Sn(o[l], y);\n      }\n      a = x;\n    }\n    s = !1;\n  };\n  t.observe(r, { origin: k.LOCAL });\n  const d = (p) => p && p.length > 0 && t.bulkDeleteAnnotation(p), f = (p) => p && p.length > 0 && t.bulkAddAnnotation(p, !1), h = (p) => p && p.length > 0 && t.bulkUpdateAnnotation(p.map(({ oldValue: y }) => y)), u = (p) => p && p.length > 0 && t.bulkUpdateAnnotation(p.map(({ newValue: y }) => y)), g = (p) => p && p.length > 0 && t.bulkAddAnnotation(p, !1), v = (p) => p && p.length > 0 && t.bulkDeleteAnnotation(p);\n  return {\n    canRedo: () => o.length - 1 > i,\n    canUndo: () => i > -1,\n    destroy: () => t.unobserve(r),\n    getHistory: () => ({ changes: [...o], pointer: i }),\n    on: (p, y) => n.on(p, y),\n    redo: () => {\n      if (o.length - 1 > i) {\n        s = !0;\n        const { created: p, updated: y, deleted: x } = o[i + 1];\n        f(p), u(y), v(x), n.emit(\"redo\", o[i + 1]), i += 1;\n      }\n    },\n    undo: () => {\n      if (i > -1) {\n        s = !0;\n        const { created: p, updated: y, deleted: x } = o[i];\n        d(p), h(y), g(x), n.emit(\"undo\", o[i]), i -= 1;\n      }\n    }\n  };\n}, Mn = () => {\n  const { subscribe: t, set: e } = Kt([]);\n  return {\n    subscribe: t,\n    set: e\n  };\n}, Rn = (t, e, n, o) => {\n  const { hover: i, selection: s, store: a, viewport: r } = t, d = /* @__PURE__ */ new Map();\n  let f = [], h;\n  const u = (y, x) => {\n    d.has(y) ? d.get(y).push(x) : d.set(y, [x]);\n  }, g = (y, x) => {\n    const l = d.get(y);\n    if (l) {\n      const c = l.indexOf(x);\n      c !== -1 && l.splice(c, 1);\n    }\n  }, v = (y, x, l) => {\n    d.has(y) && setTimeout(() => {\n      d.get(y).forEach((c) => {\n        if (n) {\n          const b = Array.isArray(x) ? x.map((E) => n.serialize(E)) : n.serialize(x), S = l ? l instanceof PointerEvent ? l : n.serialize(l) : void 0;\n          c(b, S);\n        } else\n          c(x, l);\n      });\n    }, 1);\n  };\n  s.subscribe(({ selected: y }) => {\n    if (!(f.length === 0 && y.length === 0)) {\n      if (f.length === 0 && y.length > 0)\n        f = y.map(({ id: x }) => a.getAnnotation(x));\n      else if (f.length > 0 && y.length === 0)\n        f.forEach((x) => {\n          const l = a.getAnnotation(x.id);\n          l && !G(l, x) && v(\"updateAnnotation\", l, x);\n        }), f = [];\n      else {\n        const x = new Set(f.map((c) => c.id)), l = new Set(y.map(({ id: c }) => c));\n        f.filter((c) => !l.has(c.id)).forEach((c) => {\n          const b = a.getAnnotation(c.id);\n          b && !G(b, c) && v(\"updateAnnotation\", b, c);\n        }), f = [\n          // Remove annotations that were deselected\n          ...f.filter((c) => l.has(c.id)),\n          // Add editable annotations that were selected\n          ...y.filter(({ id: c }) => !x.has(c)).map(({ id: c }) => a.getAnnotation(c))\n        ];\n      }\n      v(\"selectionChanged\", f);\n    }\n  }), i.subscribe((y) => {\n    !h && y ? v(\"mouseEnterAnnotation\", a.getAnnotation(y)) : h && !y ? v(\"mouseLeaveAnnotation\", a.getAnnotation(h)) : h && y && (v(\"mouseLeaveAnnotation\", a.getAnnotation(h)), v(\"mouseEnterAnnotation\", a.getAnnotation(y))), h = y;\n  }), r == null || r.subscribe((y) => v(\"viewportIntersect\", y.map((x) => a.getAnnotation(x)))), a.observe((y) => {\n    const { created: x, deleted: l } = y.changes;\n    (x || []).forEach((c) => v(\"createAnnotation\", c)), (l || []).forEach((c) => v(\"deleteAnnotation\", c)), (y.changes.updated || []).filter((c) => [\n      ...c.bodiesCreated || [],\n      ...c.bodiesDeleted || [],\n      ...c.bodiesUpdated || []\n    ].length > 0).forEach(({ oldValue: c, newValue: b }) => {\n      const S = f.find((E) => E.id === c.id) || c;\n      f = f.map((E) => E.id === c.id ? b : E), v(\"updateAnnotation\", b, S);\n    });\n  }, { origin: k.LOCAL }), a.observe((y) => {\n    if (f) {\n      const x = new Set(f.map((c) => c.id)), l = (y.changes.updated || []).filter(({ newValue: c }) => x.has(c.id)).map(({ newValue: c }) => c);\n      l.length > 0 && (f = f.map((c) => l.find((S) => S.id === c.id) || c));\n    }\n  }, { origin: k.REMOTE });\n  const p = (y) => (x) => {\n    const { updated: l } = x;\n    y ? (l || []).forEach((c) => v(\"updateAnnotation\", c.oldValue, c.newValue)) : (l || []).forEach((c) => v(\"updateAnnotation\", c.newValue, c.oldValue));\n  };\n  return e.on(\"undo\", p(!0)), e.on(\"redo\", p(!1)), { on: u, off: g, emit: v };\n}, kn = (t) => (e) => e.reduce((n, o) => {\n  const { parsed: i, error: s } = t.parse(o);\n  return s ? {\n    parsed: n.parsed,\n    failed: [...n.failed, o]\n  } : i ? {\n    parsed: [...n.parsed, i],\n    failed: n.failed\n  } : {\n    ...n\n  };\n}, { parsed: [], failed: [] }), In = (t, e, n) => {\n  const { store: o, selection: i } = t, s = (l) => {\n    if (n) {\n      const { parsed: c, error: b } = n.parse(l);\n      c ? o.addAnnotation(c, k.REMOTE) : console.error(b);\n    } else\n      o.addAnnotation(Bt(l), k.REMOTE);\n  }, a = () => i.clear(), r = () => o.clear(), d = (l) => {\n    const c = o.getAnnotation(l);\n    return n && c ? n.serialize(c) : c;\n  }, f = () => n ? o.all().map(n.serialize) : o.all(), h = () => {\n    var l;\n    const c = (((l = i.selected) == null ? void 0 : l.map((b) => b.id)) || []).map((b) => o.getAnnotation(b)).filter(Boolean);\n    return n ? c.map(n.serialize) : c;\n  }, u = (l, c = !0) => fetch(l).then((b) => b.json()).then((b) => (v(b, c), b)), g = (l) => {\n    if (typeof l == \"string\") {\n      const c = o.getAnnotation(l);\n      if (o.deleteAnnotation(l), c)\n        return n ? n.serialize(c) : c;\n    } else {\n      const c = n ? n.parse(l).parsed : l;\n      if (c)\n        return o.deleteAnnotation(c), l;\n    }\n  }, v = (l, c = !0) => {\n    if (n) {\n      const b = n.parseAll || kn(n), { parsed: S, failed: E } = b(l);\n      E.length > 0 && console.warn(`Discarded ${E.length} invalid annotations`, E), o.bulkAddAnnotation(S, c, k.REMOTE);\n    } else\n      o.bulkAddAnnotation(l.map(Bt), c, k.REMOTE);\n  }, p = (l, c) => {\n    l ? i.setSelected(l, c) : i.clear();\n  }, y = (l) => {\n    i.clear(), i.setUserSelectAction(l);\n  }, x = (l) => {\n    if (n) {\n      const c = n.parse(l).parsed, b = n.serialize(o.getAnnotation(c.id));\n      return o.updateAnnotation(c), b;\n    } else {\n      const c = o.getAnnotation(l.id);\n      return o.updateAnnotation(Bt(l)), c;\n    }\n  };\n  return {\n    addAnnotation: s,\n    cancelSelected: a,\n    canRedo: e.canRedo,\n    canUndo: e.canUndo,\n    clearAnnotations: r,\n    getAnnotationById: d,\n    getAnnotations: f,\n    getHistory: e.getHistory,\n    getSelected: h,\n    loadAnnotations: u,\n    redo: e.redo,\n    removeAnnotation: g,\n    setAnnotations: v,\n    setSelected: p,\n    setUserSelectAction: y,\n    undo: e.undo,\n    updateAnnotation: x\n  };\n}, _n = \"useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict\";\nlet Nn = (t) => crypto.getRandomValues(new Uint8Array(t)), Un = (t, e, n) => {\n  let o = (2 << Math.log2(t.length - 1)) - 1, i = -~(1.6 * o * e / t.length);\n  return (s = e) => {\n    let a = \"\";\n    for (; ; ) {\n      let r = n(i), d = i | 0;\n      for (; d--; )\n        if (a += t[r[d] & o] || \"\", a.length >= s) return a;\n    }\n  };\n}, Vn = (t, e = 21) => Un(t, e | 0, Nn), Yn = (t = 21) => {\n  let e = \"\", n = crypto.getRandomValues(new Uint8Array(t |= 0));\n  for (; t--; )\n    e += _n[n[t] & 63];\n  return e;\n};\nconst Dn = () => ({ isGuest: !0, id: Vn(\"1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_\", 20)() }), Kn = (t) => {\n  const e = JSON.stringify(t);\n  let n = 0;\n  for (let o = 0, i = e.length; o < i; o++) {\n    let s = e.charCodeAt(o);\n    n = (n << 5) - n + s, n |= 0;\n  }\n  return `${n}`;\n}, pe = (t) => t ? typeof t == \"object\" ? { ...t } : t : void 0, Xn = (t, e) => (Array.isArray(t) ? t : [t]).map((n) => {\n  const { id: o, type: i, purpose: s, value: a, created: r, modified: d, creator: f, ...h } = n;\n  return {\n    id: o || `temp-${Kn(n)}`,\n    annotation: e,\n    type: i,\n    purpose: s,\n    value: a,\n    creator: pe(f),\n    created: r ? new Date(r) : void 0,\n    updated: d ? new Date(d) : void 0,\n    ...h\n  };\n}), Pn = (t) => t.map((e) => {\n  var n;\n  const { annotation: o, created: i, updated: s, ...a } = e, r = {\n    ...a,\n    created: i == null ? void 0 : i.toISOString(),\n    modified: s == null ? void 0 : s.toISOString()\n  };\n  return (n = r.id) != null && n.startsWith(\"temp-\") && delete r.id, r;\n});\nYn();\nconst xo = (t, e) => ({\n  parse: (n) => jn(n),\n  serialize: (n) => zn(n, t, e)\n}), $n = (t) => t.quote !== void 0 && t.start !== void 0 && t.end !== void 0, Hn = (t) => {\n  const {\n    id: e,\n    creator: n,\n    created: o,\n    modified: i,\n    target: s\n  } = t, a = Array.isArray(s) ? s : [s];\n  if (a.length === 0)\n    return { error: Error(`No targets found for annotation: ${t.id}`) };\n  const r = {\n    creator: pe(n),\n    created: o ? new Date(o) : void 0,\n    updated: i ? new Date(i) : void 0,\n    annotation: e,\n    selector: [],\n    // @ts-expect-error: `styleClass` is not part of the core `TextAnnotationTarget` type\n    styleClass: \"styleClass\" in a[0] ? a[0].styleClass : void 0\n  };\n  for (const d of a) {\n    const h = (Array.isArray(d.selector) ? d.selector : [d.selector]).reduce((u, g) => {\n      switch (g.type) {\n        case \"TextQuoteSelector\":\n          u.quote = g.exact;\n          break;\n        case \"TextPositionSelector\":\n          u.start = g.start, u.end = g.end;\n          break;\n      }\n      return u;\n    }, {});\n    if ($n(h))\n      r.selector.push(\n        {\n          ...h,\n          id: d.id,\n          // @ts-expect-error: `scope` is not part of the core `TextSelector` type\n          scope: d.scope\n        }\n      );\n    else {\n      const u = [\n        h.start ? void 0 : \"TextPositionSelector\",\n        h.quote ? void 0 : \"TextQuoteSelector\"\n      ].filter(Boolean);\n      return { error: Error(`Missing selector types: ${u.join(\" and \")} for annotation: ${t.id}`) };\n    }\n  }\n  return { parsed: r };\n}, jn = (t) => {\n  const e = t.id || fe(), {\n    creator: n,\n    created: o,\n    modified: i,\n    body: s,\n    ...a\n  } = t, r = Xn(s, e), d = Hn(t);\n  return \"error\" in d ? { error: d.error } : {\n    parsed: {\n      ...a,\n      id: e,\n      bodies: r,\n      target: d.parsed\n    }\n  };\n}, zn = (t, e, n) => {\n  const { bodies: o, target: i, ...s } = t, {\n    selector: a,\n    creator: r,\n    created: d,\n    updated: f,\n    ...h\n  } = i, u = a.map((g) => {\n    const { id: v, quote: p, start: y, end: x, range: l } = g, { prefix: c, suffix: b } = Re(l, n), S = [{\n      type: \"TextQuoteSelector\",\n      exact: p,\n      prefix: c,\n      suffix: b\n    }, {\n      type: \"TextPositionSelector\",\n      start: y,\n      end: x\n    }];\n    return {\n      ...h,\n      id: v,\n      // @ts-expect-error: `scope` is not part of the core `TextSelector` type\n      scope: \"scope\" in g ? g.scope : void 0,\n      source: e,\n      selector: S\n    };\n  });\n  return {\n    ...s,\n    \"@context\": \"http://www.w3.org/ns/anno.jsonld\",\n    id: t.id,\n    type: \"Annotation\",\n    body: Pn(t.bodies),\n    creator: r,\n    created: d == null ? void 0 : d.toISOString(),\n    modified: f == null ? void 0 : f.toISOString(),\n    target: u\n  };\n};\nfunction me(t, e, n = 0, o = t.length - 1, i = Fn) {\n  for (; o > n; ) {\n    if (o - n > 600) {\n      const d = o - n + 1, f = e - n + 1, h = Math.log(d), u = 0.5 * Math.exp(2 * h / 3), g = 0.5 * Math.sqrt(h * u * (d - u) / d) * (f - d / 2 < 0 ? -1 : 1), v = Math.max(n, Math.floor(e - f * u / d + g)), p = Math.min(o, Math.floor(e + (d - f) * u / d + g));\n      me(t, e, v, p, i);\n    }\n    const s = t[e];\n    let a = n, r = o;\n    for (nt(t, n, e), i(t[o], s) > 0 && nt(t, n, o); a < r; ) {\n      for (nt(t, a, r), a++, r--; i(t[a], s) < 0; ) a++;\n      for (; i(t[r], s) > 0; ) r--;\n    }\n    i(t[n], s) === 0 ? nt(t, n, r) : (r++, nt(t, r, o)), r <= e && (n = r + 1), e <= r && (o = r - 1);\n  }\n}\nfunction nt(t, e, n) {\n  const o = t[e];\n  t[e] = t[n], t[n] = o;\n}\nfunction Fn(t, e) {\n  return t < e ? -1 : t > e ? 1 : 0;\n}\nclass Wn {\n  constructor(e = 9) {\n    this._maxEntries = Math.max(4, e), this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4)), this.clear();\n  }\n  all() {\n    return this._all(this.data, []);\n  }\n  search(e) {\n    let n = this.data;\n    const o = [];\n    if (!mt(e, n)) return o;\n    const i = this.toBBox, s = [];\n    for (; n; ) {\n      for (let a = 0; a < n.children.length; a++) {\n        const r = n.children[a], d = n.leaf ? i(r) : r;\n        mt(e, d) && (n.leaf ? o.push(r) : kt(e, d) ? this._all(r, o) : s.push(r));\n      }\n      n = s.pop();\n    }\n    return o;\n  }\n  collides(e) {\n    let n = this.data;\n    if (!mt(e, n)) return !1;\n    const o = [];\n    for (; n; ) {\n      for (let i = 0; i < n.children.length; i++) {\n        const s = n.children[i], a = n.leaf ? this.toBBox(s) : s;\n        if (mt(e, a)) {\n          if (n.leaf || kt(e, a)) return !0;\n          o.push(s);\n        }\n      }\n      n = o.pop();\n    }\n    return !1;\n  }\n  load(e) {\n    if (!(e && e.length)) return this;\n    if (e.length < this._minEntries) {\n      for (let o = 0; o < e.length; o++)\n        this.insert(e[o]);\n      return this;\n    }\n    let n = this._build(e.slice(), 0, e.length - 1, 0);\n    if (!this.data.children.length)\n      this.data = n;\n    else if (this.data.height === n.height)\n      this._splitRoot(this.data, n);\n    else {\n      if (this.data.height < n.height) {\n        const o = this.data;\n        this.data = n, n = o;\n      }\n      this._insert(n, this.data.height - n.height - 1, !0);\n    }\n    return this;\n  }\n  insert(e) {\n    return e && this._insert(e, this.data.height - 1), this;\n  }\n  clear() {\n    return this.data = Z([]), this;\n  }\n  remove(e, n) {\n    if (!e) return this;\n    let o = this.data;\n    const i = this.toBBox(e), s = [], a = [];\n    let r, d, f;\n    for (; o || s.length; ) {\n      if (o || (o = s.pop(), d = s[s.length - 1], r = a.pop(), f = !0), o.leaf) {\n        const h = qn(e, o.children, n);\n        if (h !== -1)\n          return o.children.splice(h, 1), s.push(o), this._condense(s), this;\n      }\n      !f && !o.leaf && kt(o, i) ? (s.push(o), a.push(r), r = 0, d = o, o = o.children[0]) : d ? (r++, o = d.children[r], f = !1) : o = null;\n    }\n    return this;\n  }\n  toBBox(e) {\n    return e;\n  }\n  compareMinX(e, n) {\n    return e.minX - n.minX;\n  }\n  compareMinY(e, n) {\n    return e.minY - n.minY;\n  }\n  toJSON() {\n    return this.data;\n  }\n  fromJSON(e) {\n    return this.data = e, this;\n  }\n  _all(e, n) {\n    const o = [];\n    for (; e; )\n      e.leaf ? n.push(...e.children) : o.push(...e.children), e = o.pop();\n    return n;\n  }\n  _build(e, n, o, i) {\n    const s = o - n + 1;\n    let a = this._maxEntries, r;\n    if (s <= a)\n      return r = Z(e.slice(n, o + 1)), J(r, this.toBBox), r;\n    i || (i = Math.ceil(Math.log(s) / Math.log(a)), a = Math.ceil(s / Math.pow(a, i - 1))), r = Z([]), r.leaf = !1, r.height = i;\n    const d = Math.ceil(s / a), f = d * Math.ceil(Math.sqrt(a));\n    ee(e, n, o, f, this.compareMinX);\n    for (let h = n; h <= o; h += f) {\n      const u = Math.min(h + f - 1, o);\n      ee(e, h, u, d, this.compareMinY);\n      for (let g = h; g <= u; g += d) {\n        const v = Math.min(g + d - 1, u);\n        r.children.push(this._build(e, g, v, i - 1));\n      }\n    }\n    return J(r, this.toBBox), r;\n  }\n  _chooseSubtree(e, n, o, i) {\n    for (; i.push(n), !(n.leaf || i.length - 1 === o); ) {\n      let s = 1 / 0, a = 1 / 0, r;\n      for (let d = 0; d < n.children.length; d++) {\n        const f = n.children[d], h = Rt(f), u = Jn(e, f) - h;\n        u < a ? (a = u, s = h < s ? h : s, r = f) : u === a && h < s && (s = h, r = f);\n      }\n      n = r || n.children[0];\n    }\n    return n;\n  }\n  _insert(e, n, o) {\n    const i = o ? e : this.toBBox(e), s = [], a = this._chooseSubtree(i, this.data, n, s);\n    for (a.children.push(e), rt(a, i); n >= 0 && s[n].children.length > this._maxEntries; )\n      this._split(s, n), n--;\n    this._adjustParentBBoxes(i, s, n);\n  }\n  // split overflowed node into two\n  _split(e, n) {\n    const o = e[n], i = o.children.length, s = this._minEntries;\n    this._chooseSplitAxis(o, s, i);\n    const a = this._chooseSplitIndex(o, s, i), r = Z(o.children.splice(a, o.children.length - a));\n    r.height = o.height, r.leaf = o.leaf, J(o, this.toBBox), J(r, this.toBBox), n ? e[n - 1].children.push(r) : this._splitRoot(o, r);\n  }\n  _splitRoot(e, n) {\n    this.data = Z([e, n]), this.data.height = e.height + 1, this.data.leaf = !1, J(this.data, this.toBBox);\n  }\n  _chooseSplitIndex(e, n, o) {\n    let i, s = 1 / 0, a = 1 / 0;\n    for (let r = n; r <= o - n; r++) {\n      const d = st(e, 0, r, this.toBBox), f = st(e, r, o, this.toBBox), h = Zn(d, f), u = Rt(d) + Rt(f);\n      h < s ? (s = h, i = r, a = u < a ? u : a) : h === s && u < a && (a = u, i = r);\n    }\n    return i || o - n;\n  }\n  // sorts node children by the best axis for split\n  _chooseSplitAxis(e, n, o) {\n    const i = e.leaf ? this.compareMinX : Gn, s = e.leaf ? this.compareMinY : Qn, a = this._allDistMargin(e, n, o, i), r = this._allDistMargin(e, n, o, s);\n    a < r && e.children.sort(i);\n  }\n  // total margin of all possible split distributions where each node is at least m full\n  _allDistMargin(e, n, o, i) {\n    e.children.sort(i);\n    const s = this.toBBox, a = st(e, 0, n, s), r = st(e, o - n, o, s);\n    let d = pt(a) + pt(r);\n    for (let f = n; f < o - n; f++) {\n      const h = e.children[f];\n      rt(a, e.leaf ? s(h) : h), d += pt(a);\n    }\n    for (let f = o - n - 1; f >= n; f--) {\n      const h = e.children[f];\n      rt(r, e.leaf ? s(h) : h), d += pt(r);\n    }\n    return d;\n  }\n  _adjustParentBBoxes(e, n, o) {\n    for (let i = o; i >= 0; i--)\n      rt(n[i], e);\n  }\n  _condense(e) {\n    for (let n = e.length - 1, o; n >= 0; n--)\n      e[n].children.length === 0 ? n > 0 ? (o = e[n - 1].children, o.splice(o.indexOf(e[n]), 1)) : this.clear() : J(e[n], this.toBBox);\n  }\n}\nfunction qn(t, e, n) {\n  if (!n) return e.indexOf(t);\n  for (let o = 0; o < e.length; o++)\n    if (n(t, e[o])) return o;\n  return -1;\n}\nfunction J(t, e) {\n  st(t, 0, t.children.length, e, t);\n}\nfunction st(t, e, n, o, i) {\n  i || (i = Z(null)), i.minX = 1 / 0, i.minY = 1 / 0, i.maxX = -1 / 0, i.maxY = -1 / 0;\n  for (let s = e; s < n; s++) {\n    const a = t.children[s];\n    rt(i, t.leaf ? o(a) : a);\n  }\n  return i;\n}\nfunction rt(t, e) {\n  return t.minX = Math.min(t.minX, e.minX), t.minY = Math.min(t.minY, e.minY), t.maxX = Math.max(t.maxX, e.maxX), t.maxY = Math.max(t.maxY, e.maxY), t;\n}\nfunction Gn(t, e) {\n  return t.minX - e.minX;\n}\nfunction Qn(t, e) {\n  return t.minY - e.minY;\n}\nfunction Rt(t) {\n  return (t.maxX - t.minX) * (t.maxY - t.minY);\n}\nfunction pt(t) {\n  return t.maxX - t.minX + (t.maxY - t.minY);\n}\nfunction Jn(t, e) {\n  return (Math.max(e.maxX, t.maxX) - Math.min(e.minX, t.minX)) * (Math.max(e.maxY, t.maxY) - Math.min(e.minY, t.minY));\n}\nfunction Zn(t, e) {\n  const n = Math.max(t.minX, e.minX), o = Math.max(t.minY, e.minY), i = Math.min(t.maxX, e.maxX), s = Math.min(t.maxY, e.maxY);\n  return Math.max(0, i - n) * Math.max(0, s - o);\n}\nfunction kt(t, e) {\n  return t.minX <= e.minX && t.minY <= e.minY && e.maxX <= t.maxX && e.maxY <= t.maxY;\n}\nfunction mt(t, e) {\n  return e.minX <= t.maxX && e.minY <= t.maxY && e.maxX >= t.minX && e.maxY >= t.minY;\n}\nfunction Z(t) {\n  return {\n    children: t,\n    height: 1,\n    leaf: !0,\n    minX: 1 / 0,\n    minY: 1 / 0,\n    maxX: -1 / 0,\n    maxY: -1 / 0\n  };\n}\nfunction ee(t, e, n, o, i) {\n  const s = [e, n];\n  for (; s.length; ) {\n    if (n = s.pop(), e = s.pop(), n - e <= o) continue;\n    const a = e + Math.ceil((n - e) / o / 2) * o;\n    me(t, a, e, n, i), s.push(e, a, a, n);\n  }\n}\nconst to = (t, e) => {\n  const n = new Wn(), o = /* @__PURE__ */ new Map(), i = (l, c) => {\n    const b = l.selector.flatMap((E) => {\n      const C = F([E]) ? E.range : ae(E, e).range;\n      return Array.from(C.getClientRects());\n    }), S = Ue(b).map(({ left: E, top: C, right: O, bottom: B }) => new DOMRect(E - c.left, C - c.top, O - E, B - C));\n    return S.map((E) => {\n      const { x: C, y: O, width: B, height: T } = E;\n      return {\n        minX: C,\n        minY: O,\n        maxX: C + B,\n        maxY: O + T,\n        annotation: {\n          id: l.annotation,\n          rects: S\n        }\n      };\n    });\n  }, s = () => [...o.values()], a = () => {\n    n.clear(), o.clear();\n  }, r = (l) => {\n    const c = i(l, e.getBoundingClientRect());\n    c.length !== 0 && (c.forEach((b) => n.insert(b)), o.set(l.annotation, c));\n  }, d = (l) => {\n    const c = o.get(l.annotation);\n    c && (c.forEach((b) => n.remove(b)), o.delete(l.annotation));\n  }, f = (l) => {\n    d(l), r(l);\n  }, h = (l, c = !0) => {\n    c && a();\n    const b = e.getBoundingClientRect(), S = l.map((C) => ({ target: C, rects: i(C, b) }));\n    S.forEach(({ target: C, rects: O }) => {\n      O.length > 0 && o.set(C.annotation, O);\n    });\n    const E = S.flatMap(({ rects: C }) => C);\n    n.load(E);\n  }, u = (l, c, b = !1) => {\n    const S = n.search({\n      minX: l,\n      minY: c,\n      maxX: l,\n      maxY: c\n    }), E = (C) => C.annotation.rects.reduce((O, B) => O + B.width * B.height, 0);\n    return S.length > 0 ? (S.sort((C, O) => E(C) - E(O)), b ? S.map((C) => C.annotation.id) : [S[0].annotation.id]) : [];\n  }, g = (l) => {\n    const c = v(l);\n    if (c.length === 0)\n      return;\n    let b = c[0].left, S = c[0].top, E = c[0].right, C = c[0].bottom;\n    for (let O = 1; O < c.length; O++) {\n      const B = c[O];\n      b = Math.min(b, B.left), S = Math.min(S, B.top), E = Math.max(E, B.right), C = Math.max(C, B.bottom);\n    }\n    return new DOMRect(b, S, E - b, C - S);\n  }, v = (l) => {\n    const c = o.get(l);\n    return c ? c[0].annotation.rects : [];\n  };\n  return {\n    all: s,\n    clear: a,\n    getAt: u,\n    getAnnotationBounds: g,\n    getAnnotationRects: v,\n    getIntersecting: (l, c, b, S) => {\n      const E = n.search({ minX: l, minY: c, maxX: b, maxY: S }), C = new Set(E.map((O) => O.annotation.id));\n      return Array.from(C).map((O) => ({\n        annotation: t.getAnnotation(O),\n        rects: v(O)\n      })).filter((O) => !!O.annotation);\n    },\n    insert: r,\n    recalculate: () => h(t.all().map((l) => l.target), !0),\n    remove: d,\n    set: h,\n    size: () => n.all().length,\n    update: f\n  };\n}, eo = (t, e) => {\n  const n = Ln(), o = to(n, t), i = gn(n);\n  i.setUserSelectAction(e);\n  const s = fn(n), a = Mn(), r = (l, c = k.LOCAL) => {\n    const b = vt(l, t), S = F(b.target.selector);\n    return S && n.addAnnotation(b, c), S;\n  }, d = (l, c = !0, b = k.LOCAL) => {\n    const S = l.map((C) => vt(C, t)), E = S.filter((C) => !F(C.target.selector));\n    return n.bulkAddAnnotation(S, c, b), E;\n  }, f = (l, c = k.LOCAL) => {\n    const b = l.map((E) => vt(E, t)), S = b.filter((E) => !F(E.target.selector));\n    return b.forEach((E) => {\n      n.getAnnotation(E.id) ? n.updateAnnotation(E, c) : n.addAnnotation(E, c);\n    }), S;\n  }, h = (l, c = k.LOCAL) => {\n    const b = wt(l, t);\n    n.updateTarget(b, c);\n  }, u = (l, c = k.LOCAL) => {\n    const b = l.map((S) => wt(S, t));\n    n.bulkUpdateTargets(b, c);\n  };\n  function g(l, c, b, S) {\n    const E = b || !!S, C = o.getAt(l, c, E).map((B) => n.getAnnotation(B)), O = S ? C.filter(S) : C;\n    if (O.length !== 0)\n      return b ? O : O[0];\n  }\n  const v = (l) => {\n    if (o.getAnnotationRects(l).length !== 0)\n      return o.getAnnotationBounds(l);\n  }, p = (l, c, b, S) => o.getIntersecting(l, c, b, S), y = (l) => o.getAnnotationRects(l), x = () => o.recalculate();\n  return n.observe(({ changes: l }) => {\n    const c = (l.deleted || []).filter((E) => F(E.target.selector)), b = (l.created || []).filter((E) => F(E.target.selector)), S = (l.updated || []).filter((E) => F(E.newValue.target.selector));\n    (c == null ? void 0 : c.length) > 0 && c.forEach((E) => o.remove(E.target)), b.length > 0 && o.set(b.map((E) => E.target), !1), (S == null ? void 0 : S.length) > 0 && S.forEach(({ newValue: E }) => o.update(E.target));\n  }), {\n    store: {\n      ...n,\n      addAnnotation: r,\n      bulkAddAnnotation: d,\n      bulkUpdateTargets: u,\n      bulkUpsertAnnotations: f,\n      getAnnotationBounds: v,\n      getAnnotationRects: y,\n      getIntersecting: p,\n      getAt: g,\n      recalculatePositions: x,\n      updateTarget: h\n    },\n    selection: i,\n    hover: s,\n    viewport: a\n  };\n}, no = () => {\n  const t = document.createElement(\"canvas\");\n  t.width = 2 * window.innerWidth, t.height = 2 * window.innerHeight, t.className = \"r6o-presence-layer\";\n  const e = t.getContext(\"2d\");\n  return e.scale(2, 2), e.translate(0.5, 0.5), t;\n}, oo = (t, e = {}) => {\n  const n = no(), o = n.getContext(\"2d\");\n  document.body.appendChild(n);\n  const i = /* @__PURE__ */ new Map(), s = (h) => Array.from(i.entries()).filter(([u, g]) => g.presenceKey === h.presenceKey).map(([u, g]) => u);\n  return t.on(\"selectionChange\", (h, u) => {\n    s(h).forEach((v) => i.delete(v)), u && u.forEach((v) => i.set(v, h));\n  }), {\n    clear: () => {\n      const { width: h, height: u } = n;\n      o.clearRect(-0.5, -0.5, h + 1, u + 1);\n    },\n    destroy: () => {\n      n.remove();\n    },\n    paint: (h, u, g) => {\n      e.font && (o.font = e.font);\n      const v = i.get(h.annotation.id);\n      if (v) {\n        const { height: p } = h.rects[0], y = h.rects[0].x + u.left, x = h.rects[0].y + u.top;\n        o.fillStyle = v.appearance.color, o.fillRect(y - 2, x - 2.5, 2, p + 5);\n        const l = o.measureText(v.appearance.label), c = l.width + 6, b = l.actualBoundingBoxAscent + l.actualBoundingBoxDescent + 8, S = l.fontBoundingBoxAscent ? 8 : 6.5;\n        return o.fillRect(y - 2, x - 2.5 - b, c, b), o.fillStyle = \"#fff\", o.fillText(v.appearance.label, y + 1, x - S), {\n          fill: v.appearance.color,\n          fillOpacity: g ? 0.45 : 0.18\n        };\n      }\n    },\n    reset: () => {\n      n.width = 2 * window.innerWidth, n.height = 2 * window.innerHeight;\n      const h = n.getContext(\"2d\");\n      h.scale(2, 2), h.translate(0.5, 0.5);\n    }\n  };\n}, It = typeof navigator < \"u\" ? navigator.userAgent.toLowerCase().indexOf(\"firefox\") > 0 : !1;\nfunction _t(t, e, n, o) {\n  t.addEventListener ? t.addEventListener(e, n, o) : t.attachEvent && t.attachEvent(\"on\".concat(e), n);\n}\nfunction ot(t, e, n, o) {\n  t.removeEventListener ? t.removeEventListener(e, n, o) : t.detachEvent && t.detachEvent(\"on\".concat(e), n);\n}\nfunction ye(t, e) {\n  const n = e.slice(0, e.length - 1);\n  for (let o = 0; o < n.length; o++) n[o] = t[n[o].toLowerCase()];\n  return n;\n}\nfunction be(t) {\n  typeof t != \"string\" && (t = \"\"), t = t.replace(/\\s/g, \"\");\n  const e = t.split(\",\");\n  let n = e.lastIndexOf(\"\");\n  for (; n >= 0; )\n    e[n - 1] += \",\", e.splice(n, 1), n = e.lastIndexOf(\"\");\n  return e;\n}\nfunction io(t, e) {\n  const n = t.length >= e.length ? t : e, o = t.length >= e.length ? e : t;\n  let i = !0;\n  for (let s = 0; s < n.length; s++)\n    o.indexOf(n[s]) === -1 && (i = !1);\n  return i;\n}\nconst lt = {\n  backspace: 8,\n  \"\": 8,\n  tab: 9,\n  clear: 12,\n  enter: 13,\n  \"\": 13,\n  return: 13,\n  esc: 27,\n  escape: 27,\n  space: 32,\n  left: 37,\n  up: 38,\n  right: 39,\n  down: 40,\n  del: 46,\n  delete: 46,\n  ins: 45,\n  insert: 45,\n  home: 36,\n  end: 35,\n  pageup: 33,\n  pagedown: 34,\n  capslock: 20,\n  num_0: 96,\n  num_1: 97,\n  num_2: 98,\n  num_3: 99,\n  num_4: 100,\n  num_5: 101,\n  num_6: 102,\n  num_7: 103,\n  num_8: 104,\n  num_9: 105,\n  num_multiply: 106,\n  num_add: 107,\n  num_enter: 108,\n  num_subtract: 109,\n  num_decimal: 110,\n  num_divide: 111,\n  \"\": 20,\n  \",\": 188,\n  \".\": 190,\n  \"/\": 191,\n  \"`\": 192,\n  \"-\": It ? 173 : 189,\n  \"=\": It ? 61 : 187,\n  \";\": It ? 59 : 186,\n  \"'\": 222,\n  \"[\": 219,\n  \"]\": 221,\n  \"\\\\\": 220\n}, H = {\n  // shiftKey\n  \"\": 16,\n  shift: 16,\n  // altKey\n  \"\": 18,\n  alt: 18,\n  option: 18,\n  // ctrlKey\n  \"\": 17,\n  ctrl: 17,\n  control: 17,\n  // metaKey\n  \"\": 91,\n  cmd: 91,\n  command: 91\n}, bt = {\n  16: \"shiftKey\",\n  18: \"altKey\",\n  17: \"ctrlKey\",\n  91: \"metaKey\",\n  shiftKey: 16,\n  ctrlKey: 17,\n  altKey: 18,\n  metaKey: 91\n}, K = {\n  16: !1,\n  18: !1,\n  17: !1,\n  91: !1\n}, _ = {};\nfor (let t = 1; t < 20; t++)\n  lt[\"f\".concat(t)] = 111 + t;\nlet I = [], ct = null, we = \"all\";\nconst z = /* @__PURE__ */ new Map(), ut = (t) => lt[t.toLowerCase()] || H[t.toLowerCase()] || t.toUpperCase().charCodeAt(0), so = (t) => Object.keys(lt).find((e) => lt[e] === t), ro = (t) => Object.keys(H).find((e) => H[e] === t);\nfunction Ae(t) {\n  we = t || \"all\";\n}\nfunction dt() {\n  return we || \"all\";\n}\nfunction ao() {\n  return I.slice(0);\n}\nfunction co() {\n  return I.map((t) => so(t) || ro(t) || String.fromCharCode(t));\n}\nfunction lo() {\n  const t = [];\n  return Object.keys(_).forEach((e) => {\n    _[e].forEach((n) => {\n      let {\n        key: o,\n        scope: i,\n        mods: s,\n        shortcut: a\n      } = n;\n      t.push({\n        scope: i,\n        shortcut: a,\n        mods: s,\n        keys: o.split(\"+\").map((r) => ut(r))\n      });\n    });\n  }), t;\n}\nfunction uo(t) {\n  const e = t.target || t.srcElement, {\n    tagName: n\n  } = e;\n  let o = !0;\n  const i = n === \"INPUT\" && ![\"checkbox\", \"radio\", \"range\", \"button\", \"file\", \"reset\", \"submit\", \"color\"].includes(e.type);\n  return (e.isContentEditable || (i || n === \"TEXTAREA\" || n === \"SELECT\") && !e.readOnly) && (o = !1), o;\n}\nfunction fo(t) {\n  return typeof t == \"string\" && (t = ut(t)), I.indexOf(t) !== -1;\n}\nfunction ho(t, e) {\n  let n, o;\n  t || (t = dt());\n  for (const i in _)\n    if (Object.prototype.hasOwnProperty.call(_, i))\n      for (n = _[i], o = 0; o < n.length; )\n        n[o].scope === t ? n.splice(o, 1).forEach((a) => {\n          let {\n            element: r\n          } = a;\n          return Xt(r);\n        }) : o++;\n  dt() === t && Ae(e || \"all\");\n}\nfunction go(t) {\n  let e = t.keyCode || t.which || t.charCode;\n  const n = I.indexOf(e);\n  if (n >= 0 && I.splice(n, 1), t.key && t.key.toLowerCase() === \"meta\" && I.splice(0, I.length), (e === 93 || e === 224) && (e = 91), e in K) {\n    K[e] = !1;\n    for (const o in H) H[o] === e && (P[o] = !1);\n  }\n}\nfunction xe(t) {\n  if (typeof t > \"u\")\n    Object.keys(_).forEach((i) => {\n      Array.isArray(_[i]) && _[i].forEach((s) => yt(s)), delete _[i];\n    }), Xt(null);\n  else if (Array.isArray(t))\n    t.forEach((i) => {\n      i.key && yt(i);\n    });\n  else if (typeof t == \"object\")\n    t.key && yt(t);\n  else if (typeof t == \"string\") {\n    for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), o = 1; o < e; o++)\n      n[o - 1] = arguments[o];\n    let [i, s] = n;\n    typeof i == \"function\" && (s = i, i = \"\"), yt({\n      key: t,\n      scope: i,\n      method: s,\n      splitKey: \"+\"\n    });\n  }\n}\nconst yt = (t) => {\n  let {\n    key: e,\n    scope: n,\n    method: o,\n    splitKey: i = \"+\"\n  } = t;\n  be(e).forEach((a) => {\n    const r = a.split(i), d = r.length, f = r[d - 1], h = f === \"*\" ? \"*\" : ut(f);\n    if (!_[h]) return;\n    n || (n = dt());\n    const u = d > 1 ? ye(H, r) : [], g = [];\n    _[h] = _[h].filter((v) => {\n      const y = (o ? v.method === o : !0) && v.scope === n && io(v.mods, u);\n      return y && g.push(v.element), !y;\n    }), g.forEach((v) => Xt(v));\n  });\n};\nfunction ne(t, e, n, o) {\n  if (e.element !== o)\n    return;\n  let i;\n  if (e.scope === n || e.scope === \"all\") {\n    i = e.mods.length > 0;\n    for (const s in K)\n      Object.prototype.hasOwnProperty.call(K, s) && (!K[s] && e.mods.indexOf(+s) > -1 || K[s] && e.mods.indexOf(+s) === -1) && (i = !1);\n    (e.mods.length === 0 && !K[16] && !K[18] && !K[17] && !K[91] || i || e.shortcut === \"*\") && (e.keys = [], e.keys = e.keys.concat(I), e.method(t, e) === !1 && (t.preventDefault ? t.preventDefault() : t.returnValue = !1, t.stopPropagation && t.stopPropagation(), t.cancelBubble && (t.cancelBubble = !0)));\n  }\n}\nfunction oe(t, e) {\n  const n = _[\"*\"];\n  let o = t.keyCode || t.which || t.charCode;\n  if (!P.filter.call(this, t)) return;\n  if ((o === 93 || o === 224) && (o = 91), I.indexOf(o) === -1 && o !== 229 && I.push(o), [\"metaKey\", \"ctrlKey\", \"altKey\", \"shiftKey\"].forEach((r) => {\n    const d = bt[r];\n    t[r] && I.indexOf(d) === -1 ? I.push(d) : !t[r] && I.indexOf(d) > -1 ? I.splice(I.indexOf(d), 1) : r === \"metaKey\" && t[r] && (I = I.filter((f) => f in bt || f === o));\n  }), o in K) {\n    K[o] = !0;\n    for (const r in H)\n      H[r] === o && (P[r] = !0);\n    if (!n) return;\n  }\n  for (const r in K)\n    Object.prototype.hasOwnProperty.call(K, r) && (K[r] = t[bt[r]]);\n  t.getModifierState && !(t.altKey && !t.ctrlKey) && t.getModifierState(\"AltGraph\") && (I.indexOf(17) === -1 && I.push(17), I.indexOf(18) === -1 && I.push(18), K[17] = !0, K[18] = !0);\n  const i = dt();\n  if (n)\n    for (let r = 0; r < n.length; r++)\n      n[r].scope === i && (t.type === \"keydown\" && n[r].keydown || t.type === \"keyup\" && n[r].keyup) && ne(t, n[r], i, e);\n  if (!(o in _)) return;\n  const s = _[o], a = s.length;\n  for (let r = 0; r < a; r++)\n    if ((t.type === \"keydown\" && s[r].keydown || t.type === \"keyup\" && s[r].keyup) && s[r].key) {\n      const d = s[r], {\n        splitKey: f\n      } = d, h = d.key.split(f), u = [];\n      for (let g = 0; g < h.length; g++)\n        u.push(ut(h[g]));\n      u.sort().join(\"\") === I.sort().join(\"\") && ne(t, d, i, e);\n    }\n}\nfunction P(t, e, n) {\n  I = [];\n  const o = be(t);\n  let i = [], s = \"all\", a = document, r = 0, d = !1, f = !0, h = \"+\", u = !1, g = !1;\n  for (n === void 0 && typeof e == \"function\" && (n = e), Object.prototype.toString.call(e) === \"[object Object]\" && (e.scope && (s = e.scope), e.element && (a = e.element), e.keyup && (d = e.keyup), e.keydown !== void 0 && (f = e.keydown), e.capture !== void 0 && (u = e.capture), typeof e.splitKey == \"string\" && (h = e.splitKey), e.single === !0 && (g = !0)), typeof e == \"string\" && (s = e), g && xe(t, s); r < o.length; r++)\n    t = o[r].split(h), i = [], t.length > 1 && (i = ye(H, t)), t = t[t.length - 1], t = t === \"*\" ? \"*\" : ut(t), t in _ || (_[t] = []), _[t].push({\n      keyup: d,\n      keydown: f,\n      scope: s,\n      mods: i,\n      shortcut: o[r],\n      method: n,\n      key: o[r],\n      splitKey: h,\n      element: a\n    });\n  if (typeof a < \"u\" && window) {\n    if (!z.has(a)) {\n      const v = function() {\n        let y = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.event;\n        return oe(y, a);\n      }, p = function() {\n        let y = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.event;\n        oe(y, a), go(y);\n      };\n      z.set(a, {\n        keydownListener: v,\n        keyupListenr: p,\n        capture: u\n      }), _t(a, \"keydown\", v, u), _t(a, \"keyup\", p, u);\n    }\n    if (!ct) {\n      const v = () => {\n        I = [];\n      };\n      ct = {\n        listener: v,\n        capture: u\n      }, _t(window, \"focus\", v, u);\n    }\n  }\n}\nfunction po(t) {\n  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"all\";\n  Object.keys(_).forEach((n) => {\n    _[n].filter((i) => i.scope === e && i.shortcut === t).forEach((i) => {\n      i && i.method && i.method();\n    });\n  });\n}\nfunction Xt(t) {\n  const e = Object.values(_).flat();\n  if (e.findIndex((o) => {\n    let {\n      element: i\n    } = o;\n    return i === t;\n  }) < 0) {\n    const {\n      keydownListener: o,\n      keyupListenr: i,\n      capture: s\n    } = z.get(t) || {};\n    o && i && (ot(t, \"keyup\", i, s), ot(t, \"keydown\", o, s), z.delete(t));\n  }\n  if ((e.length <= 0 || z.size <= 0) && (Object.keys(z).forEach((i) => {\n    const {\n      keydownListener: s,\n      keyupListenr: a,\n      capture: r\n    } = z.get(i) || {};\n    s && a && (ot(i, \"keyup\", a, r), ot(i, \"keydown\", s, r), z.delete(i));\n  }), z.clear(), Object.keys(_).forEach((i) => delete _[i]), ct)) {\n    const {\n      listener: i,\n      capture: s\n    } = ct;\n    ot(window, \"focus\", i, s), ct = null;\n  }\n}\nconst Nt = {\n  getPressedKeyString: co,\n  setScope: Ae,\n  getScope: dt,\n  deleteScope: ho,\n  getPressedKeyCodes: ao,\n  getAllKeyCodes: lo,\n  isPressed: fo,\n  filter: uo,\n  trigger: po,\n  unbind: xe,\n  keyMap: lt,\n  modifier: H,\n  modifierMap: bt\n};\nfor (const t in Nt)\n  Object.prototype.hasOwnProperty.call(Nt, t) && (P[t] = Nt[t]);\nif (typeof window < \"u\") {\n  const t = window.hotkeys;\n  P.noConflict = (e) => (e && window.hotkeys === P && (window.hotkeys = t), P), window.hotkeys = P;\n}\nconst ie = 300, ve = [\"up\", \"down\", \"left\", \"right\"], Ee = Te ? \"+a\" : \"ctrl+a\", mo = [\n  ...ve.map((t) => `shift+${t}`),\n  Ee\n], yo = (t, e, n) => {\n  let o;\n  const { annotatingEnabled: i, offsetReferenceSelector: s, selectionMode: a } = n, r = (T) => o = T;\n  let d;\n  const f = (T) => d = T, { store: h, selection: u } = e;\n  let g, v, p;\n  const y = (T) => {\n    v !== !1 && (g = it(T.target) ? void 0 : {\n      annotation: fe(),\n      selector: [],\n      creator: o,\n      created: /* @__PURE__ */ new Date()\n    });\n  }, x = Yt((T) => {\n    const m = document.getSelection();\n    if (!(m != null && m.anchorNode))\n      return;\n    if (it(m.anchorNode)) {\n      g = void 0;\n      return;\n    }\n    const A = T.timeStamp - ((p == null ? void 0 : p.timeStamp) || T.timeStamp);\n    if ((p == null ? void 0 : p.type) === \"pointerdown\" && (A < 1e3 && !g || m.isCollapsed && A < ie) && y(p || T), !g) return;\n    if (m.isCollapsed) {\n      h.getAnnotation(g.annotation) && (u.clear(), h.deleteAnnotation(g.annotation));\n      return;\n    }\n    const w = m.getRangeAt(0), L = Ye(w, t);\n    if (Ie(L)) return;\n    const M = Me(L.cloneRange());\n    (M.length !== g.selector.length || M.some((N, U) => {\n      var et;\n      return N.toString() !== ((et = g.selector[U]) == null ? void 0 : et.quote);\n    })) && (g = {\n      ...g,\n      selector: M.map((N) => Ve(N, t, s)),\n      updated: /* @__PURE__ */ new Date()\n    }, h.getAnnotation(g.annotation) ? h.updateTarget(g, k.LOCAL) : u.clear());\n  }), l = (T) => {\n    it(T.target) || (p = xt(T), v = p.button === 0);\n  }, c = (T) => {\n    if (it(T.target) || !v) return;\n    const m = () => {\n      const { x: w, y: L } = t.getBoundingClientRect(), M = T.target instanceof Node && t.contains(T.target) && h.getAt(T.clientX - w, T.clientY - L, a === \"all\", d);\n      if (M) {\n        const { selected: R } = u, N = new Set(R.map((q) => q.id)), U = Array.isArray(M) ? M.map((q) => q.id) : [M.id];\n        (N.size !== U.length || !U.every((q) => N.has(q))) && u.userSelect(U, T);\n      } else\n        u.clear();\n    }, A = T.timeStamp - p.timeStamp;\n    setTimeout(() => {\n      const w = document.getSelection();\n      w != null && w.isCollapsed && A < ie ? (g = void 0, m()) : g && g.selector.length > 0 && (O(), u.userSelect(g.annotation, xt(T)));\n    });\n  }, b = (T) => {\n    const m = document.getSelection();\n    m != null && m.isCollapsed || ((!g || g.selector.length === 0) && x(T), O(), u.userSelect(g.annotation, xt(T)));\n  }, S = (T) => {\n    T.key === \"Shift\" && g && (document.getSelection().isCollapsed || (O(), u.userSelect(g.annotation, ft(T))));\n  }, E = (T) => {\n    const m = () => setTimeout(() => {\n      (g == null ? void 0 : g.selector.length) > 0 && (u.clear(), h.addAnnotation({\n        id: g.annotation,\n        bodies: [],\n        target: g\n      }), u.userSelect(g.annotation, ft(T))), document.removeEventListener(\"selectionchange\", m);\n    }, 100);\n    document.addEventListener(\"selectionchange\", m), y(T);\n  };\n  P(mo.join(\",\"), { element: t, keydown: !0, keyup: !1 }, (T) => {\n    T.repeat || (p = ft(T));\n  }), P(Ee, { keydown: !0, keyup: !1 }, (T) => {\n    p = ft(T), E(T);\n  });\n  const C = (T) => {\n    T.repeat || T.target !== t && T.target !== document.body || (g = void 0, u.clear());\n  };\n  P(ve.join(\",\"), { keydown: !0, keyup: !1 }, C);\n  const O = () => {\n    const T = h.getAnnotation(g.annotation);\n    if (!T) {\n      h.addAnnotation({\n        id: g.annotation,\n        bodies: [],\n        target: g\n      });\n      return;\n    }\n    const { target: { updated: m } } = T, { updated: A } = g;\n    (!m || !A || m < A) && h.updateTarget(g);\n  };\n  return t.addEventListener(\"pointerdown\", l), document.addEventListener(\"pointerup\", c), document.addEventListener(\"contextmenu\", b), i && (t.addEventListener(\"keyup\", S), t.addEventListener(\"selectstart\", y), document.addEventListener(\"selectionchange\", x)), {\n    destroy: () => {\n      t.removeEventListener(\"pointerdown\", l), document.removeEventListener(\"pointerup\", c), document.removeEventListener(\"contextmenu\", b), t.removeEventListener(\"keyup\", S), t.removeEventListener(\"selectstart\", y), document.removeEventListener(\"selectionchange\", x), P.unbind();\n    },\n    setFilter: f,\n    setUser: r\n  };\n}, bo = (t, e) => ({\n  ...t,\n  annotatingEnabled: t.annotatingEnabled ?? e.annotatingEnabled,\n  user: t.user || e.user\n}), se = \"SPANS\", vo = (t, e = {}) => {\n  Le(t), Oe(t);\n  const n = bo(e, {\n    annotatingEnabled: !0,\n    user: Dn()\n  }), o = eo(t, n.userSelectAction), { selection: i, viewport: s } = o, a = o.store, r = Bn(a), d = Rn(o, r, n.adapter);\n  let f = n.user;\n  const h = n.renderer === \"CSS_HIGHLIGHTS\" ? CSS.highlights ? \"CSS_HIGHLIGHTS\" : se : n.renderer || se, u = h === \"SPANS\" ? rn(t, o, s) : h === \"CSS_HIGHLIGHTS\" ? nn(t, o, s) : h === \"CANVAS\" ? ze(t, o, s) : void 0;\n  if (!u)\n    throw `Unknown renderer implementation: ${h}`;\n  console.debug(`Using ${h} renderer`), n.style && u.setStyle(n.style);\n  const g = yo(t, o, n);\n  return g.setUser(f), {\n    ...In(o, r, n.adapter),\n    destroy: () => {\n      u.destroy(), g.destroy(), r.destroy();\n    },\n    element: t,\n    getUser: () => f,\n    setFilter: (C) => {\n      u.setFilter(C), g.setFilter(C);\n    },\n    setStyle: (C) => u.setStyle(C),\n    setUser: (C) => {\n      f = C, g.setUser(C);\n    },\n    setSelected: (C) => {\n      C ? i.setSelected(C) : i.clear();\n    },\n    setPresenceProvider: (C) => {\n      C && (u.setPainter(oo(C, n.presence)), C.on(\"selectionChange\", () => u.redraw()));\n    },\n    setVisible: (C) => u.setVisible(C),\n    on: d.on,\n    off: d.off,\n    scrollIntoView: De(t, a),\n    state: o\n  };\n};\nexport {\n  At as DEFAULT_SELECTED_STYLE,\n  W as DEFAULT_STYLE,\n  re as NOT_ANNOTATABLE_CLASS,\n  tt as NOT_ANNOTATABLE_SELECTOR,\n  k as Origin,\n  yo as SelectionHandler,\n  hn as UserSelectAction,\n  xo as W3CTextFormat,\n  Le as cancelSingleClickEvents,\n  ft as cloneKeyboardEvent,\n  xt as clonePointerEvent,\n  Ao as createBody,\n  ze as createCanvasRenderer,\n  nn as createHighlightsRenderer,\n  oo as createPresencePainter,\n  en as createRenderer,\n  rn as createSpansRenderer,\n  vo as createTextAnnotator,\n  eo as createTextAnnotatorState,\n  Yt as debounce,\n  bo as fillDefaults,\n  Re as getQuoteContext,\n  Ut as getRangeAnnotatableContents,\n  Te as isMac,\n  it as isNotAnnotatable,\n  Ce as isRangeAnnotatable,\n  F as isRevived,\n  Ie as isWhitespaceOrEmpty,\n  Ue as mergeClientRects,\n  Ke as paint,\n  jn as parseW3CTextAnnotation,\n  Oe as programmaticallyFocusable,\n  Ve as rangeToSelector,\n  vt as reviveAnnotation,\n  ae as reviveSelector,\n  wt as reviveTarget,\n  De as scrollIntoView,\n  zn as serializeW3CTextAnnotation,\n  Me as splitAnnotatableRanges,\n  wo as toDomRectList,\n  Ye as trimRangeToContainer,\n  ke as whitespaceOrEmptyRegex\n};\n//# sourceMappingURL=text-annotator.es.js.map\n","export const reanchor = (originalNode: Node, parentNode: Node, originalOffset: number) => {\n  let node = originalNode;\n\n  let offset = originalOffset;\n\n  const it = document.createNodeIterator(parentNode, NodeFilter.SHOW_TEXT);\n\n  let currentNode = it.nextNode();\n\n  let run = true;\n\n  do {\n    if (currentNode instanceof Text) {\n      if (currentNode.length < offset) {\n        offset -= currentNode.length;\n      } else {\n        node = currentNode;\n        run = false;\n      }\n    }\n\n    currentNode = it.nextNode();\n  } while (currentNode && run);\n\n  return { node, offset };\n};","import { rangeToSelector, reviveTarget as reviveTextOffsetTarget } from '@recogito/text-annotator';\nimport type { TEIAnnotation, TEIAnnotationTarget, TEIRangeSelector } from '../TEIAnnotation';\nimport { reanchor } from './utils';\nimport type { \n  TextAnnotation, \n  TextAnnotationTarget, \n  TextSelector\n} from '@recogito/text-annotator';\n\n/**\n * Helper: Returns the given XPath for a DOM node, in the form of \n * a list of segments.\n * \n * Note that this method is used recursively,\n */\nconst getXPath = (node: Node, path: string[] = []) => {\n  let xpath: string;\n  let count: number;\n  let predicate: string;\n\n  if (node.nodeType === Node.ELEMENT_NODE && (node as Element).hasAttribute('xml:id')) {\n    path.push('/');\n  } else if (node.parentNode) {\n    path = getXPath(node.parentNode, path);\n  }\n\n  if (node.nodeType === Node.ELEMENT_NODE && node.nodeName.toLowerCase().startsWith('tei-')) {\n    const el = node as Element;\n\n    if (el.hasAttribute('xml:id')) {\n      predicate = `[@xml:id='${el.getAttribute(\"xml:id\")}']`;\n    } else {\n      xpath = `count(preceding-sibling::${el.localName})`;\n      count = document.evaluate(xpath, node, null, XPathResult.NUMBER_TYPE, null).numberValue + 1;\n  \n      predicate = `[${count}]`;\n    }\n\n    path.push('/');\n    path.push(el.getAttribute('data-origname') + predicate);\n  }\n\n  return path;\n}\n\n/**\n * For the given path sgement lists, this function returns the the\n * start & end XPath expression pair.\n */\nconst toTEIXPaths = (startPath: string[], endPath: string[], selectedRange: Range) => {\n  // For a given node, returns the closest parent that is a TEI element\n  const getClosestTEINode = (node: Node | null) => {\n    if (!node) return null;\n\n    return (node.nodeName.toLowerCase().indexOf('tei-') === 0) ?\n      node : getClosestTEINode(node.parentNode);\n  };\n\n  // Helper to compute char offsets between end of XPath and a given reference node\n  const getOffsetFromTo = (fromNode: Node, toNode: Node, toOffset: number) => {\n    const range = document.createRange();\n    range.setStart(fromNode, 0);\n    range.setEnd(toNode, toOffset);\n    return range.toString().length;\n  }\n\n  const startOffset = getOffsetFromTo(\n    getClosestTEINode(selectedRange.startContainer),\n    selectedRange.startContainer,\n    selectedRange.startOffset);\n\n  const endOffset = getOffsetFromTo(\n    getClosestTEINode(selectedRange.endContainer),\n    selectedRange.endContainer,\n    selectedRange.endOffset);\n\n  const start = startPath.join('') + '::' + startOffset;\n  const end = endPath.join('') + '::' + endOffset;\n\n  return { start, end }; \n}\n\n\n/**\n * Using the DOM Range from a (revived!) TextSelector, this function computes\n * the TEIRangeSelector corresponding to that range.\n */\nexport const textToTEISelector = (selector: TextSelector): TEIRangeSelector => {\n  const { range } = selector;\n\n  // XPath segments for Range start and end nodes as a list\n  const startPathSegments: string[] = getXPath(range.startContainer);\n  const endPathSegments: string[] = getXPath(range.endContainer);\n\n  // TEI XPath expressions\n  const { start, end } = toTEIXPaths(startPathSegments, endPathSegments, range);\n\n  return {\n    start: selector.start,\n    startSelector: {\n      type: 'XPathSelector',\n      value: start\n    },\n    end: selector.end,\n    endSelector: {\n      type: 'XPathSelector',\n      value: end\n    },\n    quote: selector.quote?.replace(/\\s+/g, ' '),\n    range\n  };\n}\n\nexport const reviveTarget = (t: TextAnnotationTarget, container: HTMLElement) => {\n  const selector = Array.isArray(t.selector) ? t.selector[0] : t.selector;\n  \n  if ('start' in selector && 'end' in selector) {\n    return reviveTextOffsetTarget(t, container);\n  } else {\n    const startExpression = (selector as TEIRangeSelector).startSelector?.value;\n    const endExpression = (selector as TEIRangeSelector).endSelector?.value;\n\n    if (!startExpression || !endExpression) {\n      console.error(t);\n      throw 'Could not revive TEI target.'\n    }\n\n    const evaluateSelector = (value: string) => {\n      const splitIdx = value.indexOf('::');\n\n      if (splitIdx < 0) return;\n\n      const path = value.substring(0, splitIdx).replace(/\\/([^[/]+)/g, (_, p1) => {\n        return '/tei-' + p1.toLowerCase();\n      }).replace(/xml:/g, '');\n\n      const node = document.evaluate('.' + path,\n        container, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;\n\n      const offset = parseInt(value.substring(splitIdx + 2));\n\n      return [node, offset] as [Node, number];\n    }\n\n    const [startNode, startOffset] = evaluateSelector(startExpression);\n    const [endNode, endOffset] = evaluateSelector(endExpression);\n\n    const range = document.createRange();\n\n    // Helper\n    const reanchorIfNeeded = (parent: Node, offset: number) => {\n      if (parent.firstChild instanceof Text && parent.firstChild.length >= offset) {\n        return { node: parent.firstChild, offset };\n      } else {\n        return reanchor(parent.firstChild, parent, offset);\n      } \n    }\n\n    const reanchoredStart = reanchorIfNeeded(startNode, startOffset);\n    range.setStart(reanchoredStart.node, reanchoredStart.offset);\n\n    const reanchoredEnd = reanchorIfNeeded(endNode, endOffset);\n    range.setEnd(reanchoredEnd.node, reanchoredEnd.offset);\n\n    const textSelector = rangeToSelector(range, container);\n\n    return reviveTextOffsetTarget({\n      ...t,\n      selector: [{\n        ...textSelector,\n        ...(selector as TEIRangeSelector),\n        range\n      }]\n    }, container);\n  }\n}\n\nexport const textToTEITarget =  (container: HTMLElement) => (t: TextAnnotationTarget): TEIAnnotationTarget => {\n  const target = reviveTarget(t, container);\n  return {\n    ...t,\n    selector: target.selector.map(textToTEISelector)\n  }\n}\n\nexport const textToTEIAnnotation = (container: HTMLElement) => (a: TextAnnotation): TEIAnnotation => ({\n  ...a,\n  target: textToTEITarget(container)(a.target)\n})\n\n","import type { \n  TextAnnotator,\n  TextAnnotation,\n  TextAnnotationTarget, \n} from '@recogito/text-annotator';\nimport type { \n  Annotator,\n  Origin,  \n  Store,  \n} from '@annotorious/core';\nimport { \n  textToTEIAnnotation, \n  textToTEITarget \n} from './crosswalk';\nimport type { \n  TEIAnnotation,\n  TEIAnnotationTarget\n} from './TEIAnnotation';\n\nexport type TEIAnnotationStore = Store<TEIAnnotation> & {\n\n  // Minor change to default Annotorious store - text store returns annotations\n  // that failed to render, to support lazy document loading scenarios\n  bulkAddAnnotation(annotations: TextAnnotation[], replace: boolean, origin: Origin): TEIAnnotation[];\n\n  getAt(x: number, y: number): TEIAnnotation | undefined;\n  \n  getIntersecting(minX: number, minY: number, maxX: number, maxY: number): TEIAnnotation[];\n  \n  recalculatePositions(): void;\n\n}\n\nexport interface RecogitoTEIAnnotator<T extends unknown = TEIAnnotation> extends Annotator<TEIAnnotation, T> { }\n\nexport const TEIPlugin = (anno: TextAnnotator): RecogitoTEIAnnotator => {\n\n  const container: HTMLElement = anno.element;\n\n  const toTEI = textToTEIAnnotation(container);\n\n  const toTEITarget = textToTEITarget(container);\n\n  // Monkey-patch the store\n  const store = anno.state.store;\n\n  const _addAnnotation = store.addAnnotation;\n  store.addAnnotation = (annotation: TEIAnnotation | TextAnnotation, origin: Origin) => {\n    const { selector } = annotation.target;\n    return ('startSelector' in selector && 'start' in selector) ?\n      _addAnnotation(annotation, origin) :\n      _addAnnotation(toTEI(annotation), origin);\n  }\n\n  const _bulkAddAnnotation = store.bulkAddAnnotation;\n  store.bulkAddAnnotation = (annotations: Array<TEIAnnotation | TextAnnotation>, replace = true, origin: Origin) => {\n    const teiAnnotations = annotations.map(a => {\n      const { selector } = a.target;\n      return ('startSelector' in selector && 'start' in selector) ? a : toTEI(a);\n    });\n    \n    return _bulkAddAnnotation(teiAnnotations, replace, origin);\n  }\n\n  const _updateAnnotation = store.updateAnnotation;\n  store.updateAnnotation = (annotation: TEIAnnotation | TextAnnotation, origin: Origin) =>\n    _updateAnnotation(toTEI(annotation), origin);\n\n  const _updateTarget = store.updateTarget;\n  store.updateTarget = (target: TEIAnnotationTarget | TextAnnotationTarget, origin: Origin) => \n    _updateTarget(toTEITarget(target), origin);\n\n  return {\n    ...anno,\n    state: {\n      ...anno.state,\n      // @ts-ignore\n      store\n    }\n  }\n\n}\n"],"names":["re","tt","Ut","t","e","F","Ve","i","r","ae","h","u","n","o","s","g","v","a","d","wt","Y","D","_n","It","_t","ot","ye","be","io","lt","H","bt","K","_","I","ct","we","z","ut","so","ro","Ae","dt","ao","co","lo","uo","fo","ho","Xt","go","P","xe","yt","f","y","ne","oe","p","po","Nt","reanchor","originalNode","parentNode","originalOffset","node","offset","it","currentNode","run","getXPath","path","xpath","count","predicate","el","toTEIXPaths","startPath","endPath","selectedRange","getClosestTEINode","getOffsetFromTo","fromNode","toNode","toOffset","range","startOffset","endOffset","start","end","textToTEISelector","selector","startPathSegments","endPathSegments","_a","reviveTarget","container","reviveTextOffsetTarget","startExpression","endExpression","_b","evaluateSelector","value","splitIdx","p1","startNode","endNode","reanchorIfNeeded","parent","reanchoredStart","reanchoredEnd","textSelector","rangeToSelector","textToTEITarget","target","textToTEIAnnotation","TEIPlugin","anno","toTEI","toTEITarget","store","_addAnnotation","annotation","origin","_bulkAddAnnotation","annotations","replace","teiAnnotations","_updateAnnotation","_updateTarget"],"mappings":"iOAAK,MAACA,EAAK,kBAAmBC,EAAK,IAAID,CAAE,GAmDhC,OAAO,KAAK,UAAU,cAAgB,UAAU,cAAc,SAAW,UAAU,QAAQ,EAAE,MA6BnGE,EAAMC,GAAM,CACb,MAAMC,EAAID,EAAE,cAAe,EAC3B,OAAOC,EAAE,iBAAiBH,CAAE,EAAE,QAAS,GAAM,EAAE,OAAQ,CAAA,EAAGG,CAC5D,EAUGC,EAAKF,GAAMA,EAAE,MAAOC,GAAMA,EAAE,iBAAiB,OAAS,CAACA,EAAE,MAAM,SAAS,EAuDvEE,EAAK,CAACH,EAAGC,EAAG,IAAM,CACpB,MAAM,EAAI,SAAS,YAAa,EAAEG,EAAoDH,EACtF,EAAE,SAASG,EAAG,CAAC,EAAG,EAAE,OAAOJ,EAAE,eAAgBA,EAAE,WAAW,EAC1D,MAAM,EAAID,EAAG,CAAC,EAAE,YAAa,EAAIC,EAAE,SAAU,EAAEK,EAAI,EAAE,QAAU,EAAG,EAAIA,EAAI,EAAE,OAC5E,MAA0E,CAAE,MAAO,EAAG,MAAOA,EAAG,IAAK,EAAG,MAAOL,CAAG,CACpH,EAAGM,EAAK,CAACN,EAAGC,IAAM,CAChB,IAAIM,EAAGC,EACP,KAAM,CAAE,MAAOC,EAAG,IAAKC,CAAC,EAAKV,EAAGI,EAAIJ,EAAE,iBAAmBC,EAAGU,EAAI,SAAS,mBACvEV,EACA,WAAW,UACVW,GAAM,CACL,IAAIC,EACJ,OAAQA,EAAID,EAAE,gBAAkB,MAAQC,EAAE,QAAQf,CAAE,EAAI,WAAW,YAAc,WAAW,aAClG,CACG,EACD,IAAIgB,EAAI,EACR,MAAMT,EAAI,SAAS,YAAa,EAChC,IAAIU,EAAIJ,EAAE,SAAU,EACpBI,IAAM,MAAQ,QAAQ,MAAM,sDAAsD,EAClF,IAAI,EAAI,CAACX,EACT,KAAOW,IAAM,MAAQ,CACnB,GAAI,IAAM,EAAIX,GAAK,KAAO,OAASA,EAAE,SAASW,CAAC,GAAI,EAAG,CACpD,MAAMH,IAAML,EAAIQ,EAAE,cAAgB,KAAO,OAASR,EAAE,SAAW,EAC/D,GAAIO,EAAIF,EAAIH,EAAG,CACbJ,EAAE,SAASU,EAAGN,EAAIK,CAAC,EACnB,KACR,CACMA,GAAKF,CACX,CACIG,EAAIJ,EAAE,SAAU,CACpB,CACE,KAAOI,IAAM,MAAQ,CACnB,MAAMH,IAAMJ,EAAIO,EAAE,cAAgB,KAAO,OAASP,EAAE,SAAW,EAC/D,GAAIM,EAAIF,GAAKF,EAAG,CACdL,EAAE,OAAOU,EAAGL,EAAII,CAAC,EACjB,KACN,CACIA,GAAKF,EAAGG,EAAIJ,EAAE,SAAU,CAC5B,CACE,MAAO,CACL,GAAGX,EACH,MAAOK,CACR,CACH,EAAGW,EAAK,CAAChB,EAAGC,IAAMC,EAAEF,EAAE,QAAQ,EAAIA,EAAI,CACpC,GAAGA,EACH,SAAUA,EAAE,SAAS,IAAK,GAAM,EAAE,iBAAiB,OAAS,CAAC,EAAE,MAAM,UAAY,EAAIM,EAAG,EAAGL,CAAC,CAAC,CAC/F,EA+VyCgB,EAAI,CAAA,EAC7C,QAASjB,EAAI,EAAGA,EAAI,IAAK,EAAEA,EACzBiB,EAAE,MAAMjB,EAAI,KAAK,SAAS,EAAE,EAAE,MAAM,CAAC,CAAC,EAc7B,OAAO,OAAS,KAAO,OAAO,YAAc,OAAO,WAAW,KAAK,MAAM,EA+E/E,MAoE6DkB,EAAI,CAAA,EACtE,QAASlB,EAAI,EAAGA,EAAI,IAAK,EAAEA,EACzBkB,EAAE,MAAMlB,EAAI,KAAK,SAAS,EAAE,EAAE,MAAM,CAAC,CAAC,EAc7B,OAAO,OAAS,KAAO,OAAO,YAAc,OAAO,WAAW,KAAK,MAAM,EAyT/E,MA0LFmB,GAAK,oEAWsC,CAACnB,EAAI,KAAO,CACxD,IAAIC,EAAI,GAAI,EAAI,OAAO,gBAAgB,IAAI,WAAWD,GAAK,CAAC,CAAC,EAC7D,KAAOA,KACLC,GAAKkB,GAAG,EAAEnB,CAAC,EAAI,EAAE,EACnB,OAAOC,CACT,GA+BI,EAgiBD,MAAAmB,EAAK,OAAO,UAAY,IAAM,UAAU,UAAU,YAAW,EAAG,QAAQ,SAAS,EAAI,EAAI,GAC5F,SAASC,EAAGrB,EAAGC,EAAG,EAAG,EAAG,CACtBD,EAAE,iBAAmBA,EAAE,iBAAiBC,EAAG,EAAG,CAAC,EAAID,EAAE,aAAeA,EAAE,YAAY,KAAK,OAAOC,CAAC,EAAG,CAAC,CACrG,CACA,SAASqB,EAAGtB,EAAGC,EAAG,EAAG,EAAG,CACtBD,EAAE,oBAAsBA,EAAE,oBAAoBC,EAAG,EAAG,CAAC,EAAID,EAAE,aAAeA,EAAE,YAAY,KAAK,OAAOC,CAAC,EAAG,CAAC,CAC3G,CACA,SAASsB,EAAGvB,EAAGC,EAAG,CAChB,MAAM,EAAIA,EAAE,MAAM,EAAGA,EAAE,OAAS,CAAC,EACjC,QAAS,EAAI,EAAG,EAAI,EAAE,OAAQ,IAAK,EAAE,CAAC,EAAID,EAAE,EAAE,CAAC,EAAE,aAAa,EAC9D,OAAO,CACT,CACA,SAASwB,EAAGxB,EAAG,CACb,OAAOA,GAAK,WAAaA,EAAI,IAAKA,EAAIA,EAAE,QAAQ,MAAO,EAAE,EACzD,MAAMC,EAAID,EAAE,MAAM,GAAG,EACrB,IAAI,EAAIC,EAAE,YAAY,EAAE,EACxB,KAAO,GAAK,GACVA,EAAE,EAAI,CAAC,GAAK,IAAKA,EAAE,OAAO,EAAG,CAAC,EAAG,EAAIA,EAAE,YAAY,EAAE,EACvD,OAAOA,CACT,CACA,SAASwB,GAAGzB,EAAGC,EAAG,CAChB,MAAM,EAAID,EAAE,QAAUC,EAAE,OAASD,EAAIC,EAAG,EAAID,EAAE,QAAUC,EAAE,OAASA,EAAID,EACvE,IAAII,EAAI,GACR,QAAS,EAAI,EAAG,EAAI,EAAE,OAAQ,IAC5B,EAAE,QAAQ,EAAE,CAAC,CAAC,IAAM,KAAOA,EAAI,IACjC,OAAOA,CACT,CACA,MAAMsB,EAAK,CACT,UAAW,EACX,IAAK,EACL,IAAK,EACL,MAAO,GACP,MAAO,GACP,IAAK,GACL,OAAQ,GACR,IAAK,GACL,OAAQ,GACR,MAAO,GACP,KAAM,GACN,GAAI,GACJ,MAAO,GACP,KAAM,GACN,IAAK,GACL,OAAQ,GACR,IAAK,GACL,OAAQ,GACR,KAAM,GACN,IAAK,GACL,OAAQ,GACR,SAAU,GACV,SAAU,GACV,MAAO,GACP,MAAO,GACP,MAAO,GACP,MAAO,GACP,MAAO,IACP,MAAO,IACP,MAAO,IACP,MAAO,IACP,MAAO,IACP,MAAO,IACP,aAAc,IACd,QAAS,IACT,UAAW,IACX,aAAc,IACd,YAAa,IACb,WAAY,IACZ,IAAK,GACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAKN,EAAK,IAAM,IAChB,IAAKA,EAAK,GAAK,IACf,IAAKA,EAAK,GAAK,IACf,IAAK,IACL,IAAK,IACL,IAAK,IACL,KAAM,GACR,EAAGO,EAAI,CAEL,IAAK,GACL,MAAO,GAEP,IAAK,GACL,IAAK,GACL,OAAQ,GAER,IAAK,GACL,KAAM,GACN,QAAS,GAET,IAAK,GACL,IAAK,GACL,QAAS,EACX,EAAGC,EAAK,CACN,GAAI,WACJ,GAAI,SACJ,GAAI,UACJ,GAAI,UACJ,SAAU,GACV,QAAS,GACT,OAAQ,GACR,QAAS,EACX,EAAGC,EAAI,CACL,GAAI,GACJ,GAAI,GACJ,GAAI,GACJ,GAAI,EACN,EAAGC,EAAI,CAAE,EACT,QAAS9B,EAAI,EAAGA,EAAI,GAAIA,IACtB0B,EAAG,IAAI,OAAO1B,CAAC,CAAC,EAAI,IAAMA,EAC5B,IAAI+B,EAAI,CAAA,EAAIC,EAAK,KAAMC,EAAK,MAC5B,MAAMC,EAAoB,IAAI,IAAOC,EAAMnC,GAAM0B,EAAG1B,EAAE,YAAW,CAAE,GAAK2B,EAAE3B,EAAE,YAAW,CAAE,GAAKA,EAAE,YAAW,EAAG,WAAW,CAAC,EAAGoC,GAAMpC,GAAM,OAAO,KAAK0B,CAAE,EAAE,KAAMzB,GAAMyB,EAAGzB,CAAC,IAAMD,CAAC,EAAGqC,GAAMrC,GAAM,OAAO,KAAK2B,CAAC,EAAE,KAAM1B,GAAM0B,EAAE1B,CAAC,IAAMD,CAAC,EACpO,SAASsC,EAAGtC,EAAG,CACbiC,EAAKjC,GAAK,KACZ,CACA,SAASuC,GAAK,CACZ,OAAON,GAAM,KACf,CACA,SAASO,IAAK,CACZ,OAAOT,EAAE,MAAM,CAAC,CAClB,CACA,SAASU,IAAK,CACZ,OAAOV,EAAE,IAAK/B,GAAMoC,GAAGpC,CAAC,GAAKqC,GAAGrC,CAAC,GAAK,OAAO,aAAaA,CAAC,CAAC,CAC9D,CACA,SAAS0C,IAAK,CACZ,MAAM1C,EAAI,CAAE,EACZ,OAAO,OAAO,KAAK8B,CAAC,EAAE,QAAS7B,GAAM,CACnC6B,EAAE7B,CAAC,EAAE,QAAS,GAAM,CAClB,GAAI,CACF,IAAK,EACL,MAAOG,EACP,KAAM,EACN,SAAU,CAClB,EAAU,EACJJ,EAAE,KAAK,CACL,MAAOI,EACP,SAAU,EACV,KAAM,EACN,KAAM,EAAE,MAAM,GAAG,EAAE,IAAKC,GAAM8B,EAAG9B,CAAC,CAAC,CAC3C,CAAO,CACP,CAAK,CACF,CAAA,EAAGL,CACN,CACA,SAAS2C,GAAG3C,EAAG,CACb,MAAMC,EAAID,EAAE,QAAUA,EAAE,WAAY,CAClC,QAAS,CACb,EAAMC,EACJ,IAAI,EAAI,GACR,MAAMG,EAAI,IAAM,SAAW,CAAC,CAAC,WAAY,QAAS,QAAS,SAAU,OAAQ,QAAS,SAAU,OAAO,EAAE,SAASH,EAAE,IAAI,EACxH,OAAQA,EAAE,oBAAsBG,GAAK,IAAM,YAAc,IAAM,WAAa,CAACH,EAAE,YAAc,EAAI,IAAK,CACxG,CACA,SAAS2C,GAAG5C,EAAG,CACb,OAAO,OAAOA,GAAK,WAAaA,EAAImC,EAAGnC,CAAC,GAAI+B,EAAE,QAAQ/B,CAAC,IAAM,EAC/D,CACA,SAAS6C,GAAG7C,EAAGC,EAAG,CAChB,IAAI,EAAG,EACPD,IAAMA,EAAIuC,KACV,UAAWnC,KAAK0B,EACd,GAAI,OAAO,UAAU,eAAe,KAAKA,EAAG1B,CAAC,EAC3C,IAAK,EAAI0B,EAAE1B,CAAC,EAAG,EAAI,EAAG,EAAI,EAAE,QAC1B,EAAE,CAAC,EAAE,QAAUJ,EAAI,EAAE,OAAO,EAAG,CAAC,EAAE,QAASc,GAAM,CAC/C,GAAI,CACF,QAAST,CACrB,EAAcS,EACJ,OAAOgC,EAAGzC,CAAC,CACZ,CAAA,EAAI,IACXkC,EAAI,IAAKvC,GAAKsC,EAAGrC,GAAK,KAAK,CAC7B,CACA,SAAS8C,GAAG/C,EAAG,CACb,IAAIC,EAAID,EAAE,SAAWA,EAAE,OAASA,EAAE,SAClC,MAAM,EAAI+B,EAAE,QAAQ9B,CAAC,EACrB,GAAI,GAAK,GAAK8B,EAAE,OAAO,EAAG,CAAC,EAAG/B,EAAE,KAAOA,EAAE,IAAI,YAAa,IAAK,QAAU+B,EAAE,OAAO,EAAGA,EAAE,MAAM,GAAI9B,IAAM,IAAMA,IAAM,OAASA,EAAI,IAAKA,KAAK4B,EAAG,CAC3IA,EAAE5B,CAAC,EAAI,GACP,UAAW,KAAK0B,EAAGA,EAAE,CAAC,IAAM1B,IAAM+C,EAAE,CAAC,EAAI,GAC7C,CACA,CACA,SAASC,EAAGjD,EAAG,CACb,GAAI,OAAOA,EAAI,IACb,OAAO,KAAK8B,CAAC,EAAE,QAAS1B,GAAM,CAC5B,MAAM,QAAQ0B,EAAE1B,CAAC,CAAC,GAAK0B,EAAE1B,CAAC,EAAE,QAAS,GAAM8C,EAAG,CAAC,CAAC,EAAG,OAAOpB,EAAE1B,CAAC,CACnE,CAAK,EAAG0C,EAAG,IAAI,UACJ,MAAM,QAAQ9C,CAAC,EACtBA,EAAE,QAASI,GAAM,CACfA,EAAE,KAAO8C,EAAG9C,CAAC,CACnB,CAAK,UACM,OAAOJ,GAAK,SACnBA,EAAE,KAAOkD,EAAGlD,CAAC,UACN,OAAOA,GAAK,SAAU,CAC7B,QAASC,EAAI,UAAU,OAAQ,EAAI,IAAI,MAAMA,EAAI,EAAIA,EAAI,EAAI,CAAC,EAAG,EAAI,EAAG,EAAIA,EAAG,IAC7E,EAAE,EAAI,CAAC,EAAI,UAAU,CAAC,EACxB,GAAI,CAACG,EAAG,CAAC,EAAI,EACb,OAAOA,GAAK,aAAe,EAAIA,EAAGA,EAAI,IAAK8C,EAAG,CAC5C,IAAKlD,EACL,MAAOI,EACP,OAAQ,EACR,SAAU,GAChB,CAAK,CACL,CACA,CACA,MAAM8C,EAAMlD,GAAM,CAChB,GAAI,CACF,IAAKC,EACL,MAAO,EACP,OAAQ,EACR,SAAUG,EAAI,GAClB,EAAMJ,EACJwB,EAAGvB,CAAC,EAAE,QAASa,GAAM,CACnB,MAAMT,EAAIS,EAAE,MAAMV,CAAC,EAAGW,EAAIV,EAAE,OAAQ8C,EAAI9C,EAAEU,EAAI,CAAC,EAAGR,EAAI4C,IAAM,IAAM,IAAMhB,EAAGgB,CAAC,EAC5E,GAAI,CAACrB,EAAEvB,CAAC,EAAG,OACX,IAAM,EAAIgC,KACV,MAAM/B,EAAIO,EAAI,EAAIQ,EAAGI,EAAGtB,CAAC,EAAI,GAAIO,EAAI,CAAE,EACvCkB,EAAEvB,CAAC,EAAIuB,EAAEvB,CAAC,EAAE,OAAQM,GAAM,CACxB,MAAMuC,GAAK,EAAIvC,EAAE,SAAW,EAAI,KAAOA,EAAE,QAAU,GAAKY,GAAGZ,EAAE,KAAML,CAAC,EACpE,OAAO4C,GAAKxC,EAAE,KAAKC,EAAE,OAAO,EAAG,CAACuC,CACtC,CAAK,EAAGxC,EAAE,QAASC,GAAMiC,EAAGjC,CAAC,CAAC,CAC9B,CAAG,CACH,EACA,SAASwC,EAAGrD,EAAGC,EAAG,EAAG,EAAG,CACtB,GAAIA,EAAE,UAAY,EAChB,OACF,IAAIG,EACJ,GAAIH,EAAE,QAAU,GAAKA,EAAE,QAAU,MAAO,CACtCG,EAAIH,EAAE,KAAK,OAAS,EACpB,UAAW,KAAK4B,EACd,OAAO,UAAU,eAAe,KAAKA,EAAG,CAAC,IAAM,CAACA,EAAE,CAAC,GAAK5B,EAAE,KAAK,QAAQ,CAAC,CAAC,EAAI,IAAM4B,EAAE,CAAC,GAAK5B,EAAE,KAAK,QAAQ,CAAC,CAAC,IAAM,MAAQG,EAAI,KAC/HH,EAAE,KAAK,SAAW,GAAK,CAAC4B,EAAE,EAAE,GAAK,CAACA,EAAE,EAAE,GAAK,CAACA,EAAE,EAAE,GAAK,CAACA,EAAE,EAAE,GAAKzB,GAAKH,EAAE,WAAa,OAASA,EAAE,KAAO,CAAE,EAAEA,EAAE,KAAOA,EAAE,KAAK,OAAO8B,CAAC,EAAG9B,EAAE,OAAOD,EAAGC,CAAC,IAAM,KAAOD,EAAE,eAAiBA,EAAE,eAAc,EAAKA,EAAE,YAAc,GAAIA,EAAE,iBAAmBA,EAAE,gBAAe,EAAIA,EAAE,eAAiBA,EAAE,aAAe,KAC7S,CACA,CACA,SAASsD,EAAGtD,EAAGC,EAAG,CAChB,MAAM,EAAI6B,EAAE,GAAG,EACf,IAAI,EAAI9B,EAAE,SAAWA,EAAE,OAASA,EAAE,SAClC,GAAI,CAACgD,EAAE,OAAO,KAAK,KAAMhD,CAAC,EAAG,OAC7B,IAAK,IAAM,IAAM,IAAM,OAAS,EAAI,IAAK+B,EAAE,QAAQ,CAAC,IAAM,IAAM,IAAM,KAAOA,EAAE,KAAK,CAAC,EAAG,CAAC,UAAW,UAAW,SAAU,UAAU,EAAE,QAAS1B,GAAM,CAClJ,MAAM,EAAIuB,EAAGvB,CAAC,EACdL,EAAEK,CAAC,GAAK0B,EAAE,QAAQ,CAAC,IAAM,GAAKA,EAAE,KAAK,CAAC,EAAI,CAAC/B,EAAEK,CAAC,GAAK0B,EAAE,QAAQ,CAAC,EAAI,GAAKA,EAAE,OAAOA,EAAE,QAAQ,CAAC,EAAG,CAAC,EAAI1B,IAAM,WAAaL,EAAEK,CAAC,IAAM0B,EAAIA,EAAE,OAAQoB,GAAMA,KAAKvB,GAAMuB,IAAM,CAAC,EACzK,CAAG,EAAG,KAAKtB,EAAG,CACVA,EAAE,CAAC,EAAI,GACP,UAAWxB,KAAKsB,EACdA,EAAEtB,CAAC,IAAM,IAAM2C,EAAE3C,CAAC,EAAI,IACxB,GAAI,CAAC,EAAG,MACZ,CACE,UAAWA,KAAKwB,EACd,OAAO,UAAU,eAAe,KAAKA,EAAGxB,CAAC,IAAMwB,EAAExB,CAAC,EAAIL,EAAE4B,EAAGvB,CAAC,CAAC,GAC/DL,EAAE,kBAAoB,EAAEA,EAAE,QAAU,CAACA,EAAE,UAAYA,EAAE,iBAAiB,UAAU,IAAM+B,EAAE,QAAQ,EAAE,IAAM,IAAMA,EAAE,KAAK,EAAE,EAAGA,EAAE,QAAQ,EAAE,IAAM,IAAMA,EAAE,KAAK,EAAE,EAAGF,EAAE,EAAE,EAAI,GAAIA,EAAE,EAAE,EAAI,IAClL,MAAMzB,EAAImC,EAAI,EACd,GAAI,EACF,QAASlC,EAAI,EAAGA,EAAI,EAAE,OAAQA,IAC5B,EAAEA,CAAC,EAAE,QAAUD,IAAMJ,EAAE,OAAS,WAAa,EAAEK,CAAC,EAAE,SAAWL,EAAE,OAAS,SAAW,EAAEK,CAAC,EAAE,QAAUgD,EAAGrD,EAAG,EAAEK,CAAC,EAAGD,EAAGH,CAAC,EACtH,GAAI,EAAE,KAAK6B,GAAI,OACf,MAAM,EAAIA,EAAE,CAAC,EAAG,EAAI,EAAE,OACtB,QAASzB,EAAI,EAAGA,EAAI,EAAGA,IACrB,IAAKL,EAAE,OAAS,WAAa,EAAEK,CAAC,EAAE,SAAWL,EAAE,OAAS,SAAW,EAAEK,CAAC,EAAE,QAAU,EAAEA,CAAC,EAAE,IAAK,CAC1F,MAAM,EAAI,EAAEA,CAAC,EAAG,CACd,SAAU8C,CAClB,EAAU,EAAG5C,EAAI,EAAE,IAAI,MAAM4C,CAAC,EAAG3C,EAAI,CAAE,EACjC,QAASI,EAAI,EAAGA,EAAIL,EAAE,OAAQK,IAC5BJ,EAAE,KAAK2B,EAAG5B,EAAEK,CAAC,CAAC,CAAC,EACjBJ,EAAE,KAAI,EAAG,KAAK,EAAE,IAAMuB,EAAE,KAAI,EAAG,KAAK,EAAE,GAAKsB,EAAGrD,EAAG,EAAGI,EAAGH,CAAC,CAC9D,CACA,CACA,SAAS+C,EAAEhD,EAAGC,EAAG,EAAG,CAClB8B,EAAI,CAAE,EACN,MAAM,EAAIP,EAAGxB,CAAC,EACd,IAAII,EAAI,CAAE,EAAE,EAAI,MAAO,EAAI,SAAUC,EAAI,EAAG,EAAI,GAAI8C,EAAI,GAAI5C,EAAI,IAAKC,EAAI,GAAII,EAAI,GACjF,IAAK,IAAM,QAAU,OAAOX,GAAK,aAAe,EAAIA,GAAI,OAAO,UAAU,SAAS,KAAKA,CAAC,IAAM,oBAAsBA,EAAE,QAAU,EAAIA,EAAE,OAAQA,EAAE,UAAY,EAAIA,EAAE,SAAUA,EAAE,QAAU,EAAIA,EAAE,OAAQA,EAAE,UAAY,SAAWkD,EAAIlD,EAAE,SAAUA,EAAE,UAAY,SAAWO,EAAIP,EAAE,SAAU,OAAOA,EAAE,UAAY,WAAaM,EAAIN,EAAE,UAAWA,EAAE,SAAW,KAAOW,EAAI,KAAM,OAAOX,GAAK,WAAa,EAAIA,GAAIW,GAAKqC,EAAGjD,EAAG,CAAC,EAAGK,EAAI,EAAE,OAAQA,IACraL,EAAI,EAAEK,CAAC,EAAE,MAAME,CAAC,EAAGH,EAAI,GAAIJ,EAAE,OAAS,IAAMI,EAAImB,EAAGI,EAAG3B,CAAC,GAAIA,EAAIA,EAAEA,EAAE,OAAS,CAAC,EAAGA,EAAIA,IAAM,IAAM,IAAMmC,EAAGnC,CAAC,EAAGA,KAAK8B,IAAMA,EAAE9B,CAAC,EAAI,CAAA,GAAK8B,EAAE9B,CAAC,EAAE,KAAK,CAC5I,MAAO,EACP,QAASmD,EACT,MAAO,EACP,KAAM/C,EACN,SAAU,EAAEC,CAAC,EACb,OAAQ,EACR,IAAK,EAAEA,CAAC,EACR,SAAUE,EACV,QAAS,CACf,CAAK,EACH,GAAI,OAAO,EAAI,KAAO,OAAQ,CAC5B,GAAI,CAAC2B,EAAE,IAAI,CAAC,EAAG,CACb,MAAMrB,EAAI,UAAW,CACnB,IAAIuC,EAAI,UAAU,OAAS,GAAK,UAAU,CAAC,IAAM,OAAS,UAAU,CAAC,EAAI,OAAO,MAChF,OAAOE,EAAGF,EAAG,CAAC,CACf,EAAEG,EAAI,UAAW,CAChB,IAAIH,EAAI,UAAU,OAAS,GAAK,UAAU,CAAC,IAAM,OAAS,UAAU,CAAC,EAAI,OAAO,MAChFE,EAAGF,EAAG,CAAC,EAAGL,GAAGK,CAAC,CACf,EACDlB,EAAE,IAAI,EAAG,CACP,gBAAiBrB,EACjB,aAAc0C,EACd,QAAS/C,CACV,CAAA,EAAGa,EAAG,EAAG,UAAWR,EAAGL,CAAC,EAAGa,EAAG,EAAG,QAASkC,EAAG/C,CAAC,CACrD,CACI,GAAI,CAACwB,EAAI,CACP,MAAMnB,EAAI,IAAM,CACdkB,EAAI,CAAE,CACP,EACDC,EAAK,CACH,SAAUnB,EACV,QAASL,CACV,EAAEa,EAAG,OAAQ,QAASR,EAAGL,CAAC,CACjC,CACA,CACA,CACA,SAASgD,GAAGxD,EAAG,CACb,IAAIC,EAAI,UAAU,OAAS,GAAK,UAAU,CAAC,IAAM,OAAS,UAAU,CAAC,EAAI,MACzE,OAAO,KAAK6B,CAAC,EAAE,QAAS,GAAM,CAC5BA,EAAE,CAAC,EAAE,OAAQ1B,GAAMA,EAAE,QAAUH,GAAKG,EAAE,WAAaJ,CAAC,EAAE,QAASI,GAAM,CACnEA,GAAKA,EAAE,QAAUA,EAAE,OAAQ,CACjC,CAAK,CACL,CAAG,CACH,CACA,SAAS0C,EAAG9C,EAAG,CACb,MAAMC,EAAI,OAAO,OAAO6B,CAAC,EAAE,KAAM,EACjC,GAAI7B,EAAE,UAAWS,GAAM,CACrB,GAAI,CACF,QAASN,CACf,EAAQM,EACJ,OAAON,IAAMJ,CACd,CAAA,EAAI,EAAG,CACN,KAAM,CACJ,gBAAiBU,EACjB,aAAcN,EACd,QAASO,CACV,EAAGuB,EAAE,IAAIlC,CAAC,GAAK,CAAE,EAClBU,GAAKN,IAAMkB,EAAGtB,EAAG,QAASI,EAAGO,CAAC,EAAGW,EAAGtB,EAAG,UAAWU,EAAGC,CAAC,EAAGuB,EAAE,OAAOlC,CAAC,EACvE,CACE,IAAKC,EAAE,QAAU,GAAKiC,EAAE,MAAQ,KAAO,OAAO,KAAKA,CAAC,EAAE,QAAS9B,GAAM,CACnE,KAAM,CACJ,gBAAiBO,EACjB,aAAcG,EACd,QAAST,CACV,EAAG6B,EAAE,IAAI9B,CAAC,GAAK,CAAE,EAClBO,GAAKG,IAAMQ,EAAGlB,EAAG,QAASU,EAAGT,CAAC,EAAGiB,EAAGlB,EAAG,UAAWO,EAAGN,CAAC,EAAG6B,EAAE,OAAO9B,CAAC,EACvE,CAAG,EAAG8B,EAAE,MAAK,EAAI,OAAO,KAAKJ,CAAC,EAAE,QAAS1B,GAAM,OAAO0B,EAAE1B,CAAC,CAAC,EAAG4B,GAAK,CAC9D,KAAM,CACJ,SAAU5B,EACV,QAASO,CACf,EAAQqB,EACJV,EAAG,OAAQ,QAASlB,EAAGO,CAAC,EAAGqB,EAAK,IACpC,CACA,CACA,MAAMyB,EAAK,CACT,oBAAqBhB,GACrB,SAAUH,EACV,SAAUC,EACV,YAAaM,GACb,mBAAoBL,GACpB,eAAgBE,GAChB,UAAWE,GACX,OAAQD,GACR,QAASa,GACT,OAAQP,EACR,OAAQvB,EACR,SAAUC,EACV,YAAaC,CACf,EACA,UAAW5B,KAAKyD,EACd,OAAO,UAAU,eAAe,KAAKA,EAAIzD,CAAC,IAAMgD,EAAEhD,CAAC,EAAIyD,EAAGzD,CAAC,GAC7D,GAAI,OAAO,OAAS,IAAK,CACvB,MAAMA,EAAI,OAAO,QACjBgD,EAAE,WAAc/C,IAAOA,GAAK,OAAO,UAAY+C,IAAM,OAAO,QAAUhD,GAAIgD,GAAI,OAAO,QAAUA,CACjG,CChoEO,MAAMU,GAAW,CAACC,EAAoBC,EAAkBC,IAA2B,CACxF,IAAIC,EAAOH,EAEPI,EAASF,EAEb,MAAMG,EAAK,SAAS,mBAAmBJ,EAAY,WAAW,SAAS,EAEnE,IAAAK,EAAcD,EAAG,SAAS,EAE1BE,EAAM,GAEP,GACGD,aAAuB,OACrBA,EAAY,OAASF,EACvBA,GAAUE,EAAY,QAEfH,EAAAG,EACDC,EAAA,KAIVD,EAAcD,EAAG,SAAS,QACnBC,GAAeC,GAEjB,MAAA,CAAE,KAAAJ,EAAM,OAAAC,CAAO,CACxB,ECVMI,EAAW,CAACL,EAAYM,EAAiB,KAAO,CAChD,IAAAC,EACAC,EACAC,EAQA,GANAT,EAAK,WAAa,KAAK,cAAiBA,EAAiB,aAAa,QAAQ,EAChFM,EAAK,KAAK,GAAG,EACJN,EAAK,aACPM,EAAAD,EAASL,EAAK,WAAYM,CAAI,GAGnCN,EAAK,WAAa,KAAK,cAAgBA,EAAK,SAAS,YAAY,EAAE,WAAW,MAAM,EAAG,CACzF,MAAMU,EAAKV,EAEPU,EAAG,aAAa,QAAQ,EAC1BD,EAAY,aAAaC,EAAG,aAAa,QAAQ,CAAC,MAE1CH,EAAA,4BAA4BG,EAAG,SAAS,IACxCF,EAAA,SAAS,SAASD,EAAOP,EAAM,KAAM,YAAY,YAAa,IAAI,EAAE,YAAc,EAE1FS,EAAY,IAAID,CAAK,KAGvBF,EAAK,KAAK,GAAG,EACbA,EAAK,KAAKI,EAAG,aAAa,eAAe,EAAID,CAAS,CAAA,CAGjD,OAAAH,CACT,EAMMK,GAAc,CAACC,EAAqBC,EAAmBC,IAAyB,CAE9E,MAAAC,EAAqBf,GACpBA,EAEGA,EAAK,SAAS,YAAA,EAAc,QAAQ,MAAM,IAAM,EACtDA,EAAOe,EAAkBf,EAAK,UAAU,EAHxB,KAOdgB,EAAkB,CAACC,EAAgBC,EAAcC,IAAqB,CACpE,MAAAC,EAAQ,SAAS,YAAY,EAC7B,OAAAA,EAAA,SAASH,EAAU,CAAC,EACpBG,EAAA,OAAOF,EAAQC,CAAQ,EACtBC,EAAM,WAAW,MAC1B,EAEMC,EAAcL,EAClBD,EAAkBD,EAAc,cAAc,EAC9CA,EAAc,eACdA,EAAc,WAAW,EAErBQ,EAAYN,EAChBD,EAAkBD,EAAc,YAAY,EAC5CA,EAAc,aACdA,EAAc,SAAS,EAEnBS,EAAQX,EAAU,KAAK,EAAE,EAAI,KAAOS,EACpCG,EAAMX,EAAQ,KAAK,EAAE,EAAI,KAAOS,EAE/B,MAAA,CAAE,MAAAC,EAAO,IAAAC,CAAI,CACtB,EAOaC,GAAqBC,GAA6C,OACvE,KAAA,CAAE,MAAAN,GAAUM,EAGZC,EAA8BtB,EAASe,EAAM,cAAc,EAC3DQ,EAA4BvB,EAASe,EAAM,YAAY,EAGvD,CAAE,MAAAG,EAAO,IAAAC,GAAQb,GAAYgB,EAAmBC,EAAiBR,CAAK,EAErE,MAAA,CACL,MAAOM,EAAS,MAChB,cAAe,CACb,KAAM,gBACN,MAAOH,CACT,EACA,IAAKG,EAAS,IACd,YAAa,CACX,KAAM,gBACN,MAAOF,CACT,EACA,OAAOK,EAAAH,EAAS,QAAT,YAAAG,EAAgB,QAAQ,OAAQ,KACvC,MAAAT,CACF,CACF,EAEaU,GAAe,CAAC5F,EAAyB6F,IAA2B,SACzE,MAAAL,EAAW,MAAM,QAAQxF,EAAE,QAAQ,EAAIA,EAAE,SAAS,CAAC,EAAIA,EAAE,SAE3D,GAAA,UAAWwF,GAAY,QAASA,EAC3B,OAAAM,EAAuB9F,EAAG6F,CAAS,EACrC,CACC,MAAAE,GAAmBJ,EAAAH,EAA8B,gBAA9B,YAAAG,EAA6C,MAChEK,GAAiBC,EAAAT,EAA8B,cAA9B,YAAAS,EAA2C,MAE9D,GAAA,CAACF,GAAmB,CAACC,EACvB,cAAQ,MAAMhG,CAAC,EACT,+BAGF,MAAAkG,EAAoBC,GAAkB,CACpC,MAAAC,EAAWD,EAAM,QAAQ,IAAI,EAEnC,GAAIC,EAAW,EAAG,OAEZ,MAAAhC,GAAO+B,EAAM,UAAU,EAAGC,CAAQ,EAAE,QAAQ,cAAe,CAACtE,GAAGuE,KAC5D,QAAUA,GAAG,YAAY,CACjC,EAAE,QAAQ,QAAS,EAAE,EAEhBvC,GAAO,SAAS,SAAS,IAAMM,GACnCyB,EAAW,KAAM,YAAY,wBAAyB,IAAA,EAAM,gBAExD9B,GAAS,SAASoC,EAAM,UAAUC,EAAW,CAAC,CAAC,EAE9C,MAAA,CAACtC,GAAMC,EAAM,CACtB,EAEM,CAACuC,EAAWnB,CAAW,EAAIe,EAAiBH,CAAe,EAC3D,CAACQ,EAASnB,CAAS,EAAIc,EAAiBF,CAAa,EAErDd,EAAQ,SAAS,YAAY,EAG7BsB,EAAmB,CAACC,EAAc1C,IAClC0C,EAAO,sBAAsB,MAAQA,EAAO,WAAW,QAAU1C,EAC5D,CAAE,KAAM0C,EAAO,WAAY,OAAA1C,CAAO,EAElCL,GAAS+C,EAAO,WAAYA,EAAQ1C,CAAM,EAI/C2C,EAAkBF,EAAiBF,EAAWnB,CAAW,EAC/DD,EAAM,SAASwB,EAAgB,KAAMA,EAAgB,MAAM,EAErD,MAAAC,EAAgBH,EAAiBD,EAASnB,CAAS,EACzDF,EAAM,OAAOyB,EAAc,KAAMA,EAAc,MAAM,EAE/C,MAAAC,GAAeC,EAAgB3B,EAAOW,CAAS,EAErD,OAAOC,EAAuB,CAC5B,GAAG9F,EACH,SAAU,CAAC,CACT,GAAG4G,GACH,GAAIpB,EACJ,MAAAN,CACD,CAAA,GACAW,CAAS,CAAA,CAEhB,EAEaiB,EAAoBjB,GAA4B,GAAiD,CACtG,MAAAkB,EAASnB,GAAa,EAAGC,CAAS,EACjC,MAAA,CACL,GAAG,EACH,SAAUkB,EAAO,SAAS,IAAIxB,EAAiB,CACjD,CACF,EAEayB,GAAuBnB,GAA4B/E,IAAsC,CACpG,GAAGA,EACH,OAAQgG,EAAgBjB,CAAS,EAAE/E,EAAE,MAAM,CAC7C,GCzJamG,GAAaC,GAA8C,CAEtE,MAAMrB,EAAyBqB,EAAK,QAE9BC,EAAQH,GAAoBnB,CAAS,EAErCuB,EAAcN,EAAgBjB,CAAS,EAGvCwB,EAAQH,EAAK,MAAM,MAEnBI,EAAiBD,EAAM,cACvBA,EAAA,cAAgB,CAACE,EAA4CC,IAAmB,CAC9E,KAAA,CAAE,SAAAhC,GAAa+B,EAAW,OAChC,MAAQ,kBAAmB/B,GAAY,UAAWA,EAChD8B,EAAeC,EAAYC,CAAM,EACjCF,EAAeH,EAAMI,CAAU,EAAGC,CAAM,CAC5C,EAEA,MAAMC,EAAqBJ,EAAM,kBACjCA,EAAM,kBAAoB,CAACK,EAAoDC,EAAU,GAAMH,IAAmB,CAC1G,MAAAI,EAAiBF,EAAY,IAAS5G,GAAA,CACpC,KAAA,CAAE,SAAA0E,GAAa1E,EAAE,OACvB,MAAQ,kBAAmB0E,GAAY,UAAWA,EAAY1E,EAAIqG,EAAMrG,CAAC,CAAA,CAC1E,EAEM,OAAA2G,EAAmBG,EAAgBD,EAASH,CAAM,CAC3D,EAEA,MAAMK,EAAoBR,EAAM,iBAC1BA,EAAA,iBAAmB,CAACE,EAA4CC,IACpEK,EAAkBV,EAAMI,CAAU,EAAGC,CAAM,EAE7C,MAAMM,EAAgBT,EAAM,aACtB,OAAAA,EAAA,aAAe,CAACN,EAAoDS,IACxEM,EAAcV,EAAYL,CAAM,EAAGS,CAAM,EAEpC,CACL,GAAGN,EACH,MAAO,CACL,GAAGA,EAAK,MAER,MAAAG,CAAA,CAEJ,CAEF"}