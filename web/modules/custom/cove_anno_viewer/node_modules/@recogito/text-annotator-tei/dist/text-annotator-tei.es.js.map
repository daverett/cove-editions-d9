{"version":3,"file":"text-annotator-tei.es.js","sources":["../../text-annotator/dist/text-annotator.es.js","../src/crosswalk/utils/reanchor.ts","../src/crosswalk/forward.ts","../src/TEIPlugin.ts"],"sourcesContent":["const re = \"not-annotatable\", tt = `.${re}`, it = (t) => {\n  var n;\n  return !!(t instanceof HTMLElement ? t.closest(tt) : (n = t.parentElement) == null ? void 0 : n.closest(tt));\n}, Ce = (t) => {\n  const e = t.commonAncestorContainer;\n  return !it(e);\n}, Le = (t) => t.addEventListener(\"click\", (e) => {\n  // Allow clicks within not-annotatable elements\n  !e.target.closest(tt) && !e.target.closest(\"a\") && e.preventDefault();\n}), xt = (t) => ({\n  ...t,\n  type: t.type,\n  x: t.x,\n  y: t.y,\n  clientX: t.clientX,\n  clientY: t.clientY,\n  offsetX: t.offsetX,\n  offsetY: t.offsetY,\n  screenX: t.screenX,\n  screenY: t.screenY,\n  isPrimary: t.isPrimary,\n  altKey: t.altKey,\n  ctrlKey: t.ctrlKey,\n  metaKey: t.metaKey,\n  shiftKey: t.shiftKey,\n  button: t.button,\n  buttons: t.buttons,\n  currentTarget: t.currentTarget,\n  target: t.target,\n  defaultPrevented: t.defaultPrevented,\n  detail: t.detail,\n  eventPhase: t.eventPhase,\n  pointerId: t.pointerId,\n  pointerType: t.pointerType,\n  timeStamp: t.timeStamp\n}), ft = (t) => ({\n  ...t,\n  type: t.type,\n  key: t.key,\n  code: t.code,\n  location: t.location,\n  repeat: t.repeat,\n  altKey: t.altKey,\n  ctrlKey: t.ctrlKey,\n  metaKey: t.metaKey,\n  shiftKey: t.shiftKey,\n  currentTarget: t.currentTarget,\n  target: t.target,\n  defaultPrevented: t.defaultPrevented,\n  detail: t.detail,\n  timeStamp: t.timeStamp\n}), Te = /mac/i.test(navigator.userAgentData ? navigator.userAgentData.platform : navigator.platform), Oe = (t) => {\n  !t.hasAttribute(\"tabindex\") && t.tabIndex < 0 && t.setAttribute(\"tabindex\", \"-1\"), t.classList.add(\"no-focus-outline\");\n}, Yt = (t, e = 10) => {\n  let n;\n  return (...o) => {\n    clearTimeout(n), n = setTimeout(() => t.apply(void 0, o), e);\n  };\n}, Be = function* (t) {\n  const e = document.createNodeIterator(\n    t.commonAncestorContainer,\n    NodeFilter.SHOW_ELEMENT,\n    (o) => o instanceof HTMLElement && o.classList.contains(re) && !o.parentElement.closest(tt) && t.intersectsNode(o) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP\n  );\n  let n;\n  for (; n = e.nextNode(); )\n    n instanceof HTMLElement && (yield n);\n}, Me = (t) => {\n  if (!Ce(t)) return [];\n  const e = [];\n  let n = null;\n  for (const o of Be(t)) {\n    let i;\n    n ? (i = document.createRange(), i.setStartAfter(n), i.setEndBefore(o)) : (i = t.cloneRange(), i.setEndBefore(o)), i.collapsed || e.push(i), n = o;\n  }\n  if (n) {\n    const o = t.cloneRange();\n    o.setStartAfter(n), o.collapsed || e.push(o);\n  }\n  return e.length > 0 ? e : [t];\n}, Ut = (t) => {\n  const e = t.cloneContents();\n  return e.querySelectorAll(tt).forEach((n) => n.remove()), e;\n}, Re = (t, e, n = 10, o) => {\n  const i = o ? t.startContainer.parentElement.closest(o) : e, s = document.createRange();\n  s.setStart(i, 0), s.setEnd(t.startContainer, t.startOffset);\n  const a = Ut(s).textContent, r = document.createRange();\n  r.setStart(t.endContainer, t.endOffset), i === document.body ? r.setEnd(i, i.childNodes.length) : r.setEndAfter(i);\n  const d = Ut(r).textContent;\n  return {\n    prefix: a.substring(a.length - n),\n    suffix: d.substring(0, n)\n  };\n}, F = (t) => t.every((e) => e.range instanceof Range && !e.range.collapsed), ke = /^\\s*$/, Ie = (t) => ke.test(t.toString()), _e = (t, e) => {\n  const n = (s) => Math.round(s * 10) / 10, o = {\n    top: n(t.top),\n    bottom: n(t.bottom),\n    left: n(t.left),\n    right: n(t.right)\n  }, i = {\n    top: n(e.top),\n    bottom: n(e.bottom),\n    left: n(e.left),\n    right: n(e.right)\n  };\n  if (Math.abs(o.top - i.top) < 0.5 && Math.abs(o.bottom - i.bottom) < 0.5) {\n    if (Math.abs(o.left - i.right) < 0.5 || Math.abs(o.right - i.left) < 0.5)\n      return \"inline-adjacent\";\n    if (o.left >= i.left && o.right <= i.right)\n      return \"inline-is-contained\";\n    if (o.left <= i.left && o.right >= i.right)\n      return \"inline-contains\";\n  } else if (o.top <= i.top && o.bottom >= i.bottom) {\n    if (o.left <= i.left && o.right >= i.right)\n      return \"block-contains\";\n  } else if (o.top >= i.top && o.bottom <= i.bottom && o.left >= i.left && o.right <= i.right)\n    return \"block-is-contained\";\n}, Ne = (t, e) => {\n  const n = Math.min(t.left, e.left), o = Math.max(t.right, e.right), i = Math.min(t.top, e.top), s = Math.max(t.bottom, e.bottom);\n  return new DOMRect(n, i, o - n, s - i);\n}, Ue = (t) => t.reduce((e, n) => {\n  if (n.width === 0 || n.height === 0)\n    return e;\n  let o = [...e], i = !1;\n  for (const s of e) {\n    const a = _e(n, s);\n    if (a === \"inline-adjacent\") {\n      o = o.map((r) => r === s ? Ne(n, s) : r), i = !0;\n      break;\n    } else if (a === \"inline-contains\") {\n      o = o.map((r) => r === s ? n : r), i = !0;\n      break;\n    } else if (a === \"inline-is-contained\") {\n      i = !0;\n      break;\n    } else if (a === \"block-contains\" || a === \"block-is-contained\") {\n      n.width < s.width && (o = o.map((r) => r === s ? n : r)), i = !0;\n      break;\n    }\n  }\n  return i ? o : [...o, n];\n}, []), wo = (t) => ({\n  length: t.length,\n  item: (e) => t[e],\n  [Symbol.iterator]: function* () {\n    for (let e = 0; e < this.length; e++)\n      yield this.item(e);\n  }\n}), Ve = (t, e, n) => {\n  const o = document.createRange(), i = n ? t.startContainer.parentElement.closest(n) : e;\n  o.setStart(i, 0), o.setEnd(t.startContainer, t.startOffset);\n  const s = Ut(o).textContent, a = t.toString(), r = s.length || 0, d = r + a.length;\n  return n ? { quote: a, start: r, end: d, range: t, offsetReference: i } : { quote: a, start: r, end: d, range: t };\n}, ae = (t, e) => {\n  var h, u;\n  const { start: n, end: o } = t, i = t.offsetReference || e, s = document.createNodeIterator(\n    e,\n    NodeFilter.SHOW_TEXT,\n    (g) => {\n      var v;\n      return (v = g.parentElement) != null && v.closest(tt) ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;\n    }\n  );\n  let a = 0;\n  const r = document.createRange();\n  let d = s.nextNode();\n  d === null && console.error(\"Could not revive annotation target. Content missing.\");\n  let f = !i;\n  for (; d !== null; ) {\n    if (f || (f = i == null ? void 0 : i.contains(d)), f) {\n      const g = ((h = d.textContent) == null ? void 0 : h.length) || 0;\n      if (a + g > n) {\n        r.setStart(d, n - a);\n        break;\n      }\n      a += g;\n    }\n    d = s.nextNode();\n  }\n  for (; d !== null; ) {\n    const g = ((u = d.textContent) == null ? void 0 : u.length) || 0;\n    if (a + g >= o) {\n      r.setEnd(d, o - a);\n      break;\n    }\n    a += g, d = s.nextNode();\n  }\n  return {\n    ...t,\n    range: r\n  };\n}, wt = (t, e) => F(t.selector) ? t : {\n  ...t,\n  selector: t.selector.map((n) => n.range instanceof Range && !n.range.collapsed ? n : ae(n, e))\n}, vt = (t, e) => F(t.target.selector) ? t : { ...t, target: wt(t.target, e) }, Ye = (t, e) => {\n  const n = t.cloneRange();\n  return e.contains(n.startContainer) || n.setStart(e, 0), e.contains(n.endContainer) || n.setEnd(e, e.childNodes.length), n;\n}, ce = (t) => {\n  if (t === null)\n    return document.scrollingElement;\n  const { overflowY: e } = window.getComputedStyle(t);\n  return e !== \"visible\" && e !== \"hidden\" && t.scrollHeight > t.clientHeight ? t : ce(t.parentElement);\n}, De = (t, e) => (n) => {\n  const o = typeof n == \"string\" ? n : n.id, i = (a) => {\n    const r = s.getBoundingClientRect(), d = s.clientHeight, f = s.clientWidth, h = a.selector[0].range.getBoundingClientRect(), { width: u, height: g } = e.getAnnotationBounds(o), v = h.top - r.top, p = h.left - r.left, y = s.parentElement ? s.scrollTop : 0, x = s.parentElement ? s.scrollLeft : 0, l = v + y - (d - g) / 2, c = p + x - (f - u) / 2;\n    s.scroll({ top: l, left: c, behavior: \"smooth\" });\n  }, s = ce(t);\n  if (s) {\n    const a = e.getAnnotation(o), { range: r } = a.target.selector[0];\n    if (r && !r.collapsed)\n      return i(a.target), !0;\n    {\n      const d = wt(a.target, t), { range: f } = d.selector[0];\n      if (f && !f.collapsed)\n        return i(d), !0;\n    }\n  }\n  return !1;\n}, W = {\n  fill: \"rgb(0, 128, 255)\",\n  fillOpacity: 0.18\n}, At = {\n  fill: \"rgb(0, 128, 255)\",\n  fillOpacity: 0.45\n}, Ke = (t, e, n, o, i) => {\n  var a, r;\n  const s = n ? typeof n == \"function\" ? n(t.annotation, t.state, i) || ((a = t.state) != null && a.selected ? At : W) : n : (r = t.state) != null && r.selected ? At : W;\n  return o && o.paint(t, e) || s;\n}, Xe = (t) => {\n  const { top: e, left: n } = t.getBoundingClientRect(), { innerWidth: o, innerHeight: i } = window, s = -n, a = -e, r = o - n, d = i - e;\n  return { top: e, left: n, minX: s, minY: a, maxX: r, maxY: d };\n}, Pe = (t) => {\n  let e = /* @__PURE__ */ new Set();\n  return (o) => {\n    const i = o.map((s) => s.id);\n    (e.size !== i.length || i.some((s) => !e.has(s))) && t.set(i), e = new Set(i);\n  };\n}, Dt = (t, e, n, o) => {\n  const { store: i, selection: s, hover: a } = e;\n  let r, d, f;\n  const h = Pe(n), u = (B) => {\n    const { x: T, y: m } = t.getBoundingClientRect(), A = i.getAt(B.clientX - T, B.clientY - m, !1, d);\n    A ? a.current !== A.id && (t.classList.add(\"hovered\"), a.set(A.id)) : a.current && (t.classList.remove(\"hovered\"), a.set(null));\n  };\n  t.addEventListener(\"pointermove\", u);\n  const g = (B = !1) => {\n    f && f.clear();\n    const T = Xe(t), { minX: m, minY: A, maxX: w, maxY: L } = T, M = d ? i.getIntersecting(m, A, w, L).filter(({ annotation: U }) => d(U)) : i.getIntersecting(m, A, w, L), R = s.selected.map(({ id: U }) => U), N = M.map(({ annotation: U, rects: et }) => {\n      const q = R.includes(U.id), Se = U.id === a.current;\n      return { annotation: U, rects: et, state: { selected: q, hover: Se } };\n    });\n    o.redraw(N, T, r, f, B), setTimeout(() => h(M.map(({ annotation: U }) => U)), 1);\n  }, v = (B) => {\n    f = B, g();\n  }, p = (B) => {\n    r = B, g();\n  }, y = (B) => {\n    d = B, g(!1);\n  }, x = () => g();\n  i.observe(x);\n  const l = s.subscribe(() => g()), c = () => g(!0);\n  document.addEventListener(\"scroll\", c, { capture: !0, passive: !0 });\n  const b = Yt(() => {\n    i.recalculatePositions(), f && f.reset(), g();\n  });\n  window.addEventListener(\"resize\", b);\n  const S = new ResizeObserver(b);\n  S.observe(t);\n  const E = { attributes: !0, childList: !0, subtree: !0 }, C = new MutationObserver((B) => {\n    B.every((m) => m.target === t || t.contains(m.target)) || g(!0);\n  });\n  return C.observe(document.body, E), {\n    destroy: () => {\n      t.removeEventListener(\"pointermove\", u), o.destroy(), i.unobserve(x), l(), document.removeEventListener(\"scroll\", c), window.removeEventListener(\"resize\", b), S.disconnect(), C.disconnect();\n    },\n    redraw: g,\n    setStyle: p,\n    setFilter: y,\n    setPainter: v,\n    setVisible: o.setVisible\n  };\n}, $e = () => {\n  const t = document.createElement(\"canvas\");\n  return t.width = window.innerWidth, t.height = window.innerHeight, t.className = \"r6o-canvas-highlight-layer bg\", t;\n}, He = (t, e) => {\n  t.width = window.innerWidth, t.height = window.innerHeight;\n}, je = (t) => {\n  t.classList.add(\"r6o-annotatable\");\n  const e = $e(), n = e.getContext(\"2d\");\n  document.body.appendChild(e);\n  const o = (r, d, f, h) => requestAnimationFrame(() => {\n    const { width: u, height: g } = e;\n    n.clearRect(-0.5, -0.5, u + 1, g + 1), h && h.clear();\n    const { top: v, left: p } = d;\n    [...r].sort((x, l) => {\n      const { annotation: { target: { created: c } } } = x, { annotation: { target: { created: b } } } = l;\n      return c.getTime() - b.getTime();\n    }).forEach((x) => {\n      var S;\n      const l = f ? typeof f == \"function\" ? f(x.annotation, x.state) : f : (S = x.state) != null && S.selected ? At : W, c = h && h.paint(x, d) || l, b = x.rects.map(({ x: E, y: C, width: O, height: B }) => ({\n        x: E + p,\n        y: C + v,\n        width: O,\n        height: B\n      }));\n      if (n.fillStyle = c.fill, n.globalAlpha = c.fillOpacity || 1, b.forEach(\n        ({ x: E, y: C, width: O, height: B }) => n.fillRect(E, C, O, B)\n      ), c.underlineColor) {\n        n.globalAlpha = 1, n.strokeStyle = c.underlineColor, n.lineWidth = c.underlineThickness ?? 1;\n        const E = c.underlineOffset ?? 0;\n        b.forEach(({ x: C, y: O, width: B, height: T }) => {\n          n.beginPath(), n.moveTo(C, O + T + E), n.lineTo(C + B, O + T + E), n.stroke();\n        });\n      }\n    });\n  }), i = Yt(() => {\n    He(e);\n  });\n  return window.addEventListener(\"resize\", i), {\n    destroy: () => {\n      e.remove(), window.removeEventListener(\"resize\", i);\n    },\n    setVisible: (r) => {\n      console.log(\"setVisible not implemented on Canvas renderer\");\n    },\n    redraw: o\n  };\n}, ze = (t, e, n) => Dt(t, e, n, je(t));\nvar Fe = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) }, j = function(t) {\n  return typeof t == \"string\" ? t.length > 0 : typeof t == \"number\";\n}, V = function(t, e, n) {\n  return e === void 0 && (e = 0), n === void 0 && (n = Math.pow(10, e)), Math.round(n * t) / n + 0;\n}, X = function(t, e, n) {\n  return e === void 0 && (e = 0), n === void 0 && (n = 1), t > n ? n : t > e ? t : e;\n}, le = function(t) {\n  return (t = isFinite(t) ? t % 360 : 0) > 0 ? t : t + 360;\n}, Pt = function(t) {\n  return { r: X(t.r, 0, 255), g: X(t.g, 0, 255), b: X(t.b, 0, 255), a: X(t.a) };\n}, Et = function(t) {\n  return { r: V(t.r), g: V(t.g), b: V(t.b), a: V(t.a, 3) };\n}, We = /^#([0-9a-f]{3,8})$/i, ht = function(t) {\n  var e = t.toString(16);\n  return e.length < 2 ? \"0\" + e : e;\n}, de = function(t) {\n  var e = t.r, n = t.g, o = t.b, i = t.a, s = Math.max(e, n, o), a = s - Math.min(e, n, o), r = a ? s === e ? (n - o) / a : s === n ? 2 + (o - e) / a : 4 + (e - n) / a : 0;\n  return { h: 60 * (r < 0 ? r + 6 : r), s: s ? a / s * 100 : 0, v: s / 255 * 100, a: i };\n}, ue = function(t) {\n  var e = t.h, n = t.s, o = t.v, i = t.a;\n  e = e / 360 * 6, n /= 100, o /= 100;\n  var s = Math.floor(e), a = o * (1 - n), r = o * (1 - (e - s) * n), d = o * (1 - (1 - e + s) * n), f = s % 6;\n  return { r: 255 * [o, r, a, a, d, o][f], g: 255 * [d, o, o, r, a, a][f], b: 255 * [a, a, d, o, o, r][f], a: i };\n}, $t = function(t) {\n  return { h: le(t.h), s: X(t.s, 0, 100), l: X(t.l, 0, 100), a: X(t.a) };\n}, Ht = function(t) {\n  return { h: V(t.h), s: V(t.s), l: V(t.l), a: V(t.a, 3) };\n}, jt = function(t) {\n  return ue((n = (e = t).s, { h: e.h, s: (n *= ((o = e.l) < 50 ? o : 100 - o) / 100) > 0 ? 2 * n / (o + n) * 100 : 0, v: o + n, a: e.a }));\n  var e, n, o;\n}, at = function(t) {\n  return { h: (e = de(t)).h, s: (i = (200 - (n = e.s)) * (o = e.v) / 100) > 0 && i < 200 ? n * o / 100 / (i <= 100 ? i : 200 - i) * 100 : 0, l: i / 2, a: e.a };\n  var e, n, o, i;\n}, qe = /^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(deg|rad|grad|turn)?\\s*,\\s*([+-]?\\d*\\.?\\d+)%\\s*,\\s*([+-]?\\d*\\.?\\d+)%\\s*(?:,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i, Ge = /^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(deg|rad|grad|turn)?\\s+([+-]?\\d*\\.?\\d+)%\\s+([+-]?\\d*\\.?\\d+)%\\s*(?:\\/\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i, Qe = /^rgba?\\(\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*(?:,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i, Je = /^rgba?\\(\\s*([+-]?\\d*\\.?\\d+)(%)?\\s+([+-]?\\d*\\.?\\d+)(%)?\\s+([+-]?\\d*\\.?\\d+)(%)?\\s*(?:\\/\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i, zt = { string: [[function(t) {\n  var e = We.exec(t);\n  return e ? (t = e[1]).length <= 4 ? { r: parseInt(t[0] + t[0], 16), g: parseInt(t[1] + t[1], 16), b: parseInt(t[2] + t[2], 16), a: t.length === 4 ? V(parseInt(t[3] + t[3], 16) / 255, 2) : 1 } : t.length === 6 || t.length === 8 ? { r: parseInt(t.substr(0, 2), 16), g: parseInt(t.substr(2, 2), 16), b: parseInt(t.substr(4, 2), 16), a: t.length === 8 ? V(parseInt(t.substr(6, 2), 16) / 255, 2) : 1 } : null : null;\n}, \"hex\"], [function(t) {\n  var e = Qe.exec(t) || Je.exec(t);\n  return e ? e[2] !== e[4] || e[4] !== e[6] ? null : Pt({ r: Number(e[1]) / (e[2] ? 100 / 255 : 1), g: Number(e[3]) / (e[4] ? 100 / 255 : 1), b: Number(e[5]) / (e[6] ? 100 / 255 : 1), a: e[7] === void 0 ? 1 : Number(e[7]) / (e[8] ? 100 : 1) }) : null;\n}, \"rgb\"], [function(t) {\n  var e = qe.exec(t) || Ge.exec(t);\n  if (!e) return null;\n  var n, o, i = $t({ h: (n = e[1], o = e[2], o === void 0 && (o = \"deg\"), Number(n) * (Fe[o] || 1)), s: Number(e[3]), l: Number(e[4]), a: e[5] === void 0 ? 1 : Number(e[5]) / (e[6] ? 100 : 1) });\n  return jt(i);\n}, \"hsl\"]], object: [[function(t) {\n  var e = t.r, n = t.g, o = t.b, i = t.a, s = i === void 0 ? 1 : i;\n  return j(e) && j(n) && j(o) ? Pt({ r: Number(e), g: Number(n), b: Number(o), a: Number(s) }) : null;\n}, \"rgb\"], [function(t) {\n  var e = t.h, n = t.s, o = t.l, i = t.a, s = i === void 0 ? 1 : i;\n  if (!j(e) || !j(n) || !j(o)) return null;\n  var a = $t({ h: Number(e), s: Number(n), l: Number(o), a: Number(s) });\n  return jt(a);\n}, \"hsl\"], [function(t) {\n  var e = t.h, n = t.s, o = t.v, i = t.a, s = i === void 0 ? 1 : i;\n  if (!j(e) || !j(n) || !j(o)) return null;\n  var a = function(r) {\n    return { h: le(r.h), s: X(r.s, 0, 100), v: X(r.v, 0, 100), a: X(r.a) };\n  }({ h: Number(e), s: Number(n), v: Number(o), a: Number(s) });\n  return ue(a);\n}, \"hsv\"]] }, Ft = function(t, e) {\n  for (var n = 0; n < e.length; n++) {\n    var o = e[n][0](t);\n    if (o) return [o, e[n][1]];\n  }\n  return [null, void 0];\n}, Ze = function(t) {\n  return typeof t == \"string\" ? Ft(t.trim(), zt.string) : typeof t == \"object\" && t !== null ? Ft(t, zt.object) : [null, void 0];\n}, St = function(t, e) {\n  var n = at(t);\n  return { h: n.h, s: X(n.s + 100 * e, 0, 100), l: n.l, a: n.a };\n}, Ct = function(t) {\n  return (299 * t.r + 587 * t.g + 114 * t.b) / 1e3 / 255;\n}, Wt = function(t, e) {\n  var n = at(t);\n  return { h: n.h, s: n.s, l: X(n.l + 100 * e, 0, 100), a: n.a };\n}, qt = function() {\n  function t(e) {\n    this.parsed = Ze(e)[0], this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 };\n  }\n  return t.prototype.isValid = function() {\n    return this.parsed !== null;\n  }, t.prototype.brightness = function() {\n    return V(Ct(this.rgba), 2);\n  }, t.prototype.isDark = function() {\n    return Ct(this.rgba) < 0.5;\n  }, t.prototype.isLight = function() {\n    return Ct(this.rgba) >= 0.5;\n  }, t.prototype.toHex = function() {\n    return e = Et(this.rgba), n = e.r, o = e.g, i = e.b, a = (s = e.a) < 1 ? ht(V(255 * s)) : \"\", \"#\" + ht(n) + ht(o) + ht(i) + a;\n    var e, n, o, i, s, a;\n  }, t.prototype.toRgb = function() {\n    return Et(this.rgba);\n  }, t.prototype.toRgbString = function() {\n    return e = Et(this.rgba), n = e.r, o = e.g, i = e.b, (s = e.a) < 1 ? \"rgba(\" + n + \", \" + o + \", \" + i + \", \" + s + \")\" : \"rgb(\" + n + \", \" + o + \", \" + i + \")\";\n    var e, n, o, i, s;\n  }, t.prototype.toHsl = function() {\n    return Ht(at(this.rgba));\n  }, t.prototype.toHslString = function() {\n    return e = Ht(at(this.rgba)), n = e.h, o = e.s, i = e.l, (s = e.a) < 1 ? \"hsla(\" + n + \", \" + o + \"%, \" + i + \"%, \" + s + \")\" : \"hsl(\" + n + \", \" + o + \"%, \" + i + \"%)\";\n    var e, n, o, i, s;\n  }, t.prototype.toHsv = function() {\n    return e = de(this.rgba), { h: V(e.h), s: V(e.s), v: V(e.v), a: V(e.a, 3) };\n    var e;\n  }, t.prototype.invert = function() {\n    return $({ r: 255 - (e = this.rgba).r, g: 255 - e.g, b: 255 - e.b, a: e.a });\n    var e;\n  }, t.prototype.saturate = function(e) {\n    return e === void 0 && (e = 0.1), $(St(this.rgba, e));\n  }, t.prototype.desaturate = function(e) {\n    return e === void 0 && (e = 0.1), $(St(this.rgba, -e));\n  }, t.prototype.grayscale = function() {\n    return $(St(this.rgba, -1));\n  }, t.prototype.lighten = function(e) {\n    return e === void 0 && (e = 0.1), $(Wt(this.rgba, e));\n  }, t.prototype.darken = function(e) {\n    return e === void 0 && (e = 0.1), $(Wt(this.rgba, -e));\n  }, t.prototype.rotate = function(e) {\n    return e === void 0 && (e = 15), this.hue(this.hue() + e);\n  }, t.prototype.alpha = function(e) {\n    return typeof e == \"number\" ? $({ r: (n = this.rgba).r, g: n.g, b: n.b, a: e }) : V(this.rgba.a, 3);\n    var n;\n  }, t.prototype.hue = function(e) {\n    var n = at(this.rgba);\n    return typeof e == \"number\" ? $({ h: e, s: n.s, l: n.l, a: n.a }) : V(n.h);\n  }, t.prototype.isEqual = function(e) {\n    return this.toHex() === $(e).toHex();\n  }, t;\n}(), $ = function(t) {\n  return t instanceof qt ? t : new qt(t);\n};\nconst tn = (t) => [\n  `background-color:${$((t == null ? void 0 : t.fill) || W.fill).alpha((t == null ? void 0 : t.fillOpacity) === void 0 ? W.fillOpacity : t.fillOpacity).toHex()}`,\n  t != null && t.underlineThickness ? \"text-decoration:underline\" : void 0,\n  t != null && t.underlineColor ? `text-decoration-color:${t.underlineColor}` : void 0,\n  t != null && t.underlineOffset ? `text-underline-offset:${t.underlineOffset}px` : void 0,\n  t != null && t.underlineThickness ? `text-decoration-thickness:${t.underlineThickness}px` : void 0\n].filter(Boolean).join(\";\"), en = () => {\n  const t = document.createElement(\"style\");\n  document.getElementsByTagName(\"head\")[0].appendChild(t);\n  let e = /* @__PURE__ */ new Set();\n  return {\n    destroy: () => {\n      CSS.highlights.clear(), t.remove();\n    },\n    setVisible: (s) => {\n      console.log(\"setVisible not implemented on CSS Custom Highlights renderer\");\n    },\n    redraw: (s, a, r, d) => {\n      d && d.clear();\n      const f = new Set(s.map((u) => u.annotation.id));\n      Array.from(e).filter((u) => !f.has(u));\n      const h = s.map((u) => {\n        var p;\n        const g = r ? typeof r == \"function\" ? r(u.annotation, u.state) : r : (p = u.state) != null && p.selected ? At : W, v = d && d.paint(u, a) || g;\n        return `::highlight(_${u.annotation.id}) { ${tn(v)} }`;\n      });\n      t.innerHTML = h.join(`\n`), CSS.highlights.clear(), s.forEach(({ annotation: u }) => {\n        const g = u.target.selector.map((p) => p.range), v = new Highlight(...g);\n        CSS.highlights.set(`_${u.id}`, v);\n      }), e = f;\n    }\n  };\n}, nn = (t, e, n) => Dt(t, e, n, en());\nvar Gt = Object.prototype.hasOwnProperty;\nfunction Vt(t, e) {\n  var n, o;\n  if (t === e) return !0;\n  if (t && e && (n = t.constructor) === e.constructor) {\n    if (n === Date) return t.getTime() === e.getTime();\n    if (n === RegExp) return t.toString() === e.toString();\n    if (n === Array) {\n      if ((o = t.length) === e.length)\n        for (; o-- && Vt(t[o], e[o]); ) ;\n      return o === -1;\n    }\n    if (!n || typeof t == \"object\") {\n      o = 0;\n      for (n in t)\n        if (Gt.call(t, n) && ++o && !Gt.call(e, n) || !(n in e) || !Vt(t[n], e[n])) return !1;\n      return Object.keys(e).length === o;\n    }\n  }\n  return t !== t && e !== e;\n}\nconst on = (t, e) => {\n  const n = (s, a) => s.x <= a.x + a.width && s.x + s.width >= a.x && s.y <= a.y + a.height && s.y + s.height >= a.y, o = (s) => s.rects.reduce((a, r) => a + r.width, 0), i = e.filter(({ rects: s }) => s.some((a) => n(t, a)));\n  return i.sort((s, a) => o(a) - o(s)), i.findIndex((s) => s.rects.includes(t));\n}, sn = (t) => {\n  t.classList.add(\"r6o-annotatable\");\n  const e = document.createElement(\"div\");\n  e.className = \"r6o-span-highlight-layer\", t.insertBefore(e, t.firstChild);\n  let n = [];\n  return {\n    destroy: () => {\n      e.remove();\n    },\n    redraw: (a, r, d, f, h) => {\n      const g = !(Vt(n, a) && h);\n      if (!f && !g) return;\n      g && (e.innerHTML = \"\"), [...a].sort((p, y) => {\n        const { annotation: { target: { created: x } } } = p, { annotation: { target: { created: l } } } = y;\n        return x && l ? x.getTime() - l.getTime() : 0;\n      }).forEach((p) => {\n        p.rects.map((y) => {\n          const x = on(y, a), l = Ke(p, r, d, f, x);\n          if (g) {\n            const c = document.createElement(\"span\");\n            c.className = \"r6o-annotation\", c.dataset.annotation = p.annotation.id, c.style.left = `${y.x}px`, c.style.top = `${y.y}px`, c.style.width = `${y.width}px`, c.style.height = `${y.height}px`, c.style.backgroundColor = $((l == null ? void 0 : l.fill) || W.fill).alpha((l == null ? void 0 : l.fillOpacity) === void 0 ? W.fillOpacity : l.fillOpacity).toHex(), l.underlineStyle && (c.style.borderStyle = l.underlineStyle), l.underlineColor && (c.style.borderColor = l.underlineColor), l.underlineThickness && (c.style.borderBottomWidth = `${l.underlineThickness}px`), l.underlineOffset && (c.style.paddingBottom = `${l.underlineOffset}px`), e.appendChild(c);\n          }\n        });\n      }), n = a;\n    },\n    setVisible: (a) => {\n      a ? e.classList.remove(\"hidden\") : e.classList.add(\"hidden\");\n    }\n  };\n}, rn = (t, e, n) => Dt(t, e, n, sn(t)), Y = [];\nfor (let t = 0; t < 256; ++t)\n  Y.push((t + 256).toString(16).slice(1));\nfunction an(t, e = 0) {\n  return (Y[t[e + 0]] + Y[t[e + 1]] + Y[t[e + 2]] + Y[t[e + 3]] + \"-\" + Y[t[e + 4]] + Y[t[e + 5]] + \"-\" + Y[t[e + 6]] + Y[t[e + 7]] + \"-\" + Y[t[e + 8]] + Y[t[e + 9]] + \"-\" + Y[t[e + 10]] + Y[t[e + 11]] + Y[t[e + 12]] + Y[t[e + 13]] + Y[t[e + 14]] + Y[t[e + 15]]).toLowerCase();\n}\nlet Lt;\nconst cn = new Uint8Array(16);\nfunction ln() {\n  if (!Lt) {\n    if (typeof crypto > \"u\" || !crypto.getRandomValues)\n      throw new Error(\"crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported\");\n    Lt = crypto.getRandomValues.bind(crypto);\n  }\n  return Lt(cn);\n}\nconst dn = typeof crypto < \"u\" && crypto.randomUUID && crypto.randomUUID.bind(crypto), Qt = { randomUUID: dn };\nfunction fe(t, e, n) {\n  if (Qt.randomUUID && !e && !t)\n    return Qt.randomUUID();\n  t = t || {};\n  const o = t.random || (t.rng || ln)();\n  return o[6] = o[6] & 15 | 64, o[8] = o[8] & 63 | 128, an(o);\n}\nvar Jt = Object.prototype.hasOwnProperty;\nfunction G(t, e) {\n  var n, o;\n  if (t === e) return !0;\n  if (t && e && (n = t.constructor) === e.constructor) {\n    if (n === Date) return t.getTime() === e.getTime();\n    if (n === RegExp) return t.toString() === e.toString();\n    if (n === Array) {\n      if ((o = t.length) === e.length)\n        for (; o-- && G(t[o], e[o]); ) ;\n      return o === -1;\n    }\n    if (!n || typeof t == \"object\") {\n      o = 0;\n      for (n in t)\n        if (Jt.call(t, n) && ++o && !Jt.call(e, n) || !(n in e) || !G(t[n], e[n])) return !1;\n      return Object.keys(e).length === o;\n    }\n  }\n  return t !== t && e !== e;\n}\nfunction Tt() {\n}\nfunction un(t, e) {\n  return t != t ? e == e : t !== e || t && typeof t == \"object\" || typeof t == \"function\";\n}\nconst Q = [];\nfunction Kt(t, e = Tt) {\n  let n;\n  const o = /* @__PURE__ */ new Set();\n  function i(r) {\n    if (un(t, r) && (t = r, n)) {\n      const d = !Q.length;\n      for (const f of o)\n        f[1](), Q.push(f, t);\n      if (d) {\n        for (let f = 0; f < Q.length; f += 2)\n          Q[f][0](Q[f + 1]);\n        Q.length = 0;\n      }\n    }\n  }\n  function s(r) {\n    i(r(t));\n  }\n  function a(r, d = Tt) {\n    const f = [r, d];\n    return o.add(f), o.size === 1 && (n = e(i, s) || Tt), r(t), () => {\n      o.delete(f), o.size === 0 && n && (n(), n = null);\n    };\n  }\n  return { set: i, update: s, subscribe: a };\n}\nconst fn = (t) => {\n  const { subscribe: e, set: n } = Kt();\n  let o;\n  return e((i) => o = i), t.observe(({ changes: i }) => {\n    if (o) {\n      (i.deleted || []).some((a) => a.id === o) && n(void 0);\n      const s = (i.updated || []).find(({ oldValue: a }) => a.id === o);\n      s && n(s.newValue.id);\n    }\n  }), {\n    get current() {\n      return o;\n    },\n    subscribe: e,\n    set: n\n  };\n};\nvar hn = /* @__PURE__ */ ((t) => (t.EDIT = \"EDIT\", t.SELECT = \"SELECT\", t.NONE = \"NONE\", t))(hn || {});\nconst gt = { selected: [] }, gn = (t, e, n) => {\n  const { subscribe: o, set: i } = Kt(gt);\n  let s = e, a = gt;\n  o((p) => a = p);\n  const r = () => {\n    G(a, gt) || i(gt);\n  }, d = () => {\n    var p;\n    return ((p = a.selected) == null ? void 0 : p.length) === 0;\n  }, f = (p) => {\n    if (d())\n      return !1;\n    const y = typeof p == \"string\" ? p : p.id;\n    return a.selected.some((x) => x.id === y);\n  }, h = (p, y) => {\n    let x;\n    if (Array.isArray(p)) {\n      if (x = p.map((c) => t.getAnnotation(c)).filter(Boolean), x.length < p.length) {\n        console.warn(\"Invalid selection: \" + p.filter((c) => !x.some((b) => b.id === c)));\n        return;\n      }\n    } else {\n      const c = t.getAnnotation(p);\n      if (!c) {\n        console.warn(\"Invalid selection: \" + p);\n        return;\n      }\n      x = [c];\n    }\n    const l = x.reduce((c, b) => {\n      const S = Zt(b, s);\n      return S === \"EDIT\" ? [...c, { id: b.id, editable: !0 }] : S === \"SELECT\" ? [...c, { id: b.id }] : c;\n    }, []);\n    i({ selected: l, event: y });\n  }, u = (p, y) => {\n    const x = Array.isArray(p) ? p : [p], l = x.map((c) => t.getAnnotation(c)).filter((c) => !!c);\n    i({\n      selected: l.map((c) => {\n        const b = y === void 0 ? Zt(c, s) === \"EDIT\" : y;\n        return { id: c.id, editable: b };\n      })\n    }), l.length !== x.length && console.warn(\"Invalid selection\", p);\n  }, g = (p) => {\n    if (d())\n      return !1;\n    const { selected: y } = a;\n    y.some(({ id: x }) => p.includes(x)) && i({ selected: y.filter(({ id: x }) => !p.includes(x)) });\n  }, v = (p) => s = p;\n  return t.observe(\n    ({ changes: p }) => g((p.deleted || []).map((y) => y.id))\n  ), {\n    get event() {\n      return a ? a.event : null;\n    },\n    get selected() {\n      return a ? [...a.selected] : null;\n    },\n    get userSelectAction() {\n      return s;\n    },\n    clear: r,\n    isEmpty: d,\n    isSelected: f,\n    setSelected: u,\n    setUserSelectAction: v,\n    subscribe: o,\n    userSelect: h\n  };\n}, Zt = (t, e, n) => typeof e == \"function\" ? e(t) : e || \"EDIT\", D = [];\nfor (let t = 0; t < 256; ++t)\n  D.push((t + 256).toString(16).slice(1));\nfunction pn(t, e = 0) {\n  return (D[t[e + 0]] + D[t[e + 1]] + D[t[e + 2]] + D[t[e + 3]] + \"-\" + D[t[e + 4]] + D[t[e + 5]] + \"-\" + D[t[e + 6]] + D[t[e + 7]] + \"-\" + D[t[e + 8]] + D[t[e + 9]] + \"-\" + D[t[e + 10]] + D[t[e + 11]] + D[t[e + 12]] + D[t[e + 13]] + D[t[e + 14]] + D[t[e + 15]]).toLowerCase();\n}\nlet Ot;\nconst mn = new Uint8Array(16);\nfunction yn() {\n  if (!Ot) {\n    if (typeof crypto > \"u\" || !crypto.getRandomValues)\n      throw new Error(\"crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported\");\n    Ot = crypto.getRandomValues.bind(crypto);\n  }\n  return Ot(mn);\n}\nconst bn = typeof crypto < \"u\" && crypto.randomUUID && crypto.randomUUID.bind(crypto), te = { randomUUID: bn };\nfunction he(t, e, n) {\n  if (te.randomUUID && !e && !t)\n    return te.randomUUID();\n  t = t || {};\n  const o = t.random || (t.rng || yn)();\n  return o[6] = o[6] & 15 | 64, o[8] = o[8] & 63 | 128, pn(o);\n}\nconst Bt = (t) => {\n  const e = (n) => {\n    const o = { ...n };\n    return n.created && typeof n.created == \"string\" && (o.created = new Date(n.created)), n.updated && typeof n.updated == \"string\" && (o.updated = new Date(n.updated)), o;\n  };\n  return {\n    ...t,\n    bodies: (t.bodies || []).map(e),\n    target: e(t.target)\n  };\n}, Ao = (t, e, n, o) => ({\n  id: he(),\n  annotation: typeof t == \"string\" ? t : t.id,\n  created: n || /* @__PURE__ */ new Date(),\n  creator: o,\n  ...e\n}), wn = (t, e) => {\n  const n = new Set(t.bodies.map((o) => o.id));\n  return e.bodies.filter((o) => !n.has(o.id));\n}, An = (t, e) => {\n  const n = new Set(e.bodies.map((o) => o.id));\n  return t.bodies.filter((o) => !n.has(o.id));\n}, xn = (t, e) => e.bodies.map((n) => {\n  const o = t.bodies.find((i) => i.id === n.id);\n  return { newBody: n, oldBody: o && !G(o, n) ? o : void 0 };\n}).filter(({ oldBody: n }) => n).map(({ oldBody: n, newBody: o }) => ({ oldBody: n, newBody: o })), vn = (t, e) => !G(t.target, e.target), ge = (t, e) => {\n  const n = wn(t, e), o = An(t, e), i = xn(t, e);\n  return {\n    oldValue: t,\n    newValue: e,\n    bodiesCreated: n.length > 0 ? n : void 0,\n    bodiesDeleted: o.length > 0 ? o : void 0,\n    bodiesUpdated: i.length > 0 ? i : void 0,\n    targetUpdated: vn(t, e) ? { oldTarget: t.target, newTarget: e.target } : void 0\n  };\n};\nvar k = /* @__PURE__ */ ((t) => (t.LOCAL = \"LOCAL\", t.REMOTE = \"REMOTE\", t.SILENT = \"SILENT\", t))(k || {});\nconst En = (t, e) => {\n  var n, o;\n  const { changes: i, origin: s } = e;\n  if (!(t.options.origin ? t.options.origin === s : s !== \"SILENT\"))\n    return !1;\n  if (t.options.ignore) {\n    const { ignore: a } = t.options, r = (d) => d && d.length > 0;\n    if (!(r(i.created) || r(i.deleted))) {\n      const d = (n = i.updated) == null ? void 0 : n.some((h) => r(h.bodiesCreated) || r(h.bodiesDeleted) || r(h.bodiesUpdated)), f = (o = i.updated) == null ? void 0 : o.some((h) => h.targetUpdated);\n      if (a === \"BODY_ONLY\" && d && !f || a === \"TARGET_ONLY\" && f && !d)\n        return !1;\n    }\n  }\n  if (t.options.annotations) {\n    const a = /* @__PURE__ */ new Set([\n      ...(i.created || []).map((r) => r.id),\n      ...(i.deleted || []).map((r) => r.id),\n      ...(i.updated || []).map(({ oldValue: r }) => r.id)\n    ]);\n    return !!(Array.isArray(t.options.annotations) ? t.options.annotations : [t.options.annotations]).find((r) => a.has(r));\n  } else\n    return !0;\n}, Sn = (t, e) => {\n  const n = new Set((t.created || []).map((u) => u.id)), o = new Set((t.updated || []).map(({ newValue: u }) => u.id)), i = new Set((e.created || []).map((u) => u.id)), s = new Set((e.deleted || []).map((u) => u.id)), a = new Set((e.updated || []).map(({ oldValue: u }) => u.id)), r = new Set((e.updated || []).filter(({ oldValue: u }) => n.has(u.id) || o.has(u.id)).map(({ oldValue: u }) => u.id)), d = [\n    ...(t.created || []).filter((u) => !s.has(u.id)).map((u) => a.has(u.id) ? e.updated.find(({ oldValue: g }) => g.id === u.id).newValue : u),\n    ...e.created || []\n  ], f = [\n    ...(t.deleted || []).filter((u) => !i.has(u.id)),\n    ...(e.deleted || []).filter((u) => !n.has(u.id))\n  ], h = [\n    ...(t.updated || []).filter(({ newValue: u }) => !s.has(u.id)).map((u) => {\n      const { oldValue: g, newValue: v } = u;\n      if (a.has(v.id)) {\n        const p = e.updated.find((y) => y.oldValue.id === v.id).newValue;\n        return ge(g, p);\n      } else\n        return u;\n    }),\n    ...(e.updated || []).filter(({ oldValue: u }) => !r.has(u.id))\n  ];\n  return { created: d, deleted: f, updated: h };\n}, Mt = (t) => {\n  const e = t.id === void 0 ? he() : t.id;\n  return {\n    ...t,\n    id: e,\n    bodies: t.bodies === void 0 ? [] : t.bodies.map((n) => ({\n      ...n,\n      annotation: e\n    })),\n    target: {\n      ...t.target,\n      annotation: e\n    }\n  };\n}, Cn = (t) => t.id !== void 0, Ln = () => {\n  const t = /* @__PURE__ */ new Map(), e = /* @__PURE__ */ new Map(), n = [], o = (m, A = {}) => {\n    n.push({ onChange: m, options: A });\n  }, i = (m) => {\n    const A = n.findIndex((w) => w.onChange == m);\n    A > -1 && n.splice(A, 1);\n  }, s = (m, A) => {\n    const w = {\n      origin: m,\n      changes: {\n        created: A.created || [],\n        updated: A.updated || [],\n        deleted: A.deleted || []\n      },\n      state: [...t.values()]\n    };\n    n.forEach((L) => {\n      En(L, w) && L.onChange(w);\n    });\n  }, a = (m, A = k.LOCAL) => {\n    if (m.id && t.get(m.id))\n      throw Error(`Cannot add annotation ${m.id} - exists already`);\n    {\n      const w = Mt(m);\n      t.set(w.id, w), w.bodies.forEach((L) => e.set(L.id, w.id)), s(A, { created: [w] });\n    }\n  }, r = (m, A) => {\n    const w = Mt(typeof m == \"string\" ? A : m), L = typeof m == \"string\" ? m : m.id, M = L && t.get(L);\n    if (M) {\n      const R = ge(M, w);\n      return L === w.id ? t.set(L, w) : (t.delete(L), t.set(w.id, w)), M.bodies.forEach((N) => e.delete(N.id)), w.bodies.forEach((N) => e.set(N.id, w.id)), R;\n    } else\n      console.warn(`Cannot update annotation ${L} - does not exist`);\n  }, d = (m, A = k.LOCAL, w = k.LOCAL) => {\n    const L = Cn(A) ? w : A, M = r(m, A);\n    M && s(L, { updated: [M] });\n  }, f = (m, A = k.LOCAL) => {\n    const w = m.reduce((L, M) => {\n      const R = r(M);\n      return R ? [...L, R] : L;\n    }, []);\n    w.length > 0 && s(A, { updated: w });\n  }, h = (m, A = k.LOCAL) => {\n    const w = t.get(m.annotation);\n    if (w) {\n      const L = {\n        ...w,\n        bodies: [...w.bodies, m]\n      };\n      t.set(w.id, L), e.set(m.id, L.id), s(A, { updated: [{\n        oldValue: w,\n        newValue: L,\n        bodiesCreated: [m]\n      }] });\n    } else\n      console.warn(`Attempt to add body to missing annotation: ${m.annotation}`);\n  }, u = () => [...t.values()], g = (m = k.LOCAL) => {\n    const A = [...t.values()];\n    t.clear(), e.clear(), s(m, { deleted: A });\n  }, v = (m, A = !0, w = k.LOCAL) => {\n    const L = m.map(Mt);\n    if (A) {\n      const M = [...t.values()];\n      t.clear(), e.clear(), L.forEach((R) => {\n        t.set(R.id, R), R.bodies.forEach((N) => e.set(N.id, R.id));\n      }), s(w, { created: L, deleted: M });\n    } else {\n      const M = m.reduce((R, N) => {\n        const U = N.id && t.get(N.id);\n        return U ? [...R, U] : R;\n      }, []);\n      if (M.length > 0)\n        throw Error(`Bulk insert would overwrite the following annotations: ${M.map((R) => R.id).join(\", \")}`);\n      L.forEach((R) => {\n        t.set(R.id, R), R.bodies.forEach((N) => e.set(N.id, R.id));\n      }), s(w, { created: L });\n    }\n  }, p = (m) => {\n    const A = typeof m == \"string\" ? m : m.id, w = t.get(A);\n    if (w)\n      return t.delete(A), w.bodies.forEach((L) => e.delete(L.id)), w;\n    console.warn(`Attempt to delete missing annotation: ${A}`);\n  }, y = (m, A = k.LOCAL) => {\n    const w = p(m);\n    w && s(A, { deleted: [w] });\n  }, x = (m, A = k.LOCAL) => {\n    const w = m.reduce((L, M) => {\n      const R = p(M);\n      return R ? [...L, R] : L;\n    }, []);\n    w.length > 0 && s(A, { deleted: w });\n  }, l = (m) => {\n    const A = t.get(m.annotation);\n    if (A) {\n      const w = A.bodies.find((L) => L.id === m.id);\n      if (w) {\n        e.delete(w.id);\n        const L = {\n          ...A,\n          bodies: A.bodies.filter((M) => M.id !== m.id)\n        };\n        return t.set(A.id, L), {\n          oldValue: A,\n          newValue: L,\n          bodiesDeleted: [w]\n        };\n      } else\n        console.warn(`Attempt to delete missing body ${m.id} from annotation ${m.annotation}`);\n    } else\n      console.warn(`Attempt to delete body from missing annotation ${m.annotation}`);\n  }, c = (m, A = k.LOCAL) => {\n    const w = l(m);\n    w && s(A, { updated: [w] });\n  }, b = (m, A = k.LOCAL) => {\n    const w = m.map((L) => l(L)).filter(Boolean);\n    w.length > 0 && s(A, { updated: w });\n  }, S = (m) => {\n    const A = t.get(m);\n    return A ? { ...A } : void 0;\n  }, E = (m) => {\n    const A = e.get(m);\n    if (A) {\n      const w = S(A).bodies.find((L) => L.id === m);\n      if (w)\n        return w;\n      console.error(`Store integrity error: body ${m} in index, but not in annotation`);\n    } else\n      console.warn(`Attempt to retrieve missing body: ${m}`);\n  }, C = (m, A) => {\n    if (m.annotation !== A.annotation)\n      throw \"Annotation integrity violation: annotation ID must be the same when updating bodies\";\n    const w = t.get(m.annotation);\n    if (w) {\n      const L = w.bodies.find((R) => R.id === m.id), M = {\n        ...w,\n        bodies: w.bodies.map((R) => R.id === L.id ? A : R)\n      };\n      return t.set(w.id, M), L.id !== A.id && (e.delete(L.id), e.set(A.id, M.id)), {\n        oldValue: w,\n        newValue: M,\n        bodiesUpdated: [{ oldBody: L, newBody: A }]\n      };\n    } else\n      console.warn(`Attempt to add body to missing annotation ${m.annotation}`);\n  }, O = (m, A, w = k.LOCAL) => {\n    const L = C(m, A);\n    L && s(w, { updated: [L] });\n  }, B = (m, A = k.LOCAL) => {\n    const w = m.map((L) => C({ id: L.id, annotation: L.annotation }, L)).filter(Boolean);\n    s(A, { updated: w });\n  }, T = (m) => {\n    const A = t.get(m.annotation);\n    if (A) {\n      const w = {\n        ...A,\n        target: {\n          ...A.target,\n          ...m\n        }\n      };\n      return t.set(A.id, w), {\n        oldValue: A,\n        newValue: w,\n        targetUpdated: {\n          oldTarget: A.target,\n          newTarget: m\n        }\n      };\n    } else\n      console.warn(`Attempt to update target on missing annotation: ${m.annotation}`);\n  };\n  return {\n    addAnnotation: a,\n    addBody: h,\n    all: u,\n    bulkAddAnnotation: v,\n    bulkDeleteAnnotation: x,\n    bulkDeleteBodies: b,\n    bulkUpdateAnnotation: f,\n    bulkUpdateBodies: B,\n    bulkUpdateTargets: (m, A = k.LOCAL) => {\n      const w = m.map((L) => T(L)).filter(Boolean);\n      w.length > 0 && s(A, { updated: w });\n    },\n    clear: g,\n    deleteAnnotation: y,\n    deleteBody: c,\n    getAnnotation: S,\n    getBody: E,\n    observe: o,\n    unobserve: i,\n    updateAnnotation: d,\n    updateBody: O,\n    updateTarget: (m, A = k.LOCAL) => {\n      const w = T(m);\n      w && s(A, { updated: [w] });\n    }\n  };\n};\nlet Tn = () => ({\n  emit(t, ...e) {\n    for (let n = this.events[t] || [], o = 0, i = n.length; o < i; o++)\n      n[o](...e);\n  },\n  events: {},\n  on(t, e) {\n    var n;\n    return ((n = this.events)[t] || (n[t] = [])).push(e), () => {\n      var o;\n      this.events[t] = (o = this.events[t]) == null ? void 0 : o.filter((i) => e !== i);\n    };\n  }\n});\nconst On = 250, Bn = (t, e) => {\n  const n = Tn(), o = [];\n  let i = -1, s = !1, a = 0;\n  const r = (p) => {\n    if (!s) {\n      const { changes: y } = p, x = performance.now();\n      if (x - a > On)\n        o.splice(i + 1), o.push(y), i = o.length - 1;\n      else {\n        const l = o.length - 1;\n        o[l] = Sn(o[l], y);\n      }\n      a = x;\n    }\n    s = !1;\n  };\n  t.observe(r, { origin: k.LOCAL });\n  const d = (p) => p && p.length > 0 && t.bulkDeleteAnnotation(p), f = (p) => p && p.length > 0 && t.bulkAddAnnotation(p, !1), h = (p) => p && p.length > 0 && t.bulkUpdateAnnotation(p.map(({ oldValue: y }) => y)), u = (p) => p && p.length > 0 && t.bulkUpdateAnnotation(p.map(({ newValue: y }) => y)), g = (p) => p && p.length > 0 && t.bulkAddAnnotation(p, !1), v = (p) => p && p.length > 0 && t.bulkDeleteAnnotation(p);\n  return {\n    canRedo: () => o.length - 1 > i,\n    canUndo: () => i > -1,\n    destroy: () => t.unobserve(r),\n    getHistory: () => ({ changes: [...o], pointer: i }),\n    on: (p, y) => n.on(p, y),\n    redo: () => {\n      if (o.length - 1 > i) {\n        s = !0;\n        const { created: p, updated: y, deleted: x } = o[i + 1];\n        f(p), u(y), v(x), n.emit(\"redo\", o[i + 1]), i += 1;\n      }\n    },\n    undo: () => {\n      if (i > -1) {\n        s = !0;\n        const { created: p, updated: y, deleted: x } = o[i];\n        d(p), h(y), g(x), n.emit(\"undo\", o[i]), i -= 1;\n      }\n    }\n  };\n}, Mn = () => {\n  const { subscribe: t, set: e } = Kt([]);\n  return {\n    subscribe: t,\n    set: e\n  };\n}, Rn = (t, e, n, o) => {\n  const { hover: i, selection: s, store: a, viewport: r } = t, d = /* @__PURE__ */ new Map();\n  let f = [], h;\n  const u = (y, x) => {\n    d.has(y) ? d.get(y).push(x) : d.set(y, [x]);\n  }, g = (y, x) => {\n    const l = d.get(y);\n    if (l) {\n      const c = l.indexOf(x);\n      c !== -1 && l.splice(c, 1);\n    }\n  }, v = (y, x, l) => {\n    d.has(y) && setTimeout(() => {\n      d.get(y).forEach((c) => {\n        if (n) {\n          const b = Array.isArray(x) ? x.map((E) => n.serialize(E)) : n.serialize(x), S = l ? l instanceof PointerEvent ? l : n.serialize(l) : void 0;\n          c(b, S);\n        } else\n          c(x, l);\n      });\n    }, 1);\n  };\n  s.subscribe(({ selected: y }) => {\n    if (!(f.length === 0 && y.length === 0)) {\n      if (f.length === 0 && y.length > 0)\n        f = y.map(({ id: x }) => a.getAnnotation(x));\n      else if (f.length > 0 && y.length === 0)\n        f.forEach((x) => {\n          const l = a.getAnnotation(x.id);\n          l && !G(l, x) && v(\"updateAnnotation\", l, x);\n        }), f = [];\n      else {\n        const x = new Set(f.map((c) => c.id)), l = new Set(y.map(({ id: c }) => c));\n        f.filter((c) => !l.has(c.id)).forEach((c) => {\n          const b = a.getAnnotation(c.id);\n          b && !G(b, c) && v(\"updateAnnotation\", b, c);\n        }), f = [\n          // Remove annotations that were deselected\n          ...f.filter((c) => l.has(c.id)),\n          // Add editable annotations that were selected\n          ...y.filter(({ id: c }) => !x.has(c)).map(({ id: c }) => a.getAnnotation(c))\n        ];\n      }\n      v(\"selectionChanged\", f);\n    }\n  }), i.subscribe((y) => {\n    !h && y ? v(\"mouseEnterAnnotation\", a.getAnnotation(y)) : h && !y ? v(\"mouseLeaveAnnotation\", a.getAnnotation(h)) : h && y && (v(\"mouseLeaveAnnotation\", a.getAnnotation(h)), v(\"mouseEnterAnnotation\", a.getAnnotation(y))), h = y;\n  }), r == null || r.subscribe((y) => v(\"viewportIntersect\", y.map((x) => a.getAnnotation(x)))), a.observe((y) => {\n    const { created: x, deleted: l } = y.changes;\n    (x || []).forEach((c) => v(\"createAnnotation\", c)), (l || []).forEach((c) => v(\"deleteAnnotation\", c)), (y.changes.updated || []).filter((c) => [\n      ...c.bodiesCreated || [],\n      ...c.bodiesDeleted || [],\n      ...c.bodiesUpdated || []\n    ].length > 0).forEach(({ oldValue: c, newValue: b }) => {\n      const S = f.find((E) => E.id === c.id) || c;\n      f = f.map((E) => E.id === c.id ? b : E), v(\"updateAnnotation\", b, S);\n    });\n  }, { origin: k.LOCAL }), a.observe((y) => {\n    if (f) {\n      const x = new Set(f.map((c) => c.id)), l = (y.changes.updated || []).filter(({ newValue: c }) => x.has(c.id)).map(({ newValue: c }) => c);\n      l.length > 0 && (f = f.map((c) => l.find((S) => S.id === c.id) || c));\n    }\n  }, { origin: k.REMOTE });\n  const p = (y) => (x) => {\n    const { updated: l } = x;\n    y ? (l || []).forEach((c) => v(\"updateAnnotation\", c.oldValue, c.newValue)) : (l || []).forEach((c) => v(\"updateAnnotation\", c.newValue, c.oldValue));\n  };\n  return e.on(\"undo\", p(!0)), e.on(\"redo\", p(!1)), { on: u, off: g, emit: v };\n}, kn = (t) => (e) => e.reduce((n, o) => {\n  const { parsed: i, error: s } = t.parse(o);\n  return s ? {\n    parsed: n.parsed,\n    failed: [...n.failed, o]\n  } : i ? {\n    parsed: [...n.parsed, i],\n    failed: n.failed\n  } : {\n    ...n\n  };\n}, { parsed: [], failed: [] }), In = (t, e, n) => {\n  const { store: o, selection: i } = t, s = (l) => {\n    if (n) {\n      const { parsed: c, error: b } = n.parse(l);\n      c ? o.addAnnotation(c, k.REMOTE) : console.error(b);\n    } else\n      o.addAnnotation(Bt(l), k.REMOTE);\n  }, a = () => i.clear(), r = () => o.clear(), d = (l) => {\n    const c = o.getAnnotation(l);\n    return n && c ? n.serialize(c) : c;\n  }, f = () => n ? o.all().map(n.serialize) : o.all(), h = () => {\n    var l;\n    const c = (((l = i.selected) == null ? void 0 : l.map((b) => b.id)) || []).map((b) => o.getAnnotation(b)).filter(Boolean);\n    return n ? c.map(n.serialize) : c;\n  }, u = (l, c = !0) => fetch(l).then((b) => b.json()).then((b) => (v(b, c), b)), g = (l) => {\n    if (typeof l == \"string\") {\n      const c = o.getAnnotation(l);\n      if (o.deleteAnnotation(l), c)\n        return n ? n.serialize(c) : c;\n    } else {\n      const c = n ? n.parse(l).parsed : l;\n      if (c)\n        return o.deleteAnnotation(c), l;\n    }\n  }, v = (l, c = !0) => {\n    if (n) {\n      const b = n.parseAll || kn(n), { parsed: S, failed: E } = b(l);\n      E.length > 0 && console.warn(`Discarded ${E.length} invalid annotations`, E), o.bulkAddAnnotation(S, c, k.REMOTE);\n    } else\n      o.bulkAddAnnotation(l.map(Bt), c, k.REMOTE);\n  }, p = (l, c) => {\n    l ? i.setSelected(l, c) : i.clear();\n  }, y = (l) => {\n    i.clear(), i.setUserSelectAction(l);\n  }, x = (l) => {\n    if (n) {\n      const c = n.parse(l).parsed, b = n.serialize(o.getAnnotation(c.id));\n      return o.updateAnnotation(c), b;\n    } else {\n      const c = o.getAnnotation(l.id);\n      return o.updateAnnotation(Bt(l)), c;\n    }\n  };\n  return {\n    addAnnotation: s,\n    cancelSelected: a,\n    canRedo: e.canRedo,\n    canUndo: e.canUndo,\n    clearAnnotations: r,\n    getAnnotationById: d,\n    getAnnotations: f,\n    getHistory: e.getHistory,\n    getSelected: h,\n    loadAnnotations: u,\n    redo: e.redo,\n    removeAnnotation: g,\n    setAnnotations: v,\n    setSelected: p,\n    setUserSelectAction: y,\n    undo: e.undo,\n    updateAnnotation: x\n  };\n}, _n = \"useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict\";\nlet Nn = (t) => crypto.getRandomValues(new Uint8Array(t)), Un = (t, e, n) => {\n  let o = (2 << Math.log2(t.length - 1)) - 1, i = -~(1.6 * o * e / t.length);\n  return (s = e) => {\n    let a = \"\";\n    for (; ; ) {\n      let r = n(i), d = i | 0;\n      for (; d--; )\n        if (a += t[r[d] & o] || \"\", a.length >= s) return a;\n    }\n  };\n}, Vn = (t, e = 21) => Un(t, e | 0, Nn), Yn = (t = 21) => {\n  let e = \"\", n = crypto.getRandomValues(new Uint8Array(t |= 0));\n  for (; t--; )\n    e += _n[n[t] & 63];\n  return e;\n};\nconst Dn = () => ({ isGuest: !0, id: Vn(\"1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_\", 20)() }), Kn = (t) => {\n  const e = JSON.stringify(t);\n  let n = 0;\n  for (let o = 0, i = e.length; o < i; o++) {\n    let s = e.charCodeAt(o);\n    n = (n << 5) - n + s, n |= 0;\n  }\n  return `${n}`;\n}, pe = (t) => t ? typeof t == \"object\" ? { ...t } : t : void 0, Xn = (t, e) => (Array.isArray(t) ? t : [t]).map((n) => {\n  const { id: o, type: i, purpose: s, value: a, created: r, modified: d, creator: f, ...h } = n;\n  return {\n    id: o || `temp-${Kn(n)}`,\n    annotation: e,\n    type: i,\n    purpose: s,\n    value: a,\n    creator: pe(f),\n    created: r ? new Date(r) : void 0,\n    updated: d ? new Date(d) : void 0,\n    ...h\n  };\n}), Pn = (t) => t.map((e) => {\n  var n;\n  const { annotation: o, created: i, updated: s, ...a } = e, r = {\n    ...a,\n    created: i == null ? void 0 : i.toISOString(),\n    modified: s == null ? void 0 : s.toISOString()\n  };\n  return (n = r.id) != null && n.startsWith(\"temp-\") && delete r.id, r;\n});\nYn();\nconst xo = (t, e) => ({\n  parse: (n) => jn(n),\n  serialize: (n) => zn(n, t, e)\n}), $n = (t) => t.quote !== void 0 && t.start !== void 0 && t.end !== void 0, Hn = (t) => {\n  const {\n    id: e,\n    creator: n,\n    created: o,\n    modified: i,\n    target: s\n  } = t, a = Array.isArray(s) ? s : [s];\n  if (a.length === 0)\n    return { error: Error(`No targets found for annotation: ${t.id}`) };\n  const r = {\n    creator: pe(n),\n    created: o ? new Date(o) : void 0,\n    updated: i ? new Date(i) : void 0,\n    annotation: e,\n    selector: [],\n    // @ts-expect-error: `styleClass` is not part of the core `TextAnnotationTarget` type\n    styleClass: \"styleClass\" in a[0] ? a[0].styleClass : void 0\n  };\n  for (const d of a) {\n    const h = (Array.isArray(d.selector) ? d.selector : [d.selector]).reduce((u, g) => {\n      switch (g.type) {\n        case \"TextQuoteSelector\":\n          u.quote = g.exact;\n          break;\n        case \"TextPositionSelector\":\n          u.start = g.start, u.end = g.end;\n          break;\n      }\n      return u;\n    }, {});\n    if ($n(h))\n      r.selector.push(\n        {\n          ...h,\n          id: d.id,\n          // @ts-expect-error: `scope` is not part of the core `TextSelector` type\n          scope: d.scope\n        }\n      );\n    else {\n      const u = [\n        h.start ? void 0 : \"TextPositionSelector\",\n        h.quote ? void 0 : \"TextQuoteSelector\"\n      ].filter(Boolean);\n      return { error: Error(`Missing selector types: ${u.join(\" and \")} for annotation: ${t.id}`) };\n    }\n  }\n  return { parsed: r };\n}, jn = (t) => {\n  const e = t.id || fe(), {\n    creator: n,\n    created: o,\n    modified: i,\n    body: s,\n    ...a\n  } = t, r = Xn(s, e), d = Hn(t);\n  return \"error\" in d ? { error: d.error } : {\n    parsed: {\n      ...a,\n      id: e,\n      bodies: r,\n      target: d.parsed\n    }\n  };\n}, zn = (t, e, n) => {\n  const { bodies: o, target: i, ...s } = t, {\n    selector: a,\n    creator: r,\n    created: d,\n    updated: f,\n    ...h\n  } = i, u = a.map((g) => {\n    const { id: v, quote: p, start: y, end: x, range: l } = g, { prefix: c, suffix: b } = Re(l, n), S = [{\n      type: \"TextQuoteSelector\",\n      exact: p,\n      prefix: c,\n      suffix: b\n    }, {\n      type: \"TextPositionSelector\",\n      start: y,\n      end: x\n    }];\n    return {\n      ...h,\n      id: v,\n      // @ts-expect-error: `scope` is not part of the core `TextSelector` type\n      scope: \"scope\" in g ? g.scope : void 0,\n      source: e,\n      selector: S\n    };\n  });\n  return {\n    ...s,\n    \"@context\": \"http://www.w3.org/ns/anno.jsonld\",\n    id: t.id,\n    type: \"Annotation\",\n    body: Pn(t.bodies),\n    creator: r,\n    created: d == null ? void 0 : d.toISOString(),\n    modified: f == null ? void 0 : f.toISOString(),\n    target: u\n  };\n};\nfunction me(t, e, n = 0, o = t.length - 1, i = Fn) {\n  for (; o > n; ) {\n    if (o - n > 600) {\n      const d = o - n + 1, f = e - n + 1, h = Math.log(d), u = 0.5 * Math.exp(2 * h / 3), g = 0.5 * Math.sqrt(h * u * (d - u) / d) * (f - d / 2 < 0 ? -1 : 1), v = Math.max(n, Math.floor(e - f * u / d + g)), p = Math.min(o, Math.floor(e + (d - f) * u / d + g));\n      me(t, e, v, p, i);\n    }\n    const s = t[e];\n    let a = n, r = o;\n    for (nt(t, n, e), i(t[o], s) > 0 && nt(t, n, o); a < r; ) {\n      for (nt(t, a, r), a++, r--; i(t[a], s) < 0; ) a++;\n      for (; i(t[r], s) > 0; ) r--;\n    }\n    i(t[n], s) === 0 ? nt(t, n, r) : (r++, nt(t, r, o)), r <= e && (n = r + 1), e <= r && (o = r - 1);\n  }\n}\nfunction nt(t, e, n) {\n  const o = t[e];\n  t[e] = t[n], t[n] = o;\n}\nfunction Fn(t, e) {\n  return t < e ? -1 : t > e ? 1 : 0;\n}\nclass Wn {\n  constructor(e = 9) {\n    this._maxEntries = Math.max(4, e), this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4)), this.clear();\n  }\n  all() {\n    return this._all(this.data, []);\n  }\n  search(e) {\n    let n = this.data;\n    const o = [];\n    if (!mt(e, n)) return o;\n    const i = this.toBBox, s = [];\n    for (; n; ) {\n      for (let a = 0; a < n.children.length; a++) {\n        const r = n.children[a], d = n.leaf ? i(r) : r;\n        mt(e, d) && (n.leaf ? o.push(r) : kt(e, d) ? this._all(r, o) : s.push(r));\n      }\n      n = s.pop();\n    }\n    return o;\n  }\n  collides(e) {\n    let n = this.data;\n    if (!mt(e, n)) return !1;\n    const o = [];\n    for (; n; ) {\n      for (let i = 0; i < n.children.length; i++) {\n        const s = n.children[i], a = n.leaf ? this.toBBox(s) : s;\n        if (mt(e, a)) {\n          if (n.leaf || kt(e, a)) return !0;\n          o.push(s);\n        }\n      }\n      n = o.pop();\n    }\n    return !1;\n  }\n  load(e) {\n    if (!(e && e.length)) return this;\n    if (e.length < this._minEntries) {\n      for (let o = 0; o < e.length; o++)\n        this.insert(e[o]);\n      return this;\n    }\n    let n = this._build(e.slice(), 0, e.length - 1, 0);\n    if (!this.data.children.length)\n      this.data = n;\n    else if (this.data.height === n.height)\n      this._splitRoot(this.data, n);\n    else {\n      if (this.data.height < n.height) {\n        const o = this.data;\n        this.data = n, n = o;\n      }\n      this._insert(n, this.data.height - n.height - 1, !0);\n    }\n    return this;\n  }\n  insert(e) {\n    return e && this._insert(e, this.data.height - 1), this;\n  }\n  clear() {\n    return this.data = Z([]), this;\n  }\n  remove(e, n) {\n    if (!e) return this;\n    let o = this.data;\n    const i = this.toBBox(e), s = [], a = [];\n    let r, d, f;\n    for (; o || s.length; ) {\n      if (o || (o = s.pop(), d = s[s.length - 1], r = a.pop(), f = !0), o.leaf) {\n        const h = qn(e, o.children, n);\n        if (h !== -1)\n          return o.children.splice(h, 1), s.push(o), this._condense(s), this;\n      }\n      !f && !o.leaf && kt(o, i) ? (s.push(o), a.push(r), r = 0, d = o, o = o.children[0]) : d ? (r++, o = d.children[r], f = !1) : o = null;\n    }\n    return this;\n  }\n  toBBox(e) {\n    return e;\n  }\n  compareMinX(e, n) {\n    return e.minX - n.minX;\n  }\n  compareMinY(e, n) {\n    return e.minY - n.minY;\n  }\n  toJSON() {\n    return this.data;\n  }\n  fromJSON(e) {\n    return this.data = e, this;\n  }\n  _all(e, n) {\n    const o = [];\n    for (; e; )\n      e.leaf ? n.push(...e.children) : o.push(...e.children), e = o.pop();\n    return n;\n  }\n  _build(e, n, o, i) {\n    const s = o - n + 1;\n    let a = this._maxEntries, r;\n    if (s <= a)\n      return r = Z(e.slice(n, o + 1)), J(r, this.toBBox), r;\n    i || (i = Math.ceil(Math.log(s) / Math.log(a)), a = Math.ceil(s / Math.pow(a, i - 1))), r = Z([]), r.leaf = !1, r.height = i;\n    const d = Math.ceil(s / a), f = d * Math.ceil(Math.sqrt(a));\n    ee(e, n, o, f, this.compareMinX);\n    for (let h = n; h <= o; h += f) {\n      const u = Math.min(h + f - 1, o);\n      ee(e, h, u, d, this.compareMinY);\n      for (let g = h; g <= u; g += d) {\n        const v = Math.min(g + d - 1, u);\n        r.children.push(this._build(e, g, v, i - 1));\n      }\n    }\n    return J(r, this.toBBox), r;\n  }\n  _chooseSubtree(e, n, o, i) {\n    for (; i.push(n), !(n.leaf || i.length - 1 === o); ) {\n      let s = 1 / 0, a = 1 / 0, r;\n      for (let d = 0; d < n.children.length; d++) {\n        const f = n.children[d], h = Rt(f), u = Jn(e, f) - h;\n        u < a ? (a = u, s = h < s ? h : s, r = f) : u === a && h < s && (s = h, r = f);\n      }\n      n = r || n.children[0];\n    }\n    return n;\n  }\n  _insert(e, n, o) {\n    const i = o ? e : this.toBBox(e), s = [], a = this._chooseSubtree(i, this.data, n, s);\n    for (a.children.push(e), rt(a, i); n >= 0 && s[n].children.length > this._maxEntries; )\n      this._split(s, n), n--;\n    this._adjustParentBBoxes(i, s, n);\n  }\n  // split overflowed node into two\n  _split(e, n) {\n    const o = e[n], i = o.children.length, s = this._minEntries;\n    this._chooseSplitAxis(o, s, i);\n    const a = this._chooseSplitIndex(o, s, i), r = Z(o.children.splice(a, o.children.length - a));\n    r.height = o.height, r.leaf = o.leaf, J(o, this.toBBox), J(r, this.toBBox), n ? e[n - 1].children.push(r) : this._splitRoot(o, r);\n  }\n  _splitRoot(e, n) {\n    this.data = Z([e, n]), this.data.height = e.height + 1, this.data.leaf = !1, J(this.data, this.toBBox);\n  }\n  _chooseSplitIndex(e, n, o) {\n    let i, s = 1 / 0, a = 1 / 0;\n    for (let r = n; r <= o - n; r++) {\n      const d = st(e, 0, r, this.toBBox), f = st(e, r, o, this.toBBox), h = Zn(d, f), u = Rt(d) + Rt(f);\n      h < s ? (s = h, i = r, a = u < a ? u : a) : h === s && u < a && (a = u, i = r);\n    }\n    return i || o - n;\n  }\n  // sorts node children by the best axis for split\n  _chooseSplitAxis(e, n, o) {\n    const i = e.leaf ? this.compareMinX : Gn, s = e.leaf ? this.compareMinY : Qn, a = this._allDistMargin(e, n, o, i), r = this._allDistMargin(e, n, o, s);\n    a < r && e.children.sort(i);\n  }\n  // total margin of all possible split distributions where each node is at least m full\n  _allDistMargin(e, n, o, i) {\n    e.children.sort(i);\n    const s = this.toBBox, a = st(e, 0, n, s), r = st(e, o - n, o, s);\n    let d = pt(a) + pt(r);\n    for (let f = n; f < o - n; f++) {\n      const h = e.children[f];\n      rt(a, e.leaf ? s(h) : h), d += pt(a);\n    }\n    for (let f = o - n - 1; f >= n; f--) {\n      const h = e.children[f];\n      rt(r, e.leaf ? s(h) : h), d += pt(r);\n    }\n    return d;\n  }\n  _adjustParentBBoxes(e, n, o) {\n    for (let i = o; i >= 0; i--)\n      rt(n[i], e);\n  }\n  _condense(e) {\n    for (let n = e.length - 1, o; n >= 0; n--)\n      e[n].children.length === 0 ? n > 0 ? (o = e[n - 1].children, o.splice(o.indexOf(e[n]), 1)) : this.clear() : J(e[n], this.toBBox);\n  }\n}\nfunction qn(t, e, n) {\n  if (!n) return e.indexOf(t);\n  for (let o = 0; o < e.length; o++)\n    if (n(t, e[o])) return o;\n  return -1;\n}\nfunction J(t, e) {\n  st(t, 0, t.children.length, e, t);\n}\nfunction st(t, e, n, o, i) {\n  i || (i = Z(null)), i.minX = 1 / 0, i.minY = 1 / 0, i.maxX = -1 / 0, i.maxY = -1 / 0;\n  for (let s = e; s < n; s++) {\n    const a = t.children[s];\n    rt(i, t.leaf ? o(a) : a);\n  }\n  return i;\n}\nfunction rt(t, e) {\n  return t.minX = Math.min(t.minX, e.minX), t.minY = Math.min(t.minY, e.minY), t.maxX = Math.max(t.maxX, e.maxX), t.maxY = Math.max(t.maxY, e.maxY), t;\n}\nfunction Gn(t, e) {\n  return t.minX - e.minX;\n}\nfunction Qn(t, e) {\n  return t.minY - e.minY;\n}\nfunction Rt(t) {\n  return (t.maxX - t.minX) * (t.maxY - t.minY);\n}\nfunction pt(t) {\n  return t.maxX - t.minX + (t.maxY - t.minY);\n}\nfunction Jn(t, e) {\n  return (Math.max(e.maxX, t.maxX) - Math.min(e.minX, t.minX)) * (Math.max(e.maxY, t.maxY) - Math.min(e.minY, t.minY));\n}\nfunction Zn(t, e) {\n  const n = Math.max(t.minX, e.minX), o = Math.max(t.minY, e.minY), i = Math.min(t.maxX, e.maxX), s = Math.min(t.maxY, e.maxY);\n  return Math.max(0, i - n) * Math.max(0, s - o);\n}\nfunction kt(t, e) {\n  return t.minX <= e.minX && t.minY <= e.minY && e.maxX <= t.maxX && e.maxY <= t.maxY;\n}\nfunction mt(t, e) {\n  return e.minX <= t.maxX && e.minY <= t.maxY && e.maxX >= t.minX && e.maxY >= t.minY;\n}\nfunction Z(t) {\n  return {\n    children: t,\n    height: 1,\n    leaf: !0,\n    minX: 1 / 0,\n    minY: 1 / 0,\n    maxX: -1 / 0,\n    maxY: -1 / 0\n  };\n}\nfunction ee(t, e, n, o, i) {\n  const s = [e, n];\n  for (; s.length; ) {\n    if (n = s.pop(), e = s.pop(), n - e <= o) continue;\n    const a = e + Math.ceil((n - e) / o / 2) * o;\n    me(t, a, e, n, i), s.push(e, a, a, n);\n  }\n}\nconst to = (t, e) => {\n  const n = new Wn(), o = /* @__PURE__ */ new Map(), i = (l, c) => {\n    const b = l.selector.flatMap((E) => {\n      const C = F([E]) ? E.range : ae(E, e).range;\n      return Array.from(C.getClientRects());\n    }), S = Ue(b).map(({ left: E, top: C, right: O, bottom: B }) => new DOMRect(E - c.left, C - c.top, O - E, B - C));\n    return S.map((E) => {\n      const { x: C, y: O, width: B, height: T } = E;\n      return {\n        minX: C,\n        minY: O,\n        maxX: C + B,\n        maxY: O + T,\n        annotation: {\n          id: l.annotation,\n          rects: S\n        }\n      };\n    });\n  }, s = () => [...o.values()], a = () => {\n    n.clear(), o.clear();\n  }, r = (l) => {\n    const c = i(l, e.getBoundingClientRect());\n    c.length !== 0 && (c.forEach((b) => n.insert(b)), o.set(l.annotation, c));\n  }, d = (l) => {\n    const c = o.get(l.annotation);\n    c && (c.forEach((b) => n.remove(b)), o.delete(l.annotation));\n  }, f = (l) => {\n    d(l), r(l);\n  }, h = (l, c = !0) => {\n    c && a();\n    const b = e.getBoundingClientRect(), S = l.map((C) => ({ target: C, rects: i(C, b) }));\n    S.forEach(({ target: C, rects: O }) => {\n      O.length > 0 && o.set(C.annotation, O);\n    });\n    const E = S.flatMap(({ rects: C }) => C);\n    n.load(E);\n  }, u = (l, c, b = !1) => {\n    const S = n.search({\n      minX: l,\n      minY: c,\n      maxX: l,\n      maxY: c\n    }), E = (C) => C.annotation.rects.reduce((O, B) => O + B.width * B.height, 0);\n    return S.length > 0 ? (S.sort((C, O) => E(C) - E(O)), b ? S.map((C) => C.annotation.id) : [S[0].annotation.id]) : [];\n  }, g = (l) => {\n    const c = v(l);\n    if (c.length === 0)\n      return;\n    let b = c[0].left, S = c[0].top, E = c[0].right, C = c[0].bottom;\n    for (let O = 1; O < c.length; O++) {\n      const B = c[O];\n      b = Math.min(b, B.left), S = Math.min(S, B.top), E = Math.max(E, B.right), C = Math.max(C, B.bottom);\n    }\n    return new DOMRect(b, S, E - b, C - S);\n  }, v = (l) => {\n    const c = o.get(l);\n    return c ? c[0].annotation.rects : [];\n  };\n  return {\n    all: s,\n    clear: a,\n    getAt: u,\n    getAnnotationBounds: g,\n    getAnnotationRects: v,\n    getIntersecting: (l, c, b, S) => {\n      const E = n.search({ minX: l, minY: c, maxX: b, maxY: S }), C = new Set(E.map((O) => O.annotation.id));\n      return Array.from(C).map((O) => ({\n        annotation: t.getAnnotation(O),\n        rects: v(O)\n      })).filter((O) => !!O.annotation);\n    },\n    insert: r,\n    recalculate: () => h(t.all().map((l) => l.target), !0),\n    remove: d,\n    set: h,\n    size: () => n.all().length,\n    update: f\n  };\n}, eo = (t, e) => {\n  const n = Ln(), o = to(n, t), i = gn(n);\n  i.setUserSelectAction(e);\n  const s = fn(n), a = Mn(), r = (l, c = k.LOCAL) => {\n    const b = vt(l, t), S = F(b.target.selector);\n    return S && n.addAnnotation(b, c), S;\n  }, d = (l, c = !0, b = k.LOCAL) => {\n    const S = l.map((C) => vt(C, t)), E = S.filter((C) => !F(C.target.selector));\n    return n.bulkAddAnnotation(S, c, b), E;\n  }, f = (l, c = k.LOCAL) => {\n    const b = l.map((E) => vt(E, t)), S = b.filter((E) => !F(E.target.selector));\n    return b.forEach((E) => {\n      n.getAnnotation(E.id) ? n.updateAnnotation(E, c) : n.addAnnotation(E, c);\n    }), S;\n  }, h = (l, c = k.LOCAL) => {\n    const b = wt(l, t);\n    n.updateTarget(b, c);\n  }, u = (l, c = k.LOCAL) => {\n    const b = l.map((S) => wt(S, t));\n    n.bulkUpdateTargets(b, c);\n  };\n  function g(l, c, b, S) {\n    const E = b || !!S, C = o.getAt(l, c, E).map((B) => n.getAnnotation(B)), O = S ? C.filter(S) : C;\n    if (O.length !== 0)\n      return b ? O : O[0];\n  }\n  const v = (l) => {\n    if (o.getAnnotationRects(l).length !== 0)\n      return o.getAnnotationBounds(l);\n  }, p = (l, c, b, S) => o.getIntersecting(l, c, b, S), y = (l) => o.getAnnotationRects(l), x = () => o.recalculate();\n  return n.observe(({ changes: l }) => {\n    const c = (l.deleted || []).filter((E) => F(E.target.selector)), b = (l.created || []).filter((E) => F(E.target.selector)), S = (l.updated || []).filter((E) => F(E.newValue.target.selector));\n    (c == null ? void 0 : c.length) > 0 && c.forEach((E) => o.remove(E.target)), b.length > 0 && o.set(b.map((E) => E.target), !1), (S == null ? void 0 : S.length) > 0 && S.forEach(({ newValue: E }) => o.update(E.target));\n  }), {\n    store: {\n      ...n,\n      addAnnotation: r,\n      bulkAddAnnotation: d,\n      bulkUpdateTargets: u,\n      bulkUpsertAnnotations: f,\n      getAnnotationBounds: v,\n      getAnnotationRects: y,\n      getIntersecting: p,\n      getAt: g,\n      recalculatePositions: x,\n      updateTarget: h\n    },\n    selection: i,\n    hover: s,\n    viewport: a\n  };\n}, no = () => {\n  const t = document.createElement(\"canvas\");\n  t.width = 2 * window.innerWidth, t.height = 2 * window.innerHeight, t.className = \"r6o-presence-layer\";\n  const e = t.getContext(\"2d\");\n  return e.scale(2, 2), e.translate(0.5, 0.5), t;\n}, oo = (t, e = {}) => {\n  const n = no(), o = n.getContext(\"2d\");\n  document.body.appendChild(n);\n  const i = /* @__PURE__ */ new Map(), s = (h) => Array.from(i.entries()).filter(([u, g]) => g.presenceKey === h.presenceKey).map(([u, g]) => u);\n  return t.on(\"selectionChange\", (h, u) => {\n    s(h).forEach((v) => i.delete(v)), u && u.forEach((v) => i.set(v, h));\n  }), {\n    clear: () => {\n      const { width: h, height: u } = n;\n      o.clearRect(-0.5, -0.5, h + 1, u + 1);\n    },\n    destroy: () => {\n      n.remove();\n    },\n    paint: (h, u, g) => {\n      e.font && (o.font = e.font);\n      const v = i.get(h.annotation.id);\n      if (v) {\n        const { height: p } = h.rects[0], y = h.rects[0].x + u.left, x = h.rects[0].y + u.top;\n        o.fillStyle = v.appearance.color, o.fillRect(y - 2, x - 2.5, 2, p + 5);\n        const l = o.measureText(v.appearance.label), c = l.width + 6, b = l.actualBoundingBoxAscent + l.actualBoundingBoxDescent + 8, S = l.fontBoundingBoxAscent ? 8 : 6.5;\n        return o.fillRect(y - 2, x - 2.5 - b, c, b), o.fillStyle = \"#fff\", o.fillText(v.appearance.label, y + 1, x - S), {\n          fill: v.appearance.color,\n          fillOpacity: g ? 0.45 : 0.18\n        };\n      }\n    },\n    reset: () => {\n      n.width = 2 * window.innerWidth, n.height = 2 * window.innerHeight;\n      const h = n.getContext(\"2d\");\n      h.scale(2, 2), h.translate(0.5, 0.5);\n    }\n  };\n}, It = typeof navigator < \"u\" ? navigator.userAgent.toLowerCase().indexOf(\"firefox\") > 0 : !1;\nfunction _t(t, e, n, o) {\n  t.addEventListener ? t.addEventListener(e, n, o) : t.attachEvent && t.attachEvent(\"on\".concat(e), n);\n}\nfunction ot(t, e, n, o) {\n  t.removeEventListener ? t.removeEventListener(e, n, o) : t.detachEvent && t.detachEvent(\"on\".concat(e), n);\n}\nfunction ye(t, e) {\n  const n = e.slice(0, e.length - 1);\n  for (let o = 0; o < n.length; o++) n[o] = t[n[o].toLowerCase()];\n  return n;\n}\nfunction be(t) {\n  typeof t != \"string\" && (t = \"\"), t = t.replace(/\\s/g, \"\");\n  const e = t.split(\",\");\n  let n = e.lastIndexOf(\"\");\n  for (; n >= 0; )\n    e[n - 1] += \",\", e.splice(n, 1), n = e.lastIndexOf(\"\");\n  return e;\n}\nfunction io(t, e) {\n  const n = t.length >= e.length ? t : e, o = t.length >= e.length ? e : t;\n  let i = !0;\n  for (let s = 0; s < n.length; s++)\n    o.indexOf(n[s]) === -1 && (i = !1);\n  return i;\n}\nconst lt = {\n  backspace: 8,\n  \"\": 8,\n  tab: 9,\n  clear: 12,\n  enter: 13,\n  \"\": 13,\n  return: 13,\n  esc: 27,\n  escape: 27,\n  space: 32,\n  left: 37,\n  up: 38,\n  right: 39,\n  down: 40,\n  del: 46,\n  delete: 46,\n  ins: 45,\n  insert: 45,\n  home: 36,\n  end: 35,\n  pageup: 33,\n  pagedown: 34,\n  capslock: 20,\n  num_0: 96,\n  num_1: 97,\n  num_2: 98,\n  num_3: 99,\n  num_4: 100,\n  num_5: 101,\n  num_6: 102,\n  num_7: 103,\n  num_8: 104,\n  num_9: 105,\n  num_multiply: 106,\n  num_add: 107,\n  num_enter: 108,\n  num_subtract: 109,\n  num_decimal: 110,\n  num_divide: 111,\n  \"\": 20,\n  \",\": 188,\n  \".\": 190,\n  \"/\": 191,\n  \"`\": 192,\n  \"-\": It ? 173 : 189,\n  \"=\": It ? 61 : 187,\n  \";\": It ? 59 : 186,\n  \"'\": 222,\n  \"[\": 219,\n  \"]\": 221,\n  \"\\\\\": 220\n}, H = {\n  // shiftKey\n  \"\": 16,\n  shift: 16,\n  // altKey\n  \"\": 18,\n  alt: 18,\n  option: 18,\n  // ctrlKey\n  \"\": 17,\n  ctrl: 17,\n  control: 17,\n  // metaKey\n  \"\": 91,\n  cmd: 91,\n  command: 91\n}, bt = {\n  16: \"shiftKey\",\n  18: \"altKey\",\n  17: \"ctrlKey\",\n  91: \"metaKey\",\n  shiftKey: 16,\n  ctrlKey: 17,\n  altKey: 18,\n  metaKey: 91\n}, K = {\n  16: !1,\n  18: !1,\n  17: !1,\n  91: !1\n}, _ = {};\nfor (let t = 1; t < 20; t++)\n  lt[\"f\".concat(t)] = 111 + t;\nlet I = [], ct = null, we = \"all\";\nconst z = /* @__PURE__ */ new Map(), ut = (t) => lt[t.toLowerCase()] || H[t.toLowerCase()] || t.toUpperCase().charCodeAt(0), so = (t) => Object.keys(lt).find((e) => lt[e] === t), ro = (t) => Object.keys(H).find((e) => H[e] === t);\nfunction Ae(t) {\n  we = t || \"all\";\n}\nfunction dt() {\n  return we || \"all\";\n}\nfunction ao() {\n  return I.slice(0);\n}\nfunction co() {\n  return I.map((t) => so(t) || ro(t) || String.fromCharCode(t));\n}\nfunction lo() {\n  const t = [];\n  return Object.keys(_).forEach((e) => {\n    _[e].forEach((n) => {\n      let {\n        key: o,\n        scope: i,\n        mods: s,\n        shortcut: a\n      } = n;\n      t.push({\n        scope: i,\n        shortcut: a,\n        mods: s,\n        keys: o.split(\"+\").map((r) => ut(r))\n      });\n    });\n  }), t;\n}\nfunction uo(t) {\n  const e = t.target || t.srcElement, {\n    tagName: n\n  } = e;\n  let o = !0;\n  const i = n === \"INPUT\" && ![\"checkbox\", \"radio\", \"range\", \"button\", \"file\", \"reset\", \"submit\", \"color\"].includes(e.type);\n  return (e.isContentEditable || (i || n === \"TEXTAREA\" || n === \"SELECT\") && !e.readOnly) && (o = !1), o;\n}\nfunction fo(t) {\n  return typeof t == \"string\" && (t = ut(t)), I.indexOf(t) !== -1;\n}\nfunction ho(t, e) {\n  let n, o;\n  t || (t = dt());\n  for (const i in _)\n    if (Object.prototype.hasOwnProperty.call(_, i))\n      for (n = _[i], o = 0; o < n.length; )\n        n[o].scope === t ? n.splice(o, 1).forEach((a) => {\n          let {\n            element: r\n          } = a;\n          return Xt(r);\n        }) : o++;\n  dt() === t && Ae(e || \"all\");\n}\nfunction go(t) {\n  let e = t.keyCode || t.which || t.charCode;\n  const n = I.indexOf(e);\n  if (n >= 0 && I.splice(n, 1), t.key && t.key.toLowerCase() === \"meta\" && I.splice(0, I.length), (e === 93 || e === 224) && (e = 91), e in K) {\n    K[e] = !1;\n    for (const o in H) H[o] === e && (P[o] = !1);\n  }\n}\nfunction xe(t) {\n  if (typeof t > \"u\")\n    Object.keys(_).forEach((i) => {\n      Array.isArray(_[i]) && _[i].forEach((s) => yt(s)), delete _[i];\n    }), Xt(null);\n  else if (Array.isArray(t))\n    t.forEach((i) => {\n      i.key && yt(i);\n    });\n  else if (typeof t == \"object\")\n    t.key && yt(t);\n  else if (typeof t == \"string\") {\n    for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), o = 1; o < e; o++)\n      n[o - 1] = arguments[o];\n    let [i, s] = n;\n    typeof i == \"function\" && (s = i, i = \"\"), yt({\n      key: t,\n      scope: i,\n      method: s,\n      splitKey: \"+\"\n    });\n  }\n}\nconst yt = (t) => {\n  let {\n    key: e,\n    scope: n,\n    method: o,\n    splitKey: i = \"+\"\n  } = t;\n  be(e).forEach((a) => {\n    const r = a.split(i), d = r.length, f = r[d - 1], h = f === \"*\" ? \"*\" : ut(f);\n    if (!_[h]) return;\n    n || (n = dt());\n    const u = d > 1 ? ye(H, r) : [], g = [];\n    _[h] = _[h].filter((v) => {\n      const y = (o ? v.method === o : !0) && v.scope === n && io(v.mods, u);\n      return y && g.push(v.element), !y;\n    }), g.forEach((v) => Xt(v));\n  });\n};\nfunction ne(t, e, n, o) {\n  if (e.element !== o)\n    return;\n  let i;\n  if (e.scope === n || e.scope === \"all\") {\n    i = e.mods.length > 0;\n    for (const s in K)\n      Object.prototype.hasOwnProperty.call(K, s) && (!K[s] && e.mods.indexOf(+s) > -1 || K[s] && e.mods.indexOf(+s) === -1) && (i = !1);\n    (e.mods.length === 0 && !K[16] && !K[18] && !K[17] && !K[91] || i || e.shortcut === \"*\") && (e.keys = [], e.keys = e.keys.concat(I), e.method(t, e) === !1 && (t.preventDefault ? t.preventDefault() : t.returnValue = !1, t.stopPropagation && t.stopPropagation(), t.cancelBubble && (t.cancelBubble = !0)));\n  }\n}\nfunction oe(t, e) {\n  const n = _[\"*\"];\n  let o = t.keyCode || t.which || t.charCode;\n  if (!P.filter.call(this, t)) return;\n  if ((o === 93 || o === 224) && (o = 91), I.indexOf(o) === -1 && o !== 229 && I.push(o), [\"metaKey\", \"ctrlKey\", \"altKey\", \"shiftKey\"].forEach((r) => {\n    const d = bt[r];\n    t[r] && I.indexOf(d) === -1 ? I.push(d) : !t[r] && I.indexOf(d) > -1 ? I.splice(I.indexOf(d), 1) : r === \"metaKey\" && t[r] && (I = I.filter((f) => f in bt || f === o));\n  }), o in K) {\n    K[o] = !0;\n    for (const r in H)\n      H[r] === o && (P[r] = !0);\n    if (!n) return;\n  }\n  for (const r in K)\n    Object.prototype.hasOwnProperty.call(K, r) && (K[r] = t[bt[r]]);\n  t.getModifierState && !(t.altKey && !t.ctrlKey) && t.getModifierState(\"AltGraph\") && (I.indexOf(17) === -1 && I.push(17), I.indexOf(18) === -1 && I.push(18), K[17] = !0, K[18] = !0);\n  const i = dt();\n  if (n)\n    for (let r = 0; r < n.length; r++)\n      n[r].scope === i && (t.type === \"keydown\" && n[r].keydown || t.type === \"keyup\" && n[r].keyup) && ne(t, n[r], i, e);\n  if (!(o in _)) return;\n  const s = _[o], a = s.length;\n  for (let r = 0; r < a; r++)\n    if ((t.type === \"keydown\" && s[r].keydown || t.type === \"keyup\" && s[r].keyup) && s[r].key) {\n      const d = s[r], {\n        splitKey: f\n      } = d, h = d.key.split(f), u = [];\n      for (let g = 0; g < h.length; g++)\n        u.push(ut(h[g]));\n      u.sort().join(\"\") === I.sort().join(\"\") && ne(t, d, i, e);\n    }\n}\nfunction P(t, e, n) {\n  I = [];\n  const o = be(t);\n  let i = [], s = \"all\", a = document, r = 0, d = !1, f = !0, h = \"+\", u = !1, g = !1;\n  for (n === void 0 && typeof e == \"function\" && (n = e), Object.prototype.toString.call(e) === \"[object Object]\" && (e.scope && (s = e.scope), e.element && (a = e.element), e.keyup && (d = e.keyup), e.keydown !== void 0 && (f = e.keydown), e.capture !== void 0 && (u = e.capture), typeof e.splitKey == \"string\" && (h = e.splitKey), e.single === !0 && (g = !0)), typeof e == \"string\" && (s = e), g && xe(t, s); r < o.length; r++)\n    t = o[r].split(h), i = [], t.length > 1 && (i = ye(H, t)), t = t[t.length - 1], t = t === \"*\" ? \"*\" : ut(t), t in _ || (_[t] = []), _[t].push({\n      keyup: d,\n      keydown: f,\n      scope: s,\n      mods: i,\n      shortcut: o[r],\n      method: n,\n      key: o[r],\n      splitKey: h,\n      element: a\n    });\n  if (typeof a < \"u\" && window) {\n    if (!z.has(a)) {\n      const v = function() {\n        let y = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.event;\n        return oe(y, a);\n      }, p = function() {\n        let y = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.event;\n        oe(y, a), go(y);\n      };\n      z.set(a, {\n        keydownListener: v,\n        keyupListenr: p,\n        capture: u\n      }), _t(a, \"keydown\", v, u), _t(a, \"keyup\", p, u);\n    }\n    if (!ct) {\n      const v = () => {\n        I = [];\n      };\n      ct = {\n        listener: v,\n        capture: u\n      }, _t(window, \"focus\", v, u);\n    }\n  }\n}\nfunction po(t) {\n  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"all\";\n  Object.keys(_).forEach((n) => {\n    _[n].filter((i) => i.scope === e && i.shortcut === t).forEach((i) => {\n      i && i.method && i.method();\n    });\n  });\n}\nfunction Xt(t) {\n  const e = Object.values(_).flat();\n  if (e.findIndex((o) => {\n    let {\n      element: i\n    } = o;\n    return i === t;\n  }) < 0) {\n    const {\n      keydownListener: o,\n      keyupListenr: i,\n      capture: s\n    } = z.get(t) || {};\n    o && i && (ot(t, \"keyup\", i, s), ot(t, \"keydown\", o, s), z.delete(t));\n  }\n  if ((e.length <= 0 || z.size <= 0) && (Object.keys(z).forEach((i) => {\n    const {\n      keydownListener: s,\n      keyupListenr: a,\n      capture: r\n    } = z.get(i) || {};\n    s && a && (ot(i, \"keyup\", a, r), ot(i, \"keydown\", s, r), z.delete(i));\n  }), z.clear(), Object.keys(_).forEach((i) => delete _[i]), ct)) {\n    const {\n      listener: i,\n      capture: s\n    } = ct;\n    ot(window, \"focus\", i, s), ct = null;\n  }\n}\nconst Nt = {\n  getPressedKeyString: co,\n  setScope: Ae,\n  getScope: dt,\n  deleteScope: ho,\n  getPressedKeyCodes: ao,\n  getAllKeyCodes: lo,\n  isPressed: fo,\n  filter: uo,\n  trigger: po,\n  unbind: xe,\n  keyMap: lt,\n  modifier: H,\n  modifierMap: bt\n};\nfor (const t in Nt)\n  Object.prototype.hasOwnProperty.call(Nt, t) && (P[t] = Nt[t]);\nif (typeof window < \"u\") {\n  const t = window.hotkeys;\n  P.noConflict = (e) => (e && window.hotkeys === P && (window.hotkeys = t), P), window.hotkeys = P;\n}\nconst ie = 300, ve = [\"up\", \"down\", \"left\", \"right\"], Ee = Te ? \"+a\" : \"ctrl+a\", mo = [\n  ...ve.map((t) => `shift+${t}`),\n  Ee\n], yo = (t, e, n) => {\n  let o;\n  const { annotatingEnabled: i, offsetReferenceSelector: s, selectionMode: a } = n, r = (T) => o = T;\n  let d;\n  const f = (T) => d = T, { store: h, selection: u } = e;\n  let g, v, p;\n  const y = (T) => {\n    v !== !1 && (g = it(T.target) ? void 0 : {\n      annotation: fe(),\n      selector: [],\n      creator: o,\n      created: /* @__PURE__ */ new Date()\n    });\n  }, x = Yt((T) => {\n    const m = document.getSelection();\n    if (!(m != null && m.anchorNode))\n      return;\n    if (it(m.anchorNode)) {\n      g = void 0;\n      return;\n    }\n    const A = T.timeStamp - ((p == null ? void 0 : p.timeStamp) || T.timeStamp);\n    if ((p == null ? void 0 : p.type) === \"pointerdown\" && (A < 1e3 && !g || m.isCollapsed && A < ie) && y(p || T), !g) return;\n    if (m.isCollapsed) {\n      h.getAnnotation(g.annotation) && (u.clear(), h.deleteAnnotation(g.annotation));\n      return;\n    }\n    const w = m.getRangeAt(0), L = Ye(w, t);\n    if (Ie(L)) return;\n    const M = Me(L.cloneRange());\n    (M.length !== g.selector.length || M.some((N, U) => {\n      var et;\n      return N.toString() !== ((et = g.selector[U]) == null ? void 0 : et.quote);\n    })) && (g = {\n      ...g,\n      selector: M.map((N) => Ve(N, t, s)),\n      updated: /* @__PURE__ */ new Date()\n    }, h.getAnnotation(g.annotation) ? h.updateTarget(g, k.LOCAL) : u.clear());\n  }), l = (T) => {\n    it(T.target) || (p = xt(T), v = p.button === 0);\n  }, c = (T) => {\n    if (it(T.target) || !v) return;\n    const m = () => {\n      const { x: w, y: L } = t.getBoundingClientRect(), M = T.target instanceof Node && t.contains(T.target) && h.getAt(T.clientX - w, T.clientY - L, a === \"all\", d);\n      if (M) {\n        const { selected: R } = u, N = new Set(R.map((q) => q.id)), U = Array.isArray(M) ? M.map((q) => q.id) : [M.id];\n        (N.size !== U.length || !U.every((q) => N.has(q))) && u.userSelect(U, T);\n      } else\n        u.clear();\n    }, A = T.timeStamp - p.timeStamp;\n    setTimeout(() => {\n      const w = document.getSelection();\n      w != null && w.isCollapsed && A < ie ? (g = void 0, m()) : g && g.selector.length > 0 && (O(), u.userSelect(g.annotation, xt(T)));\n    });\n  }, b = (T) => {\n    const m = document.getSelection();\n    m != null && m.isCollapsed || ((!g || g.selector.length === 0) && x(T), O(), u.userSelect(g.annotation, xt(T)));\n  }, S = (T) => {\n    T.key === \"Shift\" && g && (document.getSelection().isCollapsed || (O(), u.userSelect(g.annotation, ft(T))));\n  }, E = (T) => {\n    const m = () => setTimeout(() => {\n      (g == null ? void 0 : g.selector.length) > 0 && (u.clear(), h.addAnnotation({\n        id: g.annotation,\n        bodies: [],\n        target: g\n      }), u.userSelect(g.annotation, ft(T))), document.removeEventListener(\"selectionchange\", m);\n    }, 100);\n    document.addEventListener(\"selectionchange\", m), y(T);\n  };\n  P(mo.join(\",\"), { element: t, keydown: !0, keyup: !1 }, (T) => {\n    T.repeat || (p = ft(T));\n  }), P(Ee, { keydown: !0, keyup: !1 }, (T) => {\n    p = ft(T), E(T);\n  });\n  const C = (T) => {\n    T.repeat || T.target !== t && T.target !== document.body || (g = void 0, u.clear());\n  };\n  P(ve.join(\",\"), { keydown: !0, keyup: !1 }, C);\n  const O = () => {\n    const T = h.getAnnotation(g.annotation);\n    if (!T) {\n      h.addAnnotation({\n        id: g.annotation,\n        bodies: [],\n        target: g\n      });\n      return;\n    }\n    const { target: { updated: m } } = T, { updated: A } = g;\n    (!m || !A || m < A) && h.updateTarget(g);\n  };\n  return t.addEventListener(\"pointerdown\", l), document.addEventListener(\"pointerup\", c), document.addEventListener(\"contextmenu\", b), i && (t.addEventListener(\"keyup\", S), t.addEventListener(\"selectstart\", y), document.addEventListener(\"selectionchange\", x)), {\n    destroy: () => {\n      t.removeEventListener(\"pointerdown\", l), document.removeEventListener(\"pointerup\", c), document.removeEventListener(\"contextmenu\", b), t.removeEventListener(\"keyup\", S), t.removeEventListener(\"selectstart\", y), document.removeEventListener(\"selectionchange\", x), P.unbind();\n    },\n    setFilter: f,\n    setUser: r\n  };\n}, bo = (t, e) => ({\n  ...t,\n  annotatingEnabled: t.annotatingEnabled ?? e.annotatingEnabled,\n  user: t.user || e.user\n}), se = \"SPANS\", vo = (t, e = {}) => {\n  Le(t), Oe(t);\n  const n = bo(e, {\n    annotatingEnabled: !0,\n    user: Dn()\n  }), o = eo(t, n.userSelectAction), { selection: i, viewport: s } = o, a = o.store, r = Bn(a), d = Rn(o, r, n.adapter);\n  let f = n.user;\n  const h = n.renderer === \"CSS_HIGHLIGHTS\" ? CSS.highlights ? \"CSS_HIGHLIGHTS\" : se : n.renderer || se, u = h === \"SPANS\" ? rn(t, o, s) : h === \"CSS_HIGHLIGHTS\" ? nn(t, o, s) : h === \"CANVAS\" ? ze(t, o, s) : void 0;\n  if (!u)\n    throw `Unknown renderer implementation: ${h}`;\n  console.debug(`Using ${h} renderer`), n.style && u.setStyle(n.style);\n  const g = yo(t, o, n);\n  return g.setUser(f), {\n    ...In(o, r, n.adapter),\n    destroy: () => {\n      u.destroy(), g.destroy(), r.destroy();\n    },\n    element: t,\n    getUser: () => f,\n    setFilter: (C) => {\n      u.setFilter(C), g.setFilter(C);\n    },\n    setStyle: (C) => u.setStyle(C),\n    setUser: (C) => {\n      f = C, g.setUser(C);\n    },\n    setSelected: (C) => {\n      C ? i.setSelected(C) : i.clear();\n    },\n    setPresenceProvider: (C) => {\n      C && (u.setPainter(oo(C, n.presence)), C.on(\"selectionChange\", () => u.redraw()));\n    },\n    setVisible: (C) => u.setVisible(C),\n    on: d.on,\n    off: d.off,\n    scrollIntoView: De(t, a),\n    state: o\n  };\n};\nexport {\n  At as DEFAULT_SELECTED_STYLE,\n  W as DEFAULT_STYLE,\n  re as NOT_ANNOTATABLE_CLASS,\n  tt as NOT_ANNOTATABLE_SELECTOR,\n  k as Origin,\n  yo as SelectionHandler,\n  hn as UserSelectAction,\n  xo as W3CTextFormat,\n  Le as cancelSingleClickEvents,\n  ft as cloneKeyboardEvent,\n  xt as clonePointerEvent,\n  Ao as createBody,\n  ze as createCanvasRenderer,\n  nn as createHighlightsRenderer,\n  oo as createPresencePainter,\n  en as createRenderer,\n  rn as createSpansRenderer,\n  vo as createTextAnnotator,\n  eo as createTextAnnotatorState,\n  Yt as debounce,\n  bo as fillDefaults,\n  Re as getQuoteContext,\n  Ut as getRangeAnnotatableContents,\n  Te as isMac,\n  it as isNotAnnotatable,\n  Ce as isRangeAnnotatable,\n  F as isRevived,\n  Ie as isWhitespaceOrEmpty,\n  Ue as mergeClientRects,\n  Ke as paint,\n  jn as parseW3CTextAnnotation,\n  Oe as programmaticallyFocusable,\n  Ve as rangeToSelector,\n  vt as reviveAnnotation,\n  ae as reviveSelector,\n  wt as reviveTarget,\n  De as scrollIntoView,\n  zn as serializeW3CTextAnnotation,\n  Me as splitAnnotatableRanges,\n  wo as toDomRectList,\n  Ye as trimRangeToContainer,\n  ke as whitespaceOrEmptyRegex\n};\n//# sourceMappingURL=text-annotator.es.js.map\n","export const reanchor = (originalNode: Node, parentNode: Node, originalOffset: number) => {\n  let node = originalNode;\n\n  let offset = originalOffset;\n\n  const it = document.createNodeIterator(parentNode, NodeFilter.SHOW_TEXT);\n\n  let currentNode = it.nextNode();\n\n  let run = true;\n\n  do {\n    if (currentNode instanceof Text) {\n      if (currentNode.length < offset) {\n        offset -= currentNode.length;\n      } else {\n        node = currentNode;\n        run = false;\n      }\n    }\n\n    currentNode = it.nextNode();\n  } while (currentNode && run);\n\n  return { node, offset };\n};","import { rangeToSelector, reviveTarget as reviveTextOffsetTarget } from '@recogito/text-annotator';\nimport type { TEIAnnotation, TEIAnnotationTarget, TEIRangeSelector } from '../TEIAnnotation';\nimport { reanchor } from './utils';\nimport type { \n  TextAnnotation, \n  TextAnnotationTarget, \n  TextSelector\n} from '@recogito/text-annotator';\n\n/**\n * Helper: Returns the given XPath for a DOM node, in the form of \n * a list of segments.\n * \n * Note that this method is used recursively,\n */\nconst getXPath = (node: Node, path: string[] = []) => {\n  let xpath: string;\n  let count: number;\n  let predicate: string;\n\n  if (node.nodeType === Node.ELEMENT_NODE && (node as Element).hasAttribute('xml:id')) {\n    path.push('/');\n  } else if (node.parentNode) {\n    path = getXPath(node.parentNode, path);\n  }\n\n  if (node.nodeType === Node.ELEMENT_NODE && node.nodeName.toLowerCase().startsWith('tei-')) {\n    const el = node as Element;\n\n    if (el.hasAttribute('xml:id')) {\n      predicate = `[@xml:id='${el.getAttribute(\"xml:id\")}']`;\n    } else {\n      xpath = `count(preceding-sibling::${el.localName})`;\n      count = document.evaluate(xpath, node, null, XPathResult.NUMBER_TYPE, null).numberValue + 1;\n  \n      predicate = `[${count}]`;\n    }\n\n    path.push('/');\n    path.push(el.getAttribute('data-origname') + predicate);\n  }\n\n  return path;\n}\n\n/**\n * For the given path sgement lists, this function returns the the\n * start & end XPath expression pair.\n */\nconst toTEIXPaths = (startPath: string[], endPath: string[], selectedRange: Range) => {\n  // For a given node, returns the closest parent that is a TEI element\n  const getClosestTEINode = (node: Node | null) => {\n    if (!node) return null;\n\n    return (node.nodeName.toLowerCase().indexOf('tei-') === 0) ?\n      node : getClosestTEINode(node.parentNode);\n  };\n\n  // Helper to compute char offsets between end of XPath and a given reference node\n  const getOffsetFromTo = (fromNode: Node, toNode: Node, toOffset: number) => {\n    const range = document.createRange();\n    range.setStart(fromNode, 0);\n    range.setEnd(toNode, toOffset);\n    return range.toString().length;\n  }\n\n  const startOffset = getOffsetFromTo(\n    getClosestTEINode(selectedRange.startContainer),\n    selectedRange.startContainer,\n    selectedRange.startOffset);\n\n  const endOffset = getOffsetFromTo(\n    getClosestTEINode(selectedRange.endContainer),\n    selectedRange.endContainer,\n    selectedRange.endOffset);\n\n  const start = startPath.join('') + '::' + startOffset;\n  const end = endPath.join('') + '::' + endOffset;\n\n  return { start, end }; \n}\n\n\n/**\n * Using the DOM Range from a (revived!) TextSelector, this function computes\n * the TEIRangeSelector corresponding to that range.\n */\nexport const textToTEISelector = (selector: TextSelector): TEIRangeSelector => {\n  const { range } = selector;\n\n  // XPath segments for Range start and end nodes as a list\n  const startPathSegments: string[] = getXPath(range.startContainer);\n  const endPathSegments: string[] = getXPath(range.endContainer);\n\n  // TEI XPath expressions\n  const { start, end } = toTEIXPaths(startPathSegments, endPathSegments, range);\n\n  return {\n    start: selector.start,\n    startSelector: {\n      type: 'XPathSelector',\n      value: start\n    },\n    end: selector.end,\n    endSelector: {\n      type: 'XPathSelector',\n      value: end\n    },\n    quote: selector.quote?.replace(/\\s+/g, ' '),\n    range\n  };\n}\n\nexport const reviveTarget = (t: TextAnnotationTarget, container: HTMLElement) => {\n  const selector = Array.isArray(t.selector) ? t.selector[0] : t.selector;\n  \n  if ('start' in selector && 'end' in selector) {\n    return reviveTextOffsetTarget(t, container);\n  } else {\n    const startExpression = (selector as TEIRangeSelector).startSelector?.value;\n    const endExpression = (selector as TEIRangeSelector).endSelector?.value;\n\n    if (!startExpression || !endExpression) {\n      console.error(t);\n      throw 'Could not revive TEI target.'\n    }\n\n    const evaluateSelector = (value: string) => {\n      const splitIdx = value.indexOf('::');\n\n      if (splitIdx < 0) return;\n\n      const path = value.substring(0, splitIdx).replace(/\\/([^[/]+)/g, (_, p1) => {\n        return '/tei-' + p1.toLowerCase();\n      }).replace(/xml:/g, '');\n\n      const node = document.evaluate('.' + path,\n        container, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;\n\n      const offset = parseInt(value.substring(splitIdx + 2));\n\n      return [node, offset] as [Node, number];\n    }\n\n    const [startNode, startOffset] = evaluateSelector(startExpression);\n    const [endNode, endOffset] = evaluateSelector(endExpression);\n\n    const range = document.createRange();\n\n    // Helper\n    const reanchorIfNeeded = (parent: Node, offset: number) => {\n      if (parent.firstChild instanceof Text && parent.firstChild.length >= offset) {\n        return { node: parent.firstChild, offset };\n      } else {\n        return reanchor(parent.firstChild, parent, offset);\n      } \n    }\n\n    const reanchoredStart = reanchorIfNeeded(startNode, startOffset);\n    range.setStart(reanchoredStart.node, reanchoredStart.offset);\n\n    const reanchoredEnd = reanchorIfNeeded(endNode, endOffset);\n    range.setEnd(reanchoredEnd.node, reanchoredEnd.offset);\n\n    const textSelector = rangeToSelector(range, container);\n\n    return reviveTextOffsetTarget({\n      ...t,\n      selector: [{\n        ...textSelector,\n        ...(selector as TEIRangeSelector),\n        range\n      }]\n    }, container);\n  }\n}\n\nexport const textToTEITarget =  (container: HTMLElement) => (t: TextAnnotationTarget): TEIAnnotationTarget => {\n  const target = reviveTarget(t, container);\n  return {\n    ...t,\n    selector: target.selector.map(textToTEISelector)\n  }\n}\n\nexport const textToTEIAnnotation = (container: HTMLElement) => (a: TextAnnotation): TEIAnnotation => ({\n  ...a,\n  target: textToTEITarget(container)(a.target)\n})\n\n","import type { \n  TextAnnotator,\n  TextAnnotation,\n  TextAnnotationTarget, \n} from '@recogito/text-annotator';\nimport type { \n  Annotator,\n  Origin,  \n  Store,  \n} from '@annotorious/core';\nimport { \n  textToTEIAnnotation, \n  textToTEITarget \n} from './crosswalk';\nimport type { \n  TEIAnnotation,\n  TEIAnnotationTarget\n} from './TEIAnnotation';\n\nexport type TEIAnnotationStore = Store<TEIAnnotation> & {\n\n  // Minor change to default Annotorious store - text store returns annotations\n  // that failed to render, to support lazy document loading scenarios\n  bulkAddAnnotation(annotations: TextAnnotation[], replace: boolean, origin: Origin): TEIAnnotation[];\n\n  getAt(x: number, y: number): TEIAnnotation | undefined;\n  \n  getIntersecting(minX: number, minY: number, maxX: number, maxY: number): TEIAnnotation[];\n  \n  recalculatePositions(): void;\n\n}\n\nexport interface RecogitoTEIAnnotator<T extends unknown = TEIAnnotation> extends Annotator<TEIAnnotation, T> { }\n\nexport const TEIPlugin = (anno: TextAnnotator): RecogitoTEIAnnotator => {\n\n  const container: HTMLElement = anno.element;\n\n  const toTEI = textToTEIAnnotation(container);\n\n  const toTEITarget = textToTEITarget(container);\n\n  // Monkey-patch the store\n  const store = anno.state.store;\n\n  const _addAnnotation = store.addAnnotation;\n  store.addAnnotation = (annotation: TEIAnnotation | TextAnnotation, origin: Origin) => {\n    const { selector } = annotation.target;\n    return ('startSelector' in selector && 'start' in selector) ?\n      _addAnnotation(annotation, origin) :\n      _addAnnotation(toTEI(annotation), origin);\n  }\n\n  const _bulkAddAnnotation = store.bulkAddAnnotation;\n  store.bulkAddAnnotation = (annotations: Array<TEIAnnotation | TextAnnotation>, replace = true, origin: Origin) => {\n    const teiAnnotations = annotations.map(a => {\n      const { selector } = a.target;\n      return ('startSelector' in selector && 'start' in selector) ? a : toTEI(a);\n    });\n    \n    return _bulkAddAnnotation(teiAnnotations, replace, origin);\n  }\n\n  const _updateAnnotation = store.updateAnnotation;\n  store.updateAnnotation = (annotation: TEIAnnotation | TextAnnotation, origin: Origin) =>\n    _updateAnnotation(toTEI(annotation), origin);\n\n  const _updateTarget = store.updateTarget;\n  store.updateTarget = (target: TEIAnnotationTarget | TextAnnotationTarget, origin: Origin) => \n    _updateTarget(toTEITarget(target), origin);\n\n  return {\n    ...anno,\n    state: {\n      ...anno.state,\n      // @ts-ignore\n      store\n    }\n  }\n\n}\n"],"names":["re","tt","Ut","t","e","F","Ve","i","r","ae","h","u","n","o","s","g","v","a","d","wt","Y","D","_n","Yn","It","_t","ot","ye","be","io","lt","H","bt","K","_","I","ct","we","z","ut","so","ro","Ae","dt","ao","co","lo","uo","fo","ho","Xt","go","P","xe","yt","f","y","ne","oe","p","po","Nt","reanchor","originalNode","parentNode","originalOffset","node","offset","it","currentNode","run","getXPath","path","xpath","count","predicate","el","toTEIXPaths","startPath","endPath","selectedRange","getClosestTEINode","getOffsetFromTo","fromNode","toNode","toOffset","range","startOffset","endOffset","start","end","textToTEISelector","selector","_a","startPathSegments","endPathSegments","reviveTarget","container","_b","reviveTextOffsetTarget","startExpression","endExpression","evaluateSelector","value","splitIdx","p1","startNode","endNode","reanchorIfNeeded","parent","reanchoredStart","reanchoredEnd","textSelector","rangeToSelector","textToTEITarget","target","textToTEIAnnotation","TEIPlugin","anno","toTEI","toTEITarget","store","_addAnnotation","annotation","origin","_bulkAddAnnotation","annotations","replace","teiAnnotations","_updateAnnotation","_updateTarget"],"mappings":"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"}