const J = "not-annotatable", X = `.${J}`;
/mac/i.test(navigator.userAgentData ? navigator.userAgentData.platform : navigator.platform);
const Q = (e) => {
  const t = e.cloneContents();
  return t.querySelectorAll(X).forEach((n) => n.remove()), t;
}, Z = (e) => e.every((t) => t.range instanceof Range && !t.range.collapsed), ee = (e, t, n) => {
  const o = document.createRange(), r = t;
  o.setStart(r, 0), o.setEnd(e.startContainer, e.startOffset);
  const s = Q(o).textContent, a = e.toString(), c = s.length || 0, d = c + a.length;
  return { quote: a, start: c, end: d, range: e };
}, te = (e, t) => {
  var n, o;
  const { start: r, end: s } = e, a = e.offsetReference || t, c = document.createNodeIterator(
    t,
    NodeFilter.SHOW_TEXT,
    (u) => {
      var g;
      return (g = u.parentElement) != null && g.closest(X) ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
    }
  );
  let d = 0;
  const l = document.createRange();
  let i = c.nextNode();
  i === null && console.error("Could not revive annotation target. Content missing.");
  let f = !a;
  for (; i !== null; ) {
    if (f || (f = a == null ? void 0 : a.contains(i)), f) {
      const u = ((n = i.textContent) == null ? void 0 : n.length) || 0;
      if (d + u > r) {
        l.setStart(i, r - d);
        break;
      }
      d += u;
    }
    i = c.nextNode();
  }
  for (; i !== null; ) {
    const u = ((o = i.textContent) == null ? void 0 : o.length) || 0;
    if (d + u >= s) {
      l.setEnd(i, s - d);
      break;
    }
    d += u, i = c.nextNode();
  }
  return {
    ...e,
    range: l
  };
}, D = (e, t) => Z(e.selector) ? e : {
  ...e,
  selector: e.selector.map((n) => n.range instanceof Range && !n.range.collapsed ? n : te(n, t))
}, ne = [];
for (let e = 0; e < 256; ++e)
  ne.push((e + 256).toString(16).slice(1));
typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
const oe = [];
for (let e = 0; e < 256; ++e)
  oe.push((e + 256).toString(16).slice(1));
typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
const re = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
let se = (e = 21) => {
  let t = "", n = crypto.getRandomValues(new Uint8Array(e |= 0));
  for (; e--; )
    t += re[n[e] & 63];
  return t;
};
se();
const I = typeof navigator < "u" ? navigator.userAgent.toLowerCase().indexOf("firefox") > 0 : !1;
function K(e, t, n, o) {
  e.addEventListener ? e.addEventListener(t, n, o) : e.attachEvent && e.attachEvent("on".concat(t), n);
}
function x(e, t, n, o) {
  e.removeEventListener ? e.removeEventListener(t, n, o) : e.detachEvent && e.detachEvent("on".concat(t), n);
}
function F(e, t) {
  const n = t.slice(0, t.length - 1);
  for (let o = 0; o < n.length; o++) n[o] = e[n[o].toLowerCase()];
  return n;
}
function M(e) {
  typeof e != "string" && (e = ""), e = e.replace(/\s/g, "");
  const t = e.split(",");
  let n = t.lastIndexOf("");
  for (; n >= 0; )
    t[n - 1] += ",", t.splice(n, 1), n = t.lastIndexOf("");
  return t;
}
function ce(e, t) {
  const n = e.length >= t.length ? e : t, o = e.length >= t.length ? t : e;
  let r = !0;
  for (let s = 0; s < n.length; s++)
    o.indexOf(n[s]) === -1 && (r = !1);
  return r;
}
const T = {
  backspace: 8,
  "⌫": 8,
  tab: 9,
  clear: 12,
  enter: 13,
  "↩": 13,
  return: 13,
  esc: 27,
  escape: 27,
  space: 32,
  left: 37,
  up: 38,
  right: 39,
  down: 40,
  del: 46,
  delete: 46,
  ins: 45,
  insert: 45,
  home: 36,
  end: 35,
  pageup: 33,
  pagedown: 34,
  capslock: 20,
  num_0: 96,
  num_1: 97,
  num_2: 98,
  num_3: 99,
  num_4: 100,
  num_5: 101,
  num_6: 102,
  num_7: 103,
  num_8: 104,
  num_9: 105,
  num_multiply: 106,
  num_add: 107,
  num_enter: 108,
  num_subtract: 109,
  num_decimal: 110,
  num_divide: 111,
  "⇪": 20,
  ",": 188,
  ".": 190,
  "/": 191,
  "`": 192,
  "-": I ? 173 : 189,
  "=": I ? 61 : 187,
  ";": I ? 59 : 186,
  "'": 222,
  "[": 219,
  "]": 221,
  "\\": 220
}, m = {
  // shiftKey
  "⇧": 16,
  shift: 16,
  // altKey
  "⌥": 18,
  alt: 18,
  option: 18,
  // ctrlKey
  "⌃": 17,
  ctrl: 17,
  control: 17,
  // metaKey
  "⌘": 91,
  cmd: 91,
  command: 91
}, _ = {
  16: "shiftKey",
  18: "altKey",
  17: "ctrlKey",
  91: "metaKey",
  shiftKey: 16,
  ctrlKey: 17,
  altKey: 18,
  metaKey: 91
}, h = {
  16: !1,
  18: !1,
  17: !1,
  91: !1
}, y = {};
for (let e = 1; e < 20; e++)
  T["f".concat(e)] = 111 + e;
let p = [], C = null, V = "all";
const k = /* @__PURE__ */ new Map(), S = (e) => T[e.toLowerCase()] || m[e.toLowerCase()] || e.toUpperCase().charCodeAt(0), ae = (e) => Object.keys(T).find((t) => T[t] === e), le = (e) => Object.keys(m).find((t) => m[t] === e);
function q(e) {
  V = e || "all";
}
function A() {
  return V || "all";
}
function ie() {
  return p.slice(0);
}
function ue() {
  return p.map((e) => ae(e) || le(e) || String.fromCharCode(e));
}
function de() {
  const e = [];
  return Object.keys(y).forEach((t) => {
    y[t].forEach((n) => {
      let {
        key: o,
        scope: r,
        mods: s,
        shortcut: a
      } = n;
      e.push({
        scope: r,
        shortcut: a,
        mods: s,
        keys: o.split("+").map((c) => S(c))
      });
    });
  }), e;
}
function fe(e) {
  const t = e.target || e.srcElement, {
    tagName: n
  } = t;
  let o = !0;
  const r = n === "INPUT" && !["checkbox", "radio", "range", "button", "file", "reset", "submit", "color"].includes(t.type);
  return (t.isContentEditable || (r || n === "TEXTAREA" || n === "SELECT") && !t.readOnly) && (o = !1), o;
}
function pe(e) {
  return typeof e == "string" && (e = S(e)), p.indexOf(e) !== -1;
}
function ye(e, t) {
  let n, o;
  e || (e = A());
  for (const r in y)
    if (Object.prototype.hasOwnProperty.call(y, r))
      for (n = y[r], o = 0; o < n.length; )
        n[o].scope === e ? n.splice(o, 1).forEach((s) => {
          let {
            element: a
          } = s;
          return j(a);
        }) : o++;
  A() === e && q(t || "all");
}
function ge(e) {
  let t = e.keyCode || e.which || e.charCode;
  const n = p.indexOf(t);
  if (n >= 0 && p.splice(n, 1), e.key && e.key.toLowerCase() === "meta" && p.splice(0, p.length), (t === 93 || t === 224) && (t = 91), t in h) {
    h[t] = !1;
    for (const o in m) m[o] === t && (O[o] = !1);
  }
}
function Y(e) {
  if (typeof e > "u")
    Object.keys(y).forEach((r) => {
      Array.isArray(y[r]) && y[r].forEach((s) => N(s)), delete y[r];
    }), j(null);
  else if (Array.isArray(e))
    e.forEach((r) => {
      r.key && N(r);
    });
  else if (typeof e == "object")
    e.key && N(e);
  else if (typeof e == "string") {
    for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), o = 1; o < t; o++)
      n[o - 1] = arguments[o];
    let [r, s] = n;
    typeof r == "function" && (s = r, r = ""), N({
      key: e,
      scope: r,
      method: s,
      splitKey: "+"
    });
  }
}
const N = (e) => {
  let {
    key: t,
    scope: n,
    method: o,
    splitKey: r = "+"
  } = e;
  M(t).forEach((s) => {
    const a = s.split(r), c = a.length, d = a[c - 1], l = d === "*" ? "*" : S(d);
    if (!y[l]) return;
    n || (n = A());
    const i = c > 1 ? F(m, a) : [], f = [];
    y[l] = y[l].filter((u) => {
      const g = (o ? u.method === o : !0) && u.scope === n && ce(u.mods, i);
      return g && f.push(u.element), !g;
    }), f.forEach((u) => j(u));
  });
};
function U(e, t, n, o) {
  if (t.element !== o)
    return;
  let r;
  if (t.scope === n || t.scope === "all") {
    r = t.mods.length > 0;
    for (const s in h)
      Object.prototype.hasOwnProperty.call(h, s) && (!h[s] && t.mods.indexOf(+s) > -1 || h[s] && t.mods.indexOf(+s) === -1) && (r = !1);
    (t.mods.length === 0 && !h[16] && !h[18] && !h[17] && !h[91] || r || t.shortcut === "*") && (t.keys = [], t.keys = t.keys.concat(p), t.method(e, t) === !1 && (e.preventDefault ? e.preventDefault() : e.returnValue = !1, e.stopPropagation && e.stopPropagation(), e.cancelBubble && (e.cancelBubble = !0)));
  }
}
function R(e, t) {
  const n = y["*"];
  let o = e.keyCode || e.which || e.charCode;
  if (!O.filter.call(this, e)) return;
  if ((o === 93 || o === 224) && (o = 91), p.indexOf(o) === -1 && o !== 229 && p.push(o), ["metaKey", "ctrlKey", "altKey", "shiftKey"].forEach((c) => {
    const d = _[c];
    e[c] && p.indexOf(d) === -1 ? p.push(d) : !e[c] && p.indexOf(d) > -1 ? p.splice(p.indexOf(d), 1) : c === "metaKey" && e[c] && (p = p.filter((l) => l in _ || l === o));
  }), o in h) {
    h[o] = !0;
    for (const c in m)
      m[c] === o && (O[c] = !0);
    if (!n) return;
  }
  for (const c in h)
    Object.prototype.hasOwnProperty.call(h, c) && (h[c] = e[_[c]]);
  e.getModifierState && !(e.altKey && !e.ctrlKey) && e.getModifierState("AltGraph") && (p.indexOf(17) === -1 && p.push(17), p.indexOf(18) === -1 && p.push(18), h[17] = !0, h[18] = !0);
  const r = A();
  if (n)
    for (let c = 0; c < n.length; c++)
      n[c].scope === r && (e.type === "keydown" && n[c].keydown || e.type === "keyup" && n[c].keyup) && U(e, n[c], r, t);
  if (!(o in y)) return;
  const s = y[o], a = s.length;
  for (let c = 0; c < a; c++)
    if ((e.type === "keydown" && s[c].keydown || e.type === "keyup" && s[c].keyup) && s[c].key) {
      const d = s[c], {
        splitKey: l
      } = d, i = d.key.split(l), f = [];
      for (let u = 0; u < i.length; u++)
        f.push(S(i[u]));
      f.sort().join("") === p.sort().join("") && U(e, d, r, t);
    }
}
function O(e, t, n) {
  p = [];
  const o = M(e);
  let r = [], s = "all", a = document, c = 0, d = !1, l = !0, i = "+", f = !1, u = !1;
  for (n === void 0 && typeof t == "function" && (n = t), Object.prototype.toString.call(t) === "[object Object]" && (t.scope && (s = t.scope), t.element && (a = t.element), t.keyup && (d = t.keyup), t.keydown !== void 0 && (l = t.keydown), t.capture !== void 0 && (f = t.capture), typeof t.splitKey == "string" && (i = t.splitKey), t.single === !0 && (u = !0)), typeof t == "string" && (s = t), u && Y(e, s); c < o.length; c++)
    e = o[c].split(i), r = [], e.length > 1 && (r = F(m, e)), e = e[e.length - 1], e = e === "*" ? "*" : S(e), e in y || (y[e] = []), y[e].push({
      keyup: d,
      keydown: l,
      scope: s,
      mods: r,
      shortcut: o[c],
      method: n,
      key: o[c],
      splitKey: i,
      element: a
    });
  if (typeof a < "u" && window) {
    if (!k.has(a)) {
      const g = function() {
        let b = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.event;
        return R(b, a);
      }, w = function() {
        let b = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.event;
        R(b, a), ge(b);
      };
      k.set(a, {
        keydownListener: g,
        keyupListenr: w,
        capture: f
      }), K(a, "keydown", g, f), K(a, "keyup", w, f);
    }
    if (!C) {
      const g = () => {
        p = [];
      };
      C = {
        listener: g,
        capture: f
      }, K(window, "focus", g, f);
    }
  }
}
function he(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "all";
  Object.keys(y).forEach((n) => {
    y[n].filter((o) => o.scope === t && o.shortcut === e).forEach((o) => {
      o && o.method && o.method();
    });
  });
}
function j(e) {
  const t = Object.values(y).flat();
  if (t.findIndex((n) => {
    let {
      element: o
    } = n;
    return o === e;
  }) < 0) {
    const {
      keydownListener: n,
      keyupListenr: o,
      capture: r
    } = k.get(e) || {};
    n && o && (x(e, "keyup", o, r), x(e, "keydown", n, r), k.delete(e));
  }
  if ((t.length <= 0 || k.size <= 0) && (Object.keys(k).forEach((n) => {
    const {
      keydownListener: o,
      keyupListenr: r,
      capture: s
    } = k.get(n) || {};
    o && r && (x(n, "keyup", r, s), x(n, "keydown", o, s), k.delete(n));
  }), k.clear(), Object.keys(y).forEach((n) => delete y[n]), C)) {
    const {
      listener: n,
      capture: o
    } = C;
    x(window, "focus", n, o), C = null;
  }
}
const P = {
  getPressedKeyString: ue,
  setScope: q,
  getScope: A,
  deleteScope: ye,
  getPressedKeyCodes: ie,
  getAllKeyCodes: de,
  isPressed: pe,
  filter: fe,
  trigger: he,
  unbind: Y,
  keyMap: T,
  modifier: m,
  modifierMap: _
};
for (const e in P)
  Object.prototype.hasOwnProperty.call(P, e) && (O[e] = P[e]);
if (typeof window < "u") {
  const e = window.hotkeys;
  O.noConflict = (t) => (t && window.hotkeys === O && (window.hotkeys = e), O), window.hotkeys = O;
}
const me = (e, t, n) => {
  let o = e, r = n;
  const s = document.createNodeIterator(t, NodeFilter.SHOW_TEXT);
  let a = s.nextNode(), c = !0;
  do
    a instanceof Text && (a.length < r ? r -= a.length : (o = a, c = !1)), a = s.nextNode();
  while (a && c);
  return { node: o, offset: r };
}, L = (e, t = []) => {
  let n, o, r;
  if (e.nodeType === Node.ELEMENT_NODE && e.hasAttribute("xml:id") ? t.push("/") : e.parentNode && (t = L(e.parentNode, t)), e.nodeType === Node.ELEMENT_NODE && e.nodeName.toLowerCase().startsWith("tei-")) {
    const s = e;
    s.hasAttribute("xml:id") ? r = `[@xml:id='${s.getAttribute("xml:id")}']` : (n = `count(preceding-sibling::${s.localName})`, o = document.evaluate(n, e, null, XPathResult.NUMBER_TYPE, null).numberValue + 1, r = `[${o}]`), t.push("/"), t.push(s.getAttribute("data-origname") + r);
  }
  return t;
}, Ee = (e, t, n) => {
  const o = (l) => l ? l.nodeName.toLowerCase().indexOf("tei-") === 0 ? l : o(l.parentNode) : null, r = (l, i, f) => {
    const u = document.createRange();
    return u.setStart(l, 0), u.setEnd(i, f), u.toString().length;
  }, s = r(
    o(n.startContainer),
    n.startContainer,
    n.startOffset
  ), a = r(
    o(n.endContainer),
    n.endContainer,
    n.endOffset
  ), c = e.join("") + "::" + s, d = t.join("") + "::" + a;
  return { start: c, end: d };
}, ke = (e) => {
  var a;
  const { range: t } = e, n = L(t.startContainer), o = L(t.endContainer), { start: r, end: s } = Ee(n, o, t);
  return {
    start: e.start,
    startSelector: {
      type: "XPathSelector",
      value: r
    },
    end: e.end,
    endSelector: {
      type: "XPathSelector",
      value: s
    },
    quote: (a = e.quote) == null ? void 0 : a.replace(/\s+/g, " "),
    range: t
  };
}, we = (e, t) => {
  var o, r;
  const n = Array.isArray(e.selector) ? e.selector[0] : e.selector;
  if ("start" in n && "end" in n)
    return D(e, t);
  {
    const s = (o = n.startSelector) == null ? void 0 : o.value, a = (r = n.endSelector) == null ? void 0 : r.value;
    if (!s || !a)
      throw console.error(e), "Could not revive TEI target.";
    const c = (E) => {
      const v = E.indexOf("::");
      if (v < 0) return;
      const W = E.substring(0, v).replace(/\/([^[/]+)/g, (be, G) => "/tei-" + G.toLowerCase()).replace(/xml:/g, ""), $ = document.evaluate(
        "." + W,
        t,
        null,
        XPathResult.FIRST_ORDERED_NODE_TYPE,
        null
      ).singleNodeValue, z = parseInt(E.substring(v + 2));
      return [$, z];
    }, [d, l] = c(s), [i, f] = c(a), u = document.createRange(), g = (E, v) => E.firstChild instanceof Text && E.firstChild.length >= v ? { node: E.firstChild, offset: v } : me(E.firstChild, E, v), w = g(d, l);
    u.setStart(w.node, w.offset);
    const b = g(i, f);
    u.setEnd(b.node, b.offset);
    const H = ee(u, t);
    return D({
      ...e,
      selector: [{
        ...H,
        ...n,
        range: u
      }]
    }, t);
  }
}, B = (e) => (t) => {
  const n = we(t, e);
  return {
    ...t,
    selector: n.selector.map(ke)
  };
}, Oe = (e) => (t) => ({
  ...t,
  target: B(e)(t.target)
}), ve = (e) => {
  const t = e.element, n = Oe(t), o = B(t), r = e.state.store, s = r.addAnnotation;
  r.addAnnotation = (l, i) => {
    const { selector: f } = l.target;
    return "startSelector" in f && "start" in f ? s(l, i) : s(n(l), i);
  };
  const a = r.bulkAddAnnotation;
  r.bulkAddAnnotation = (l, i = !0, f) => {
    const u = l.map((g) => {
      const { selector: w } = g.target;
      return "startSelector" in w && "start" in w ? g : n(g);
    });
    return a(u, i, f);
  };
  const c = r.updateAnnotation;
  r.updateAnnotation = (l, i) => c(n(l), i);
  const d = r.updateTarget;
  return r.updateTarget = (l, i) => d(o(l), i), {
    ...e,
    state: {
      ...e.state,
      // @ts-ignore
      store: r
    }
  };
};
export {
  ve as TEIPlugin
};
//# sourceMappingURL=text-annotator-tei.es.js.map
