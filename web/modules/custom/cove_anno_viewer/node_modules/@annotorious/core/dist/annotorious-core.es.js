var W = Object.prototype.hasOwnProperty;
function x(e, n) {
  var t, o;
  if (e === n) return !0;
  if (e && n && (t = e.constructor) === n.constructor) {
    if (t === Date) return e.getTime() === n.getTime();
    if (t === RegExp) return e.toString() === n.toString();
    if (t === Array) {
      if ((o = e.length) === n.length)
        for (; o-- && x(e[o], n[o]); ) ;
      return o === -1;
    }
    if (!t || typeof e == "object") {
      o = 0;
      for (t in e)
        if (W.call(e, t) && ++o && !W.call(n, t) || !(t in n) || !x(e[t], n[t])) return !1;
      return Object.keys(n).length === o;
    }
  }
  return e !== e && n !== n;
}
function V() {
}
function X(e, n) {
  return e != e ? n == n : e !== n || e && typeof e == "object" || typeof e == "function";
}
const I = [];
function j(e, n = V) {
  let t;
  const o = /* @__PURE__ */ new Set();
  function a(v) {
    if (X(e, v) && (e = v, t)) {
      const w = !I.length;
      for (const h of o)
        h[1](), I.push(h, e);
      if (w) {
        for (let h = 0; h < I.length; h += 2)
          I[h][0](I[h + 1]);
        I.length = 0;
      }
    }
  }
  function p(v) {
    a(v(e));
  }
  function A(v, w = V) {
    const h = [v, w];
    return o.add(h), o.size === 1 && (t = n(a, p) || V), v(e), () => {
      o.delete(h), o.size === 0 && t && (t(), t = null);
    };
  }
  return { set: a, update: p, subscribe: A };
}
const Se = (e) => {
  const { subscribe: n, set: t } = j();
  let o;
  return n((a) => o = a), e.observe(({ changes: a }) => {
    if (o) {
      (a.deleted || []).some((v) => v.id === o) && t(void 0);
      const A = (a.updated || []).find(({ oldValue: v }) => v.id === o);
      A && t(A.newValue.id);
    }
  }), {
    get current() {
      return o;
    },
    subscribe: n,
    set: t
  };
};
var Z = /* @__PURE__ */ ((e) => (e.EDIT = "EDIT", e.SELECT = "SELECT", e.NONE = "NONE", e))(Z || {});
const z = { selected: [] }, Ue = (e, n, t) => {
  const { subscribe: o, set: a } = j(z);
  let p = n, A = z;
  o((g) => A = g);
  const v = () => {
    x(A, z) || a(z);
  }, w = () => {
    var g;
    return ((g = A.selected) == null ? void 0 : g.length) === 0;
  }, h = (g) => {
    if (w())
      return !1;
    const C = typeof g == "string" ? g : g.id;
    return A.selected.some((U) => U.id === C);
  }, L = (g, C) => {
    let U;
    if (Array.isArray(g)) {
      if (U = g.map((i) => e.getAnnotation(i)).filter(Boolean), U.length < g.length) {
        console.warn("Invalid selection: " + g.filter((i) => !U.some((s) => s.id === i)));
        return;
      }
    } else {
      const i = e.getAnnotation(g);
      if (!i) {
        console.warn("Invalid selection: " + g);
        return;
      }
      U = [i];
    }
    const r = U.reduce((i, s) => {
      const m = q(s, p, t);
      return m === "EDIT" ? [...i, { id: s.id, editable: !0 }] : m === "SELECT" ? [...i, { id: s.id }] : i;
    }, []);
    a({ selected: r, event: C });
  }, c = (g, C) => {
    const U = Array.isArray(g) ? g : [g], r = U.map((i) => e.getAnnotation(i)).filter((i) => !!i);
    a({
      selected: r.map((i) => {
        const s = C === void 0 ? q(i, p, t) === "EDIT" : C;
        return { id: i.id, editable: s };
      })
    }), r.length !== U.length && console.warn("Invalid selection", g);
  }, E = (g) => {
    if (w())
      return !1;
    const { selected: C } = A;
    C.some(({ id: r }) => g.includes(r)) && a({ selected: C.filter(({ id: r }) => !g.includes(r)) });
  }, T = (g) => p = g;
  return e.observe(
    ({ changes: g }) => E((g.deleted || []).map((C) => C.id))
  ), {
    get event() {
      return A ? A.event : null;
    },
    get selected() {
      return A ? [...A.selected] : null;
    },
    get userSelectAction() {
      return p;
    },
    clear: v,
    isEmpty: w,
    isSelected: h,
    setSelected: c,
    setUserSelectAction: T,
    subscribe: o,
    userSelect: L
  };
}, q = (e, n, t) => {
  const o = t ? t.serialize(e) : e;
  return typeof n == "function" ? n(o) : n || "EDIT";
}, O = [];
for (let e = 0; e < 256; ++e)
  O.push((e + 256).toString(16).slice(1));
function F(e, n = 0) {
  return (O[e[n + 0]] + O[e[n + 1]] + O[e[n + 2]] + O[e[n + 3]] + "-" + O[e[n + 4]] + O[e[n + 5]] + "-" + O[e[n + 6]] + O[e[n + 7]] + "-" + O[e[n + 8]] + O[e[n + 9]] + "-" + O[e[n + 10]] + O[e[n + 11]] + O[e[n + 12]] + O[e[n + 13]] + O[e[n + 14]] + O[e[n + 15]]).toLowerCase();
}
let _;
const K = new Uint8Array(16);
function ee() {
  if (!_) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    _ = crypto.getRandomValues.bind(crypto);
  }
  return _(K);
}
const te = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), G = { randomUUID: te };
function H(e, n, t) {
  if (G.randomUUID && !n && !e)
    return G.randomUUID();
  e = e || {};
  const o = e.random || (e.rng || ee)();
  return o[6] = o[6] & 15 | 64, o[8] = o[8] & 63 | 128, F(o);
}
const Te = (e) => {
  const { creator: n, updatedBy: t } = e.target, o = e.bodies.reduce((a, p) => [...a, p.creator, p.updatedBy].filter(Boolean), []);
  return [
    n,
    t,
    ...o
  ].filter((a) => a);
}, Y = (e) => {
  const n = (t) => {
    const o = { ...t };
    return t.created && typeof t.created == "string" && (o.created = new Date(t.created)), t.updated && typeof t.updated == "string" && (o.updated = new Date(t.updated)), o;
  };
  return {
    ...e,
    bodies: (e.bodies || []).map(n),
    target: n(e.target)
  };
}, De = (e, n, t, o) => ({
  id: H(),
  annotation: typeof e == "string" ? e : e.id,
  created: t || /* @__PURE__ */ new Date(),
  creator: o,
  ...n
}), ne = (e, n) => {
  const t = new Set(e.bodies.map((o) => o.id));
  return n.bodies.filter((o) => !t.has(o.id));
}, oe = (e, n) => {
  const t = new Set(n.bodies.map((o) => o.id));
  return e.bodies.filter((o) => !t.has(o.id));
}, se = (e, n) => n.bodies.map((t) => {
  const o = e.bodies.find((a) => a.id === t.id);
  return { newBody: t, oldBody: o && !x(o, t) ? o : void 0 };
}).filter(({ oldBody: t }) => t).map(({ oldBody: t, newBody: o }) => ({ oldBody: t, newBody: o })), ie = (e, n) => !x(e.target, n.target), J = (e, n) => {
  const t = ne(e, n), o = oe(e, n), a = se(e, n);
  return {
    oldValue: e,
    newValue: n,
    bodiesCreated: t.length > 0 ? t : void 0,
    bodiesDeleted: o.length > 0 ? o : void 0,
    bodiesUpdated: a.length > 0 ? a : void 0,
    targetUpdated: ie(e, n) ? { oldTarget: e.target, newTarget: n.target } : void 0
  };
};
var de = /* @__PURE__ */ ((e) => (e.BODY_ONLY = "BODY_ONLY", e.TARGET_ONLY = "TARGET_ONLY", e))(de || {}), D = /* @__PURE__ */ ((e) => (e.LOCAL = "LOCAL", e.REMOTE = "REMOTE", e.SILENT = "SILENT", e))(D || {});
const re = (e, n) => {
  var p, A;
  const { changes: t, origin: o } = n;
  if (!(e.options.origin ? e.options.origin === o : o !== "SILENT"))
    return !1;
  if (e.options.ignore) {
    const { ignore: v } = e.options, w = (L) => L && L.length > 0;
    if (!(w(t.created) || w(t.deleted))) {
      const L = (p = t.updated) == null ? void 0 : p.some((E) => w(E.bodiesCreated) || w(E.bodiesDeleted) || w(E.bodiesUpdated)), c = (A = t.updated) == null ? void 0 : A.some((E) => E.targetUpdated);
      if (v === "BODY_ONLY" && L && !c || v === "TARGET_ONLY" && c && !L)
        return !1;
    }
  }
  if (e.options.annotations) {
    const v = /* @__PURE__ */ new Set([
      ...(t.created || []).map((h) => h.id),
      ...(t.deleted || []).map((h) => h.id),
      ...(t.updated || []).map(({ oldValue: h }) => h.id)
    ]);
    return !!(Array.isArray(e.options.annotations) ? e.options.annotations : [e.options.annotations]).find((h) => v.has(h));
  } else
    return !0;
}, ae = (e, n) => {
  const t = new Set((e.created || []).map((c) => c.id)), o = new Set((e.updated || []).map(({ newValue: c }) => c.id)), a = new Set((n.created || []).map((c) => c.id)), p = new Set((n.deleted || []).map((c) => c.id)), A = new Set((n.updated || []).map(({ oldValue: c }) => c.id)), v = new Set((n.updated || []).filter(({ oldValue: c }) => t.has(c.id) || o.has(c.id)).map(({ oldValue: c }) => c.id)), w = [
    ...(e.created || []).filter((c) => !p.has(c.id)).map((c) => A.has(c.id) ? n.updated.find(({ oldValue: E }) => E.id === c.id).newValue : c),
    ...n.created || []
  ], h = [
    ...(e.deleted || []).filter((c) => !a.has(c.id)),
    ...(n.deleted || []).filter((c) => !t.has(c.id))
  ], L = [
    ...(e.updated || []).filter(({ newValue: c }) => !p.has(c.id)).map((c) => {
      const { oldValue: E, newValue: T } = c;
      if (A.has(T.id)) {
        const g = n.updated.find((C) => C.oldValue.id === T.id).newValue;
        return J(E, g);
      } else
        return c;
    }),
    ...(n.updated || []).filter(({ oldValue: c }) => !v.has(c.id))
  ];
  return { created: w, deleted: h, updated: L };
}, $ = (e) => {
  const n = e.id === void 0 ? H() : e.id;
  return {
    ...e,
    id: n,
    bodies: e.bodies === void 0 ? [] : e.bodies.map((t) => ({
      ...t,
      annotation: n
    })),
    target: {
      ...e.target,
      annotation: n
    }
  };
}, ce = (e) => e.id !== void 0, Oe = () => {
  const e = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map(), t = [], o = (d, l = {}) => {
    t.push({ onChange: d, options: l });
  }, a = (d) => {
    const l = t.findIndex((u) => u.onChange == d);
    l > -1 && t.splice(l, 1);
  }, p = (d, l) => {
    const u = {
      origin: d,
      changes: {
        created: l.created || [],
        updated: l.updated || [],
        deleted: l.deleted || []
      },
      state: [...e.values()]
    };
    t.forEach((f) => {
      re(f, u) && f.onChange(u);
    });
  }, A = (d, l = D.LOCAL) => {
    if (d.id && e.get(d.id))
      throw Error(`Cannot add annotation ${d.id} - exists already`);
    {
      const f = $(d);
      e.set(f.id, f), f.bodies.forEach((S) => n.set(S.id, f.id)), p(l, { created: [f] });
    }
  }, v = (d, l) => {
    const u = $(typeof d == "string" ? l : d), f = typeof d == "string" ? d : d.id, S = f && e.get(f);
    if (S) {
      const y = J(S, u);
      return f === u.id ? e.set(f, u) : (e.delete(f), e.set(u.id, u)), S.bodies.forEach((B) => n.delete(B.id)), u.bodies.forEach((B) => n.set(B.id, u.id)), y;
    } else
      console.warn(`Cannot update annotation ${f} - does not exist`);
  }, w = (d, l = D.LOCAL, u = D.LOCAL) => {
    const f = ce(l) ? u : l, S = v(d, l);
    S && p(f, { updated: [S] });
  }, h = (d, l = D.LOCAL) => {
    const u = d.reduce((f, S) => {
      const y = v(S);
      return y ? [...f, y] : f;
    }, []);
    u.length > 0 && p(l, { updated: u });
  }, L = (d, l = D.LOCAL) => {
    const u = e.get(d.annotation);
    if (u) {
      const f = {
        ...u,
        bodies: [...u.bodies, d]
      };
      e.set(u.id, f), n.set(d.id, f.id), p(l, { updated: [{
        oldValue: u,
        newValue: f,
        bodiesCreated: [d]
      }] });
    } else
      console.warn(`Attempt to add body to missing annotation: ${d.annotation}`);
  }, c = () => [...e.values()], E = (d = D.LOCAL) => {
    const l = [...e.values()];
    e.clear(), n.clear(), p(d, { deleted: l });
  }, T = (d, l = !0, u = D.LOCAL) => {
    const f = d.map($);
    if (l) {
      const S = [...e.values()];
      e.clear(), n.clear(), f.forEach((y) => {
        e.set(y.id, y), y.bodies.forEach((B) => n.set(B.id, y.id));
      }), p(u, { created: f, deleted: S });
    } else {
      const S = d.reduce((y, B) => {
        const M = B.id && e.get(B.id);
        return M ? [...y, M] : y;
      }, []);
      if (S.length > 0)
        throw Error(`Bulk insert would overwrite the following annotations: ${S.map((y) => y.id).join(", ")}`);
      f.forEach((y) => {
        e.set(y.id, y), y.bodies.forEach((B) => n.set(B.id, y.id));
      }), p(u, { created: f });
    }
  }, g = (d) => {
    const l = typeof d == "string" ? d : d.id, u = e.get(l);
    if (u)
      return e.delete(l), u.bodies.forEach((f) => n.delete(f.id)), u;
    console.warn(`Attempt to delete missing annotation: ${l}`);
  }, C = (d, l = D.LOCAL) => {
    const u = g(d);
    u && p(l, { deleted: [u] });
  }, U = (d, l = D.LOCAL) => {
    const u = d.reduce((f, S) => {
      const y = g(S);
      return y ? [...f, y] : f;
    }, []);
    u.length > 0 && p(l, { deleted: u });
  }, r = (d) => {
    const l = e.get(d.annotation);
    if (l) {
      const u = l.bodies.find((f) => f.id === d.id);
      if (u) {
        n.delete(u.id);
        const f = {
          ...l,
          bodies: l.bodies.filter((y) => y.id !== d.id)
        };
        return e.set(l.id, f), {
          oldValue: l,
          newValue: f,
          bodiesDeleted: [u]
        };
      } else
        console.warn(`Attempt to delete missing body ${d.id} from annotation ${d.annotation}`);
    } else
      console.warn(`Attempt to delete body from missing annotation ${d.annotation}`);
  }, i = (d, l = D.LOCAL) => {
    const u = r(d);
    u && p(l, { updated: [u] });
  }, s = (d, l = D.LOCAL) => {
    const u = d.map((f) => r(f)).filter(Boolean);
    u.length > 0 && p(l, { updated: u });
  }, m = (d) => {
    const l = e.get(d);
    return l ? { ...l } : void 0;
  }, b = (d) => {
    const l = n.get(d);
    if (l) {
      const f = m(l).bodies.find((S) => S.id === d);
      if (f)
        return f;
      console.error(`Store integrity error: body ${d} in index, but not in annotation`);
    } else
      console.warn(`Attempt to retrieve missing body: ${d}`);
  }, R = (d, l) => {
    if (d.annotation !== l.annotation)
      throw "Annotation integrity violation: annotation ID must be the same when updating bodies";
    const u = e.get(d.annotation);
    if (u) {
      const f = u.bodies.find((y) => y.id === d.id), S = {
        ...u,
        bodies: u.bodies.map((y) => y.id === f.id ? l : y)
      };
      return e.set(u.id, S), f.id !== l.id && (n.delete(f.id), n.set(l.id, S.id)), {
        oldValue: u,
        newValue: S,
        bodiesUpdated: [{ oldBody: f, newBody: l }]
      };
    } else
      console.warn(`Attempt to add body to missing annotation ${d.annotation}`);
  }, N = (d, l, u = D.LOCAL) => {
    const f = R(d, l);
    f && p(u, { updated: [f] });
  }, k = (d, l = D.LOCAL) => {
    const u = d.map((f) => R({ id: f.id, annotation: f.annotation }, f)).filter(Boolean);
    p(l, { updated: u });
  }, P = (d) => {
    const l = e.get(d.annotation);
    if (l) {
      const u = {
        ...l,
        target: {
          ...l.target,
          ...d
        }
      };
      return e.set(l.id, u), {
        oldValue: l,
        newValue: u,
        targetUpdated: {
          oldTarget: l.target,
          newTarget: d
        }
      };
    } else
      console.warn(`Attempt to update target on missing annotation: ${d.annotation}`);
  };
  return {
    addAnnotation: A,
    addBody: L,
    all: c,
    bulkAddAnnotation: T,
    bulkDeleteAnnotation: U,
    bulkDeleteBodies: s,
    bulkUpdateAnnotation: h,
    bulkUpdateBodies: k,
    bulkUpdateTargets: (d, l = D.LOCAL) => {
      const u = d.map((f) => P(f)).filter(Boolean);
      u.length > 0 && p(l, { updated: u });
    },
    clear: E,
    deleteAnnotation: C,
    deleteBody: i,
    getAnnotation: m,
    getBody: b,
    observe: o,
    unobserve: a,
    updateAnnotation: w,
    updateBody: N,
    updateTarget: (d, l = D.LOCAL) => {
      const u = P(d);
      u && p(l, { updated: [u] });
    }
  };
}, Re = (e) => ({
  ...e,
  subscribe: (t) => {
    const o = (a) => t(a.state);
    return e.observe(o), t(e.all()), () => e.unobserve(o);
  }
});
let Q = () => ({
  emit(e, ...n) {
    for (let t = this.events[e] || [], o = 0, a = t.length; o < a; o++)
      t[o](...n);
  },
  events: {},
  on(e, n) {
    var t;
    return ((t = this.events)[e] || (t[e] = [])).push(n), () => {
      var o;
      this.events[e] = (o = this.events[e]) == null ? void 0 : o.filter((a) => n !== a);
    };
  }
});
const le = 250, Be = (e) => {
  const n = Q(), t = [];
  let o = -1, a = !1, p = 0;
  const A = (s) => {
    if (!a) {
      const { changes: m } = s, b = performance.now();
      if (b - p > le)
        t.splice(o + 1), t.push(m), o = t.length - 1;
      else {
        const R = t.length - 1;
        t[R] = ae(t[R], m);
      }
      p = b;
    }
    a = !1;
  };
  e.observe(A, { origin: D.LOCAL });
  const v = (s) => s && s.length > 0 && e.bulkDeleteAnnotation(s), w = (s) => s && s.length > 0 && e.bulkAddAnnotation(s, !1), h = (s) => s && s.length > 0 && e.bulkUpdateAnnotation(s.map(({ oldValue: m }) => m)), L = (s) => s && s.length > 0 && e.bulkUpdateAnnotation(s.map(({ newValue: m }) => m)), c = (s) => s && s.length > 0 && e.bulkAddAnnotation(s, !1), E = (s) => s && s.length > 0 && e.bulkDeleteAnnotation(s);
  return {
    canRedo: () => t.length - 1 > o,
    canUndo: () => o > -1,
    destroy: () => e.unobserve(A),
    on: (s, m) => n.on(s, m),
    redo: () => {
      if (t.length - 1 > o) {
        a = !0;
        const { created: s, updated: m, deleted: b } = t[o + 1];
        w(s), L(m), E(b), n.emit("redo", t[o + 1]), o += 1;
      }
    },
    undo: () => {
      if (o > -1) {
        a = !0;
        const { created: s, updated: m, deleted: b } = t[o];
        v(s), h(m), c(b), n.emit("undo", t[o]), o -= 1;
      }
    }
  };
}, xe = () => {
  const { subscribe: e, set: n } = j([]);
  return {
    subscribe: e,
    set: n
  };
}, ke = (e, n, t, o) => {
  const { hover: a, selection: p, store: A, viewport: v } = e, w = /* @__PURE__ */ new Map();
  let h = [], L, c;
  const E = (r, i) => {
    w.has(r) ? w.get(r).push(i) : w.set(r, [i]);
  }, T = (r, i) => {
    const s = w.get(r);
    if (s) {
      const m = s.indexOf(i);
      m !== -1 && s.splice(m, 1);
    }
  }, g = (r, i, s) => {
    w.has(r) && setTimeout(() => {
      w.get(r).forEach((m) => {
        if (t) {
          const b = Array.isArray(i) ? i.map((N) => t.serialize(N)) : t.serialize(i), R = s ? s instanceof PointerEvent ? s : t.serialize(s) : void 0;
          m(b, R);
        } else
          m(i, s);
      });
    }, 1);
  }, C = () => {
    const { selected: r } = p, i = (r || []).map(({ id: s }) => A.getAnnotation(s));
    i.forEach((s) => {
      const m = h.find((b) => b.id === s.id);
      (!m || !x(m, s)) && g("updateAnnotation", s, m);
    }), h = h.map((s) => {
      const m = i.find(({ id: b }) => b === s.id);
      return m || s;
    });
  };
  p.subscribe(({ selected: r }) => {
    if (!(h.length === 0 && r.length === 0)) {
      if (h.length === 0 && r.length > 0)
        h = r.map(({ id: i }) => A.getAnnotation(i));
      else if (h.length > 0 && r.length === 0)
        h.forEach((i) => {
          const s = A.getAnnotation(i.id);
          s && !x(s, i) && g("updateAnnotation", s, i);
        }), h = [];
      else {
        const i = new Set(h.map((b) => b.id)), s = new Set(r.map(({ id: b }) => b));
        h.filter((b) => !s.has(b.id)).forEach((b) => {
          const R = A.getAnnotation(b.id);
          R && !x(R, b) && g("updateAnnotation", R, b);
        }), h = [
          // Remove annotations that were deselected
          ...h.filter((b) => s.has(b.id)),
          // Add editable annotations that were selected
          ...r.filter(({ id: b }) => !i.has(b)).map(({ id: b }) => A.getAnnotation(b))
        ];
      }
      g("selectionChanged", h);
    }
  }), a.subscribe((r) => {
    !L && r ? g("mouseEnterAnnotation", A.getAnnotation(r)) : L && !r ? g("mouseLeaveAnnotation", A.getAnnotation(L)) : L && r && (g("mouseLeaveAnnotation", A.getAnnotation(L)), g("mouseEnterAnnotation", A.getAnnotation(r))), L = r;
  }), v == null || v.subscribe((r) => g("viewportIntersect", r.map((i) => A.getAnnotation(i)))), A.observe((r) => {
    o && (c && clearTimeout(c), c = setTimeout(C, 1e3));
    const { created: i, deleted: s } = r.changes;
    (i || []).forEach((b) => g("createAnnotation", b)), (s || []).forEach((b) => g("deleteAnnotation", b)), (r.changes.updated || []).filter((b) => [
      ...b.bodiesCreated || [],
      ...b.bodiesDeleted || [],
      ...b.bodiesUpdated || []
    ].length > 0).forEach(({ oldValue: b, newValue: R }) => {
      const N = h.find((k) => k.id === b.id) || b;
      h = h.map((k) => k.id === b.id ? R : k), g("updateAnnotation", R, N);
    });
  }, { origin: D.LOCAL }), A.observe((r) => {
    if (h) {
      const i = new Set(h.map((m) => m.id)), s = (r.changes.updated || []).filter(({ newValue: m }) => i.has(m.id)).map(({ newValue: m }) => m);
      s.length > 0 && (h = h.map((m) => {
        const b = s.find((R) => R.id === m.id);
        return b || m;
      }));
    }
  }, { origin: D.REMOTE });
  const U = (r) => (i) => {
    const { updated: s } = i;
    r ? (s || []).forEach((m) => g("updateAnnotation", m.oldValue, m.newValue)) : (s || []).forEach((m) => g("updateAnnotation", m.newValue, m.oldValue));
  };
  return n.on("undo", U(!0)), n.on("redo", U(!1)), { on: E, off: T, emit: g };
}, Ie = (e) => (n) => n.map((t) => e.serialize(t)), ue = (e) => (n) => n.reduce((t, o) => {
  const { parsed: a, error: p } = e.parse(o);
  return p ? {
    parsed: t.parsed,
    failed: [...t.failed, o]
  } : a ? {
    parsed: [...t.parsed, a],
    failed: t.failed
  } : {
    ...t
  };
}, { parsed: [], failed: [] }), Ne = (e, n, t) => {
  const { store: o, selection: a } = e, p = (r) => {
    if (t) {
      const { parsed: i, error: s } = t.parse(r);
      i ? o.addAnnotation(i, D.REMOTE) : console.error(s);
    } else
      o.addAnnotation(Y(r), D.REMOTE);
  }, A = () => a.clear(), v = () => o.clear(), w = (r) => {
    const i = o.getAnnotation(r);
    return t && i ? t.serialize(i) : i;
  }, h = () => t ? o.all().map(t.serialize) : o.all(), L = () => {
    var s;
    const i = (((s = a.selected) == null ? void 0 : s.map((m) => m.id)) || []).map((m) => o.getAnnotation(m)).filter(Boolean);
    return t ? i.map(t.serialize) : i;
  }, c = (r, i = !0) => fetch(r).then((s) => s.json()).then((s) => (T(s, i), s)), E = (r) => {
    if (typeof r == "string") {
      const i = o.getAnnotation(r);
      if (o.deleteAnnotation(r), i)
        return t ? t.serialize(i) : i;
    } else {
      const i = t ? t.parse(r).parsed : r;
      if (i)
        return o.deleteAnnotation(i), r;
    }
  }, T = (r, i = !0) => {
    if (t) {
      const s = t.parseAll || ue(t), { parsed: m, failed: b } = s(r);
      b.length > 0 && console.warn(`Discarded ${b.length} invalid annotations`, b), o.bulkAddAnnotation(m, i, D.REMOTE);
    } else
      o.bulkAddAnnotation(r.map(Y), i, D.REMOTE);
  }, g = (r, i) => {
    r ? a.setSelected(r, i) : a.clear();
  }, C = (r) => {
    a.clear(), a.setUserSelectAction(r);
  }, U = (r) => {
    if (t) {
      const i = t.parse(r).parsed, s = t.serialize(o.getAnnotation(i.id));
      return o.updateAnnotation(i), s;
    } else {
      const i = o.getAnnotation(r.id);
      return o.updateAnnotation(Y(r)), i;
    }
  };
  return {
    addAnnotation: p,
    cancelSelected: A,
    canRedo: n.canRedo,
    canUndo: n.canUndo,
    clearAnnotations: v,
    getAnnotationById: w,
    getAnnotations: h,
    getSelected: L,
    loadAnnotations: c,
    redo: n.redo,
    removeAnnotation: E,
    setAnnotations: T,
    setSelected: g,
    setUserSelectAction: C,
    undo: n.undo,
    updateAnnotation: U
  };
}, ze = (e, n, t) => typeof n == "function" ? n(e, t) : n, $e = (e, n) => typeof e != "function" && typeof n != "function" ? {
  ...e || {},
  ...n || {}
} : (t, o) => {
  const a = typeof e == "function" ? e(t, o) : e, p = typeof n == "function" ? n(t, o) : n;
  return {
    ...a || {},
    ...p || {}
  };
}, fe = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
let pe = (e) => crypto.getRandomValues(new Uint8Array(e)), ge = (e, n, t) => {
  let o = (2 << Math.log2(e.length - 1)) - 1, a = -~(1.6 * o * n / e.length);
  return (p = n) => {
    let A = "";
    for (; ; ) {
      let v = t(a), w = a;
      for (; w--; )
        if (A += e[v[w] & o] || "", A.length === p) return A;
    }
  };
}, he = (e, n = 21) => ge(e, n, pe), me = (e = 21) => {
  let n = "", t = crypto.getRandomValues(new Uint8Array(e));
  for (; e--; )
    n += fe[t[e] & 63];
  return n;
};
const Ve = () => ({ isGuest: !0, id: he("1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_", 20)() }), Ae = (e) => {
  const n = JSON.stringify(e);
  let t = 0;
  for (let o = 0, a = n.length; o < a; o++) {
    let p = n.charCodeAt(o);
    t = (t << 5) - t + p, t |= 0;
  }
  return `${t}`;
}, be = (e) => e ? typeof e == "object" ? { ...e } : e : void 0, _e = (e, n) => (Array.isArray(e) ? e : [e]).map((t) => {
  const { id: o, type: a, purpose: p, value: A, created: v, modified: w, creator: h, ...L } = t;
  return {
    id: o || `temp-${Ae(t)}`,
    annotation: n,
    type: a,
    purpose: p,
    value: A,
    creator: be(h),
    created: v ? new Date(v) : void 0,
    updated: w ? new Date(w) : void 0,
    ...L
  };
}), Ye = (e) => e.map((n) => {
  var v;
  const { annotation: t, created: o, updated: a, ...p } = n, A = {
    ...p,
    created: o == null ? void 0 : o.toISOString(),
    modified: a == null ? void 0 : a.toISOString()
  };
  return (v = A.id) != null && v.startsWith("temp-") && delete A.id, A;
}), ve = [
  "#ff7c00",
  // orange
  "#1ac938",
  // green
  "#e8000b",
  // red
  "#8b2be2",
  // purple
  "#9f4800",
  // brown
  "#f14cc1",
  // pink
  "#ffc400",
  // khaki
  "#00d7ff",
  // cyan
  "#023eff"
  // blue
], Ee = () => {
  const e = [...ve];
  return { assignRandomColor: () => {
    const o = Math.floor(Math.random() * e.length), a = e[o];
    return e.splice(o, 1), a;
  }, releaseColor: (o) => e.push(o) };
}, we = () => {
  const e = Ee();
  return { addUser: (o, a) => {
    const p = e.assignRandomColor();
    return {
      label: a.name || a.id,
      avatar: a.avatar,
      color: p
    };
  }, removeUser: (o) => e.releaseColor(o.appearance.color) };
}, Ce = (e, n) => e.every((t) => e.includes(t)) && n.every((t) => e.includes(t)), je = me(), Pe = (e = we()) => {
  const n = Q(), t = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map(), a = (c, E) => {
    if (t.has(c)) {
      console.warn("Attempt to add user that is already present", c, E);
      return;
    }
    const T = e.addUser(c, E);
    t.set(c, {
      ...E,
      presenceKey: c,
      appearance: T
    });
  }, p = (c) => {
    const E = t.get(c);
    if (!E) {
      console.warn("Attempt to remove user that is not present", c);
      return;
    }
    e.removeUser(E), t.delete(c);
  }, A = (c) => {
    const E = new Set(c.map((C) => C.presenceKey)), T = c.filter(({ presenceKey: C }) => !t.has(C)), g = Array.from(t.values()).filter((C) => !E.has(C.presenceKey));
    T.forEach(({ presenceKey: C, user: U }) => a(C, U)), g.forEach((C) => {
      const { presenceKey: U } = C;
      o.has(U) && n.emit("selectionChange", C, null), p(U);
    }), (T.length > 0 || g.length > 0) && n.emit("presence", h());
  }, v = (c, E) => {
    const T = t.get(c);
    if (!T) {
      console.warn("Activity notification from user that is not present");
      return;
    }
    const g = o.get(c);
    (!g || !Ce(g, E)) && (o.set(c, E), n.emit("selectionChange", T, E));
  }, w = (c, E) => {
    const T = t.get(c);
    if (!T) {
      console.warn("Selection change for user that is not present", c);
      return;
    }
    E ? o.set(c, E) : o.delete(c), n.emit("selectionChange", T, E);
  }, h = () => [...Array.from(t.values())];
  return {
    getPresentUsers: h,
    notifyActivity: v,
    on: (c, E) => n.on(c, E),
    syncUsers: A,
    updateSelection: w
  };
};
export {
  de as Ignore,
  D as Origin,
  je as PRESENCE_KEY,
  Z as UserSelectAction,
  $e as chainStyles,
  ze as computeStyle,
  Ve as createAnonymousGuest,
  Ne as createBaseAnnotator,
  De as createBody,
  we as createDefaultAppearanceProvider,
  Se as createHoverState,
  ke as createLifecycleObserver,
  Pe as createPresenceState,
  Ue as createSelectionState,
  Oe as createStore,
  Be as createUndoStack,
  xe as createViewportState,
  Ee as defaultColorProvider,
  J as diffAnnotations,
  Te as getContributors,
  ae as mergeChanges,
  q as onUserSelect,
  ue as parseAll,
  _e as parseW3CBodies,
  be as parseW3CUser,
  Y as reviveDates,
  Ie as serializeAll,
  Ye as serializeW3CBodies,
  re as shouldNotify,
  Re as toSvelteStore
};
//# sourceMappingURL=annotorious-core.es.js.map
