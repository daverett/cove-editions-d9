import { offset as it, shift as nt, flip as ot, inline as st, arrow as rt, computePosition as ct } from "./annotorious-react.es28.js";
import { createCoords as y, rectToClientRect as G, round as H, floor as D, max as E, min as z } from "./annotorious-react.es27.js";
import { getOverflowAncestors as $, isElement as v, getWindow as L, getFrameElement as U, getComputedStyle as b, getDocumentElement as R, isHTMLElement as O, isWebKit as J, isTopLayer as M, getNodeName as S, isOverflowElement as _, getNodeScroll as A, getParentNode as W, isLastTraversableNode as N, isTableElement as lt, isContainingBlock as Q, getContainingBlock as ft } from "./annotorious-react.es21.js";
function Y(t) {
  const e = b(t);
  let i = parseFloat(e.width) || 0, n = parseFloat(e.height) || 0;
  const o = O(t), r = o ? t.offsetWidth : i, s = o ? t.offsetHeight : n, c = H(i) !== r || H(n) !== s;
  return c && (i = r, n = s), {
    width: i,
    height: n,
    $: c
  };
}
function k(t) {
  return v(t) ? t : t.contextElement;
}
function F(t) {
  const e = k(t);
  if (!O(e))
    return y(1);
  const i = e.getBoundingClientRect(), {
    width: n,
    height: o,
    $: r
  } = Y(e);
  let s = (r ? H(i.width) : i.width) / n, c = (r ? H(i.height) : i.height) / o;
  return (!s || !Number.isFinite(s)) && (s = 1), (!c || !Number.isFinite(c)) && (c = 1), {
    x: s,
    y: c
  };
}
const ut = /* @__PURE__ */ y(0);
function Z(t) {
  const e = L(t);
  return !J() || !e.visualViewport ? ut : {
    x: e.visualViewport.offsetLeft,
    y: e.visualViewport.offsetTop
  };
}
function ht(t, e, i) {
  return e === void 0 && (e = !1), !i || e && i !== L(t) ? !1 : e;
}
function T(t, e, i, n) {
  e === void 0 && (e = !1), i === void 0 && (i = !1);
  const o = t.getBoundingClientRect(), r = k(t);
  let s = y(1);
  e && (n ? v(n) && (s = F(n)) : s = F(t));
  const c = ht(r, i, n) ? Z(r) : y(0);
  let l = (o.left + c.x) / s.x, f = (o.top + c.y) / s.y, u = o.width / s.x, h = o.height / s.y;
  if (r) {
    const p = L(r), g = n && v(n) ? L(n) : n;
    let x = p, a = U(x);
    for (; a && n && g !== x; ) {
      const w = F(a), d = a.getBoundingClientRect(), m = b(a), C = d.left + (a.clientLeft + parseFloat(m.paddingLeft)) * w.x, B = d.top + (a.clientTop + parseFloat(m.paddingTop)) * w.y;
      l *= w.x, f *= w.y, u *= w.x, h *= w.y, l += C, f += B, x = L(a), a = U(x);
    }
  }
  return G({
    width: u,
    height: h,
    x: l,
    y: f
  });
}
function q(t, e) {
  const i = A(t).scrollLeft;
  return e ? e.left + i : T(R(t)).left + i;
}
function X(t, e, i) {
  i === void 0 && (i = !1);
  const n = t.getBoundingClientRect(), o = n.left + e.scrollLeft - (i ? 0 : (
    // RTL <body> scrollbar.
    q(t, n)
  )), r = n.top + e.scrollTop;
  return {
    x: o,
    y: r
  };
}
function at(t) {
  let {
    elements: e,
    rect: i,
    offsetParent: n,
    strategy: o
  } = t;
  const r = o === "fixed", s = R(n), c = e ? M(e.floating) : !1;
  if (n === s || c && r)
    return i;
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  }, f = y(1);
  const u = y(0), h = O(n);
  if ((h || !h && !r) && ((S(n) !== "body" || _(s)) && (l = A(n)), O(n))) {
    const g = T(n);
    f = F(n), u.x = g.x + n.clientLeft, u.y = g.y + n.clientTop;
  }
  const p = s && !h && !r ? X(s, l, !0) : y(0);
  return {
    width: i.width * f.x,
    height: i.height * f.y,
    x: i.x * f.x - l.scrollLeft * f.x + u.x + p.x,
    y: i.y * f.y - l.scrollTop * f.y + u.y + p.y
  };
}
function dt(t) {
  return Array.from(t.getClientRects());
}
function gt(t) {
  const e = R(t), i = A(t), n = t.ownerDocument.body, o = E(e.scrollWidth, e.clientWidth, n.scrollWidth, n.clientWidth), r = E(e.scrollHeight, e.clientHeight, n.scrollHeight, n.clientHeight);
  let s = -i.scrollLeft + q(t);
  const c = -i.scrollTop;
  return b(n).direction === "rtl" && (s += E(e.clientWidth, n.clientWidth) - o), {
    width: o,
    height: r,
    x: s,
    y: c
  };
}
function pt(t, e) {
  const i = L(t), n = R(t), o = i.visualViewport;
  let r = n.clientWidth, s = n.clientHeight, c = 0, l = 0;
  if (o) {
    r = o.width, s = o.height;
    const f = J();
    (!f || f && e === "fixed") && (c = o.offsetLeft, l = o.offsetTop);
  }
  return {
    width: r,
    height: s,
    x: c,
    y: l
  };
}
function wt(t, e) {
  const i = T(t, !0, e === "fixed"), n = i.top + t.clientTop, o = i.left + t.clientLeft, r = O(t) ? F(t) : y(1), s = t.clientWidth * r.x, c = t.clientHeight * r.y, l = o * r.x, f = n * r.y;
  return {
    width: s,
    height: c,
    x: l,
    y: f
  };
}
function K(t, e, i) {
  let n;
  if (e === "viewport")
    n = pt(t, i);
  else if (e === "document")
    n = gt(R(t));
  else if (v(e))
    n = wt(e, i);
  else {
    const o = Z(t);
    n = {
      x: e.x - o.x,
      y: e.y - o.y,
      width: e.width,
      height: e.height
    };
  }
  return G(n);
}
function tt(t, e) {
  const i = W(t);
  return i === e || !v(i) || N(i) ? !1 : b(i).position === "fixed" || tt(i, e);
}
function mt(t, e) {
  const i = e.get(t);
  if (i)
    return i;
  let n = $(t, [], !1).filter((c) => v(c) && S(c) !== "body"), o = null;
  const r = b(t).position === "fixed";
  let s = r ? W(t) : t;
  for (; v(s) && !N(s); ) {
    const c = b(s), l = Q(s);
    !l && c.position === "fixed" && (o = null), (r ? !l && !o : !l && c.position === "static" && !!o && ["absolute", "fixed"].includes(o.position) || _(s) && !l && tt(t, s)) ? n = n.filter((u) => u !== s) : o = c, s = W(s);
  }
  return e.set(t, n), n;
}
function yt(t) {
  let {
    element: e,
    boundary: i,
    rootBoundary: n,
    strategy: o
  } = t;
  const s = [...i === "clippingAncestors" ? M(e) ? [] : mt(e, this._c) : [].concat(i), n], c = s[0], l = s.reduce((f, u) => {
    const h = K(e, u, o);
    return f.top = E(h.top, f.top), f.right = z(h.right, f.right), f.bottom = z(h.bottom, f.bottom), f.left = E(h.left, f.left), f;
  }, K(e, c, o));
  return {
    width: l.right - l.left,
    height: l.bottom - l.top,
    x: l.left,
    y: l.top
  };
}
function xt(t) {
  const {
    width: e,
    height: i
  } = Y(t);
  return {
    width: e,
    height: i
  };
}
function vt(t, e, i) {
  const n = O(e), o = R(e), r = i === "fixed", s = T(t, !0, r, e);
  let c = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l = y(0);
  if (n || !n && !r)
    if ((S(e) !== "body" || _(o)) && (c = A(e)), n) {
      const p = T(e, !0, r, e);
      l.x = p.x + e.clientLeft, l.y = p.y + e.clientTop;
    } else o && (l.x = q(o));
  const f = o && !n && !r ? X(o, c) : y(0), u = s.left + c.scrollLeft - l.x - f.x, h = s.top + c.scrollTop - l.y - f.y;
  return {
    x: u,
    y: h,
    width: s.width,
    height: s.height
  };
}
function V(t) {
  return b(t).position === "static";
}
function j(t, e) {
  if (!O(t) || b(t).position === "fixed")
    return null;
  if (e)
    return e(t);
  let i = t.offsetParent;
  return R(t) === i && (i = i.ownerDocument.body), i;
}
function et(t, e) {
  const i = L(t);
  if (M(t))
    return i;
  if (!O(t)) {
    let o = W(t);
    for (; o && !N(o); ) {
      if (v(o) && !V(o))
        return o;
      o = W(o);
    }
    return i;
  }
  let n = j(t, e);
  for (; n && lt(n) && V(n); )
    n = j(n, e);
  return n && N(n) && V(n) && !Q(n) ? i : n || ft(t) || i;
}
const bt = async function(t) {
  const e = this.getOffsetParent || et, i = this.getDimensions, n = await i(t.floating);
  return {
    reference: vt(t.reference, await e(t.floating), t.strategy),
    floating: {
      x: 0,
      y: 0,
      width: n.width,
      height: n.height
    }
  };
};
function Rt(t) {
  return b(t).direction === "rtl";
}
const Ot = {
  convertOffsetParentRelativeRectToViewportRelativeRect: at,
  getDocumentElement: R,
  getClippingRect: yt,
  getOffsetParent: et,
  getElementRects: bt,
  getClientRects: dt,
  getDimensions: xt,
  getScale: F,
  isElement: v,
  isRTL: Rt
};
function Ct(t, e) {
  let i = null, n;
  const o = R(t);
  function r() {
    var c;
    clearTimeout(n), (c = i) == null || c.disconnect(), i = null;
  }
  function s(c, l) {
    c === void 0 && (c = !1), l === void 0 && (l = 1), r();
    const {
      left: f,
      top: u,
      width: h,
      height: p
    } = t.getBoundingClientRect();
    if (c || e(), !h || !p)
      return;
    const g = D(u), x = D(o.clientWidth - (f + h)), a = D(o.clientHeight - (u + p)), w = D(f), m = {
      rootMargin: -g + "px " + -x + "px " + -a + "px " + -w + "px",
      threshold: E(0, z(1, l)) || 1
    };
    let C = !0;
    function B(P) {
      const I = P[0].intersectionRatio;
      if (I !== l) {
        if (!C)
          return s();
        I ? s(!1, I) : n = setTimeout(() => {
          s(!1, 1e-7);
        }, 1e3);
      }
      C = !1;
    }
    try {
      i = new IntersectionObserver(B, {
        ...m,
        // Handle <iframe>s
        root: o.ownerDocument
      });
    } catch {
      i = new IntersectionObserver(B, m);
    }
    i.observe(t);
  }
  return s(!0), r;
}
function Ft(t, e, i, n) {
  n === void 0 && (n = {});
  const {
    ancestorScroll: o = !0,
    ancestorResize: r = !0,
    elementResize: s = typeof ResizeObserver == "function",
    layoutShift: c = typeof IntersectionObserver == "function",
    animationFrame: l = !1
  } = n, f = k(t), u = o || r ? [...f ? $(f) : [], ...$(e)] : [];
  u.forEach((d) => {
    o && d.addEventListener("scroll", i, {
      passive: !0
    }), r && d.addEventListener("resize", i);
  });
  const h = f && c ? Ct(f, i) : null;
  let p = -1, g = null;
  s && (g = new ResizeObserver((d) => {
    let [m] = d;
    m && m.target === f && g && (g.unobserve(e), cancelAnimationFrame(p), p = requestAnimationFrame(() => {
      var C;
      (C = g) == null || C.observe(e);
    })), i();
  }), f && !l && g.observe(f), g.observe(e));
  let x, a = l ? T(t) : null;
  l && w();
  function w() {
    const d = T(t);
    a && (d.x !== a.x || d.y !== a.y || d.width !== a.width || d.height !== a.height) && i(), a = d, x = requestAnimationFrame(w);
  }
  return i(), () => {
    var d;
    u.forEach((m) => {
      o && m.removeEventListener("scroll", i), r && m.removeEventListener("resize", i);
    }), h == null || h(), (d = g) == null || d.disconnect(), g = null, l && cancelAnimationFrame(x);
  };
}
const Wt = it, Bt = nt, Dt = ot, Ht = rt, Nt = st, At = (t, e, i) => {
  const n = /* @__PURE__ */ new Map(), o = {
    platform: Ot,
    ...i
  }, r = {
    ...o.platform,
    _c: n
  };
  return ct(t, e, {
    ...o,
    platform: r
  });
};
export {
  Ht as arrow,
  Ft as autoUpdate,
  At as computePosition,
  Dt as flip,
  $ as getOverflowAncestors,
  Nt as inline,
  Wt as offset,
  Ot as platform,
  Bt as shift
};
//# sourceMappingURL=annotorious-react.es16.js.map
