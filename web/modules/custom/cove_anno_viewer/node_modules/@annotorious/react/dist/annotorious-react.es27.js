const l = Math.min, a = Math.max, P = Math.round, M = Math.floor, O = (t) => ({
  x: t,
  y: t
}), m = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, p = {
  start: "end",
  end: "start"
};
function S(t, n, e) {
  return a(t, l(n, e));
}
function w(t, n) {
  return typeof t == "function" ? t(n) : t;
}
function f(t) {
  return t.split("-")[0];
}
function g(t) {
  return t.split("-")[1];
}
function h(t) {
  return t === "x" ? "y" : "x";
}
function x(t) {
  return t === "y" ? "height" : "width";
}
function b(t) {
  return ["top", "bottom"].includes(f(t)) ? "y" : "x";
}
function d(t) {
  return h(b(t));
}
function j(t, n, e) {
  e === void 0 && (e = !1);
  const r = g(t), o = d(t), i = x(o);
  let c = o === "x" ? r === (e ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return n.reference[i] > n.floating[i] && (c = u(c)), [c, u(c)];
}
function C(t) {
  const n = u(t);
  return [s(t), n, s(n)];
}
function s(t) {
  return t.replace(/start|end/g, (n) => p[n]);
}
function A(t, n, e) {
  const r = ["left", "right"], o = ["right", "left"], i = ["top", "bottom"], c = ["bottom", "top"];
  switch (t) {
    case "top":
    case "bottom":
      return e ? n ? o : r : n ? r : o;
    case "left":
    case "right":
      return n ? i : c;
    default:
      return [];
  }
}
function L(t, n, e, r) {
  const o = g(t);
  let i = A(f(t), e === "start", r);
  return o && (i = i.map((c) => c + "-" + o), n && (i = i.concat(i.map(s)))), i;
}
function u(t) {
  return t.replace(/left|right|bottom|top/g, (n) => m[n]);
}
function y(t) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...t
  };
}
function E(t) {
  return typeof t != "number" ? y(t) : {
    top: t,
    right: t,
    bottom: t,
    left: t
  };
}
function R(t) {
  const {
    x: n,
    y: e,
    width: r,
    height: o
  } = t;
  return {
    width: r,
    height: o,
    top: e,
    left: n,
    right: n + r,
    bottom: e + o,
    x: n,
    y: e
  };
}
export {
  S as clamp,
  O as createCoords,
  w as evaluate,
  y as expandPaddingObject,
  M as floor,
  g as getAlignment,
  d as getAlignmentAxis,
  j as getAlignmentSides,
  x as getAxisLength,
  C as getExpandedPlacements,
  s as getOppositeAlignmentPlacement,
  h as getOppositeAxis,
  L as getOppositeAxisPlacements,
  u as getOppositePlacement,
  E as getPaddingObject,
  f as getSide,
  b as getSideAxis,
  a as max,
  l as min,
  R as rectToClientRect,
  P as round
};
//# sourceMappingURL=annotorious-react.es27.js.map
