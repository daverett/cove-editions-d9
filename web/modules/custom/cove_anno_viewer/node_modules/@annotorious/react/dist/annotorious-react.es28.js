import { evaluate as Y, getSide as F, getSideAxis as M, getOppositePlacement as Q, getExpandedPlacements as U, getOppositeAxisPlacements as Z, getAlignmentSides as tt, rectToClientRect as $, getPaddingObject as H, clamp as _, getAlignmentAxis as q, getAlignment as I, min as X, max as z, getOppositeAxis as et, getAxisLength as G } from "./annotorious-react.es27.js";
function W(o, c, l) {
  let {
    reference: e,
    floating: s
  } = o;
  const t = M(c), a = q(c), r = G(a), d = F(c), g = t === "y", u = e.x + e.width / 2 - s.width / 2, i = e.y + e.height / 2 - s.height / 2, m = e[r] / 2 - s[r] / 2;
  let n;
  switch (d) {
    case "top":
      n = {
        x: u,
        y: e.y - s.height
      };
      break;
    case "bottom":
      n = {
        x: u,
        y: e.y + e.height
      };
      break;
    case "right":
      n = {
        x: e.x + e.width,
        y: i
      };
      break;
    case "left":
      n = {
        x: e.x - s.width,
        y: i
      };
      break;
    default:
      n = {
        x: e.x,
        y: e.y
      };
  }
  switch (I(c)) {
    case "start":
      n[a] -= m * (l && g ? -1 : 1);
      break;
    case "end":
      n[a] += m * (l && g ? -1 : 1);
      break;
  }
  return n;
}
const st = async (o, c, l) => {
  const {
    placement: e = "bottom",
    strategy: s = "absolute",
    middleware: t = [],
    platform: a
  } = l, r = t.filter(Boolean), d = await (a.isRTL == null ? void 0 : a.isRTL(c));
  let g = await a.getElementRects({
    reference: o,
    floating: c,
    strategy: s
  }), {
    x: u,
    y: i
  } = W(g, e, d), m = e, n = {}, f = 0;
  for (let h = 0; h < r.length; h++) {
    const {
      name: x,
      fn: w
    } = r[h], {
      x: A,
      y,
      data: R,
      reset: p
    } = await w({
      x: u,
      y: i,
      initialPlacement: e,
      placement: m,
      strategy: s,
      middlewareData: n,
      rects: g,
      platform: a,
      elements: {
        reference: o,
        floating: c
      }
    });
    u = A ?? u, i = y ?? i, n = {
      ...n,
      [x]: {
        ...n[x],
        ...R
      }
    }, p && f <= 50 && (f++, typeof p == "object" && (p.placement && (m = p.placement), p.rects && (g = p.rects === !0 ? await a.getElementRects({
      reference: o,
      floating: c,
      strategy: s
    }) : p.rects), {
      x: u,
      y: i
    } = W(g, m, d)), h = -1);
  }
  return {
    x: u,
    y: i,
    placement: m,
    strategy: s,
    middlewareData: n
  };
};
async function J(o, c) {
  var l;
  c === void 0 && (c = {});
  const {
    x: e,
    y: s,
    platform: t,
    rects: a,
    elements: r,
    strategy: d
  } = o, {
    boundary: g = "clippingAncestors",
    rootBoundary: u = "viewport",
    elementContext: i = "floating",
    altBoundary: m = !1,
    padding: n = 0
  } = Y(c, o), f = H(n), x = r[m ? i === "floating" ? "reference" : "floating" : i], w = $(await t.getClippingRect({
    element: (l = await (t.isElement == null ? void 0 : t.isElement(x))) == null || l ? x : x.contextElement || await (t.getDocumentElement == null ? void 0 : t.getDocumentElement(r.floating)),
    boundary: g,
    rootBoundary: u,
    strategy: d
  })), A = i === "floating" ? {
    x: e,
    y: s,
    width: a.floating.width,
    height: a.floating.height
  } : a.reference, y = await (t.getOffsetParent == null ? void 0 : t.getOffsetParent(r.floating)), R = await (t.isElement == null ? void 0 : t.isElement(y)) ? await (t.getScale == null ? void 0 : t.getScale(y)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, p = $(t.convertOffsetParentRelativeRectToViewportRelativeRect ? await t.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: r,
    rect: A,
    offsetParent: y,
    strategy: d
  }) : A);
  return {
    top: (w.top - p.top + f.top) / R.y,
    bottom: (p.bottom - w.bottom + f.bottom) / R.y,
    left: (w.left - p.left + f.left) / R.x,
    right: (p.right - w.right + f.right) / R.x
  };
}
const ct = (o) => ({
  name: "arrow",
  options: o,
  async fn(c) {
    const {
      x: l,
      y: e,
      placement: s,
      rects: t,
      platform: a,
      elements: r,
      middlewareData: d
    } = c, {
      element: g,
      padding: u = 0
    } = Y(o, c) || {};
    if (g == null)
      return {};
    const i = H(u), m = {
      x: l,
      y: e
    }, n = q(s), f = G(n), h = await a.getDimensions(g), x = n === "y", w = x ? "top" : "left", A = x ? "bottom" : "right", y = x ? "clientHeight" : "clientWidth", R = t.reference[f] + t.reference[n] - m[n] - t.floating[f], p = m[n] - t.reference[n], C = await (a.getOffsetParent == null ? void 0 : a.getOffsetParent(g));
    let k = C ? C[y] : 0;
    (!k || !await (a.isElement == null ? void 0 : a.isElement(C))) && (k = r.floating[y] || t.floating[f]);
    const j = R / 2 - p / 2, T = k / 2 - h[f] / 2 - 1, v = X(i[w], T), L = X(i[A], T), S = v, B = k - h[f] - L, b = k / 2 - h[f] / 2 + j, D = _(S, b, B), P = !d.arrow && I(s) != null && b !== D && t.reference[f] / 2 - (b < S ? v : L) - h[f] / 2 < 0, O = P ? b < S ? b - S : b - B : 0;
    return {
      [n]: m[n] + O,
      data: {
        [n]: D,
        centerOffset: b - D - O,
        ...P && {
          alignmentOffset: O
        }
      },
      reset: P
    };
  }
}), lt = function(o) {
  return o === void 0 && (o = {}), {
    name: "flip",
    options: o,
    async fn(c) {
      var l, e;
      const {
        placement: s,
        middlewareData: t,
        rects: a,
        initialPlacement: r,
        platform: d,
        elements: g
      } = c, {
        mainAxis: u = !0,
        crossAxis: i = !0,
        fallbackPlacements: m,
        fallbackStrategy: n = "bestFit",
        fallbackAxisSideDirection: f = "none",
        flipAlignment: h = !0,
        ...x
      } = Y(o, c);
      if ((l = t.arrow) != null && l.alignmentOffset)
        return {};
      const w = F(s), A = M(r), y = F(r) === r, R = await (d.isRTL == null ? void 0 : d.isRTL(g.floating)), p = m || (y || !h ? [Q(r)] : U(r)), C = f !== "none";
      !m && C && p.push(...Z(r, h, f, R));
      const k = [r, ...p], j = await J(c, x), T = [];
      let v = ((e = t.flip) == null ? void 0 : e.overflows) || [];
      if (u && T.push(j[w]), i) {
        const b = tt(s, a, R);
        T.push(j[b[0]], j[b[1]]);
      }
      if (v = [...v, {
        placement: s,
        overflows: T
      }], !T.every((b) => b <= 0)) {
        var L, S;
        const b = (((L = t.flip) == null ? void 0 : L.index) || 0) + 1, D = k[b];
        if (D)
          return {
            data: {
              index: b,
              overflows: v
            },
            reset: {
              placement: D
            }
          };
        let P = (S = v.filter((O) => O.overflows[0] <= 0).sort((O, E) => O.overflows[1] - E.overflows[1])[0]) == null ? void 0 : S.placement;
        if (!P)
          switch (n) {
            case "bestFit": {
              var B;
              const O = (B = v.filter((E) => {
                if (C) {
                  const V = M(E.placement);
                  return V === A || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  V === "y";
                }
                return !0;
              }).map((E) => [E.placement, E.overflows.filter((V) => V > 0).reduce((V, N) => V + N, 0)]).sort((E, V) => E[1] - V[1])[0]) == null ? void 0 : B[0];
              O && (P = O);
              break;
            }
            case "initialPlacement":
              P = r;
              break;
          }
        if (s !== P)
          return {
            reset: {
              placement: P
            }
          };
      }
      return {};
    }
  };
};
function K(o) {
  const c = X(...o.map((t) => t.left)), l = X(...o.map((t) => t.top)), e = z(...o.map((t) => t.right)), s = z(...o.map((t) => t.bottom));
  return {
    x: c,
    y: l,
    width: e - c,
    height: s - l
  };
}
function nt(o) {
  const c = o.slice().sort((s, t) => s.y - t.y), l = [];
  let e = null;
  for (let s = 0; s < c.length; s++) {
    const t = c[s];
    !e || t.y - e.y > e.height / 2 ? l.push([t]) : l[l.length - 1].push(t), e = t;
  }
  return l.map((s) => $(K(s)));
}
const at = function(o) {
  return o === void 0 && (o = {}), {
    name: "inline",
    options: o,
    async fn(c) {
      const {
        placement: l,
        elements: e,
        rects: s,
        platform: t,
        strategy: a
      } = c, {
        padding: r = 2,
        x: d,
        y: g
      } = Y(o, c), u = Array.from(await (t.getClientRects == null ? void 0 : t.getClientRects(e.reference)) || []), i = nt(u), m = $(K(u)), n = H(r);
      function f() {
        if (i.length === 2 && i[0].left > i[1].right && d != null && g != null)
          return i.find((x) => d > x.left - n.left && d < x.right + n.right && g > x.top - n.top && g < x.bottom + n.bottom) || m;
        if (i.length >= 2) {
          if (M(l) === "y") {
            const v = i[0], L = i[i.length - 1], S = F(l) === "top", B = v.top, b = L.bottom, D = S ? v.left : L.left, P = S ? v.right : L.right, O = P - D, E = b - B;
            return {
              top: B,
              bottom: b,
              left: D,
              right: P,
              width: O,
              height: E,
              x: D,
              y: B
            };
          }
          const x = F(l) === "left", w = z(...i.map((v) => v.right)), A = X(...i.map((v) => v.left)), y = i.filter((v) => x ? v.left === A : v.right === w), R = y[0].top, p = y[y.length - 1].bottom, C = A, k = w, j = k - C, T = p - R;
          return {
            top: R,
            bottom: p,
            left: C,
            right: k,
            width: j,
            height: T,
            x: C,
            y: R
          };
        }
        return m;
      }
      const h = await t.getElementRects({
        reference: {
          getBoundingClientRect: f
        },
        floating: e.floating,
        strategy: a
      });
      return s.reference.x !== h.reference.x || s.reference.y !== h.reference.y || s.reference.width !== h.reference.width || s.reference.height !== h.reference.height ? {
        reset: {
          rects: h
        }
      } : {};
    }
  };
};
async function it(o, c) {
  const {
    placement: l,
    platform: e,
    elements: s
  } = o, t = await (e.isRTL == null ? void 0 : e.isRTL(s.floating)), a = F(l), r = I(l), d = M(l) === "y", g = ["left", "top"].includes(a) ? -1 : 1, u = t && d ? -1 : 1, i = Y(c, o);
  let {
    mainAxis: m,
    crossAxis: n,
    alignmentAxis: f
  } = typeof i == "number" ? {
    mainAxis: i,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: i.mainAxis || 0,
    crossAxis: i.crossAxis || 0,
    alignmentAxis: i.alignmentAxis
  };
  return r && typeof f == "number" && (n = r === "end" ? f * -1 : f), d ? {
    x: n * u,
    y: m * g
  } : {
    x: m * g,
    y: n * u
  };
}
const rt = function(o) {
  return o === void 0 && (o = 0), {
    name: "offset",
    options: o,
    async fn(c) {
      var l, e;
      const {
        x: s,
        y: t,
        placement: a,
        middlewareData: r
      } = c, d = await it(c, o);
      return a === ((l = r.offset) == null ? void 0 : l.placement) && (e = r.arrow) != null && e.alignmentOffset ? {} : {
        x: s + d.x,
        y: t + d.y,
        data: {
          ...d,
          placement: a
        }
      };
    }
  };
}, ft = function(o) {
  return o === void 0 && (o = {}), {
    name: "shift",
    options: o,
    async fn(c) {
      const {
        x: l,
        y: e,
        placement: s
      } = c, {
        mainAxis: t = !0,
        crossAxis: a = !1,
        limiter: r = {
          fn: (x) => {
            let {
              x: w,
              y: A
            } = x;
            return {
              x: w,
              y: A
            };
          }
        },
        ...d
      } = Y(o, c), g = {
        x: l,
        y: e
      }, u = await J(c, d), i = M(F(s)), m = et(i);
      let n = g[m], f = g[i];
      if (t) {
        const x = m === "y" ? "top" : "left", w = m === "y" ? "bottom" : "right", A = n + u[x], y = n - u[w];
        n = _(A, n, y);
      }
      if (a) {
        const x = i === "y" ? "top" : "left", w = i === "y" ? "bottom" : "right", A = f + u[x], y = f - u[w];
        f = _(A, f, y);
      }
      const h = r.fn({
        ...c,
        [m]: n,
        [i]: f
      });
      return {
        ...h,
        data: {
          x: h.x - l,
          y: h.y - e,
          enabled: {
            [m]: t,
            [i]: a
          }
        }
      };
    }
  };
};
export {
  ct as arrow,
  st as computePosition,
  J as detectOverflow,
  lt as flip,
  at as inline,
  rt as offset,
  $ as rectToClientRect,
  ft as shift
};
//# sourceMappingURL=annotorious-react.es28.js.map
