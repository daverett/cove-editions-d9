import { offset as I, shift as J, flip as K, inline as N, computePosition as Q, arrow as v } from "./annotorious-react.es16.js";
import { autoUpdate as le, platform as ce } from "./annotorious-react.es16.js";
import * as f from "react";
import { useLayoutEffect as T, useEffect as X } from "react";
import * as Y from "react-dom";
var R = typeof document < "u" ? T : X;
function h(e, t) {
  if (e === t)
    return !0;
  if (typeof e != typeof t)
    return !1;
  if (typeof e == "function" && e.toString() === t.toString())
    return !0;
  let n, r, s;
  if (e && t && typeof e == "object") {
    if (Array.isArray(e)) {
      if (n = e.length, n !== t.length) return !1;
      for (r = n; r-- !== 0; )
        if (!h(e[r], t[r]))
          return !1;
      return !0;
    }
    if (s = Object.keys(e), n = s.length, n !== Object.keys(t).length)
      return !1;
    for (r = n; r-- !== 0; )
      if (!{}.hasOwnProperty.call(t, s[r]))
        return !1;
    for (r = n; r-- !== 0; ) {
      const p = s[r];
      if (!(p === "_owner" && e.$$typeof) && !h(e[p], t[p]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function q(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function A(e, t) {
  const n = q(e);
  return Math.round(t * n) / n;
}
function $(e) {
  const t = f.useRef(e);
  return R(() => {
    t.current = e;
  }), t;
}
function te(e) {
  e === void 0 && (e = {});
  const {
    placement: t = "bottom",
    strategy: n = "absolute",
    middleware: r = [],
    platform: s,
    elements: {
      reference: p,
      floating: B
    } = {},
    transform: k = !0,
    whileElementsMounted: D,
    open: x
  } = e, [i, O] = f.useState({
    x: 0,
    y: 0,
    strategy: n,
    placement: t,
    middlewareData: {},
    isPositioned: !1
  }), [M, U] = f.useState(r);
  h(M, r) || U(r);
  const [V, W] = f.useState(null), [z, G] = f.useState(null), _ = f.useCallback((o) => {
    o !== a.current && (a.current = o, W(o));
  }, []), C = f.useCallback((o) => {
    o !== d.current && (d.current = o, G(o));
  }, []), u = p || V, l = B || z, a = f.useRef(null), d = f.useRef(null), y = f.useRef(i), H = D != null, P = $(D), S = $(s), F = $(x), g = f.useCallback(() => {
    if (!a.current || !d.current)
      return;
    const o = {
      placement: t,
      strategy: n,
      middleware: M
    };
    S.current && (o.platform = S.current), Q(a.current, d.current, o).then((w) => {
      const m = {
        ...w,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: F.current !== !1
      };
      E.current && !h(y.current, m) && (y.current = m, Y.flushSync(() => {
        O(m);
      }));
    });
  }, [M, t, n, S, F]);
  R(() => {
    x === !1 && y.current.isPositioned && (y.current.isPositioned = !1, O((o) => ({
      ...o,
      isPositioned: !1
    })));
  }, [x]);
  const E = f.useRef(!1);
  R(() => (E.current = !0, () => {
    E.current = !1;
  }), []), R(() => {
    if (u && (a.current = u), l && (d.current = l), u && l) {
      if (P.current)
        return P.current(u, l, g);
      g();
    }
  }, [u, l, g, P, H]);
  const j = f.useMemo(() => ({
    reference: a,
    floating: d,
    setReference: _,
    setFloating: C
  }), [_, C]), c = f.useMemo(() => ({
    reference: u,
    floating: l
  }), [u, l]), L = f.useMemo(() => {
    const o = {
      position: n,
      left: 0,
      top: 0
    };
    if (!c.floating)
      return o;
    const w = A(c.floating, i.x), m = A(c.floating, i.y);
    return k ? {
      ...o,
      transform: "translate(" + w + "px, " + m + "px)",
      ...q(c.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: n,
      left: w,
      top: m
    };
  }, [n, k, c.floating, i.x, i.y]);
  return f.useMemo(() => ({
    ...i,
    update: g,
    refs: j,
    elements: c,
    floatingStyles: L
  }), [i, g, j, c, L]);
}
const Z = (e) => {
  function t(n) {
    return {}.hasOwnProperty.call(n, "current");
  }
  return {
    name: "arrow",
    options: e,
    fn(n) {
      const {
        element: r,
        padding: s
      } = typeof e == "function" ? e(n) : e;
      return r && t(r) ? r.current != null ? v({
        element: r.current,
        padding: s
      }).fn(n) : {} : r ? v({
        element: r,
        padding: s
      }).fn(n) : {};
    }
  };
}, ne = (e, t) => ({
  ...I(e),
  options: [e, t]
}), re = (e, t) => ({
  ...J(e),
  options: [e, t]
}), fe = (e, t) => ({
  ...K(e),
  options: [e, t]
}), oe = (e, t) => ({
  ...N(e),
  options: [e, t]
}), se = (e, t) => ({
  ...Z(e),
  options: [e, t]
});
export {
  se as arrow,
  le as autoUpdate,
  Q as computePosition,
  fe as flip,
  oe as inline,
  ne as offset,
  ce as platform,
  re as shift,
  te as useFloating
};
//# sourceMappingURL=annotorious-react.es15.js.map
