import { j as E } from "./annotorious-react.es11.js";
import { onUserSelect as I } from "@annotorious/core";
import { useDebounce as H } from "./annotorious-react.es12.js";
import { createContext as O, forwardRef as R, useState as v, useImperativeHandle as P, useEffect as m, useContext as l } from "react";
const i = O({
  anno: void 0,
  setAnno: void 0,
  annotations: [],
  selection: { selected: [] }
}), L = R((t, e) => {
  const [n, c] = v(null), [a, o] = v([]), [u, r] = v({ selected: [] });
  return P(e, () => n), m(() => {
    if (n) {
      const { selection: h, store: s, hover: S } = n.state;
      s.all().length > 0 && o(s.all());
      const b = () => o(() => s.all());
      s.observe(b);
      let d;
      const f = h.subscribe(({ selected: A, ...j }) => {
        d && s.unobserve(d);
        const D = (A || []).map(({ id: p, editable: w }) => ({ annotation: s.getAnnotation(p), editable: w }));
        r({ selected: D, ...j }), d = (p) => {
          const { updated: w } = p.changes;
          r((V) => ({
            ...V,
            selected: V.selected.map(({ annotation: g, editable: x }) => {
              const C = w.find((U) => U.oldValue.id === g.id);
              return C ? { annotation: C.newValue, editable: x } : { annotation: g, editable: x };
            })
          }));
        }, s.observe(d, { annotations: A.map(({ id: p }) => p) });
      });
      return () => {
        s.unobserve(b), f();
      };
    }
  }, [n]), /* @__PURE__ */ E.jsx(i.Provider, { value: {
    anno: n,
    setAnno: c,
    annotations: a,
    selection: u
  }, children: t.children });
}), M = () => {
  const { anno: t } = l(i);
  return t;
}, k = () => {
  const { anno: t } = l(i);
  return t == null ? void 0 : t.state.store;
}, q = () => {
  const { annotations: t } = l(i);
  return t;
}, y = (t) => {
  const { annotations: e } = l(i);
  return H(e, t);
}, N = (t) => t ? y(t) : q(), z = (t, e) => {
  const n = k(), [c, a] = v(
    n == null ? void 0 : n.getAnnotation(t)
  );
  return m(() => {
    if (!n) return;
    const o = (u) => {
      const r = u.changes.updated[0];
      r && a(r.newValue);
    };
    return n.observe(o, { ...e, annotations: t }), () => n.unobserve(o);
  }, []), c;
}, Q = (t, e) => {
  const n = z(t);
  return n ? I(n, e) : void 0;
}, T = () => {
  const { selection: t } = l(i);
  return t;
}, W = () => {
  const { anno: t } = l(i), [e, n] = v();
  return m(() => {
    if (!t) return;
    const { hover: c, store: a } = t.state, o = c.subscribe((u) => {
      if (u) {
        const r = a.getAnnotation(u);
        n(r);
      } else
        n(void 0);
    });
    return () => {
      o();
    };
  }, [t]), e;
}, X = () => {
  const { anno: t } = l(i);
  return t == null ? void 0 : t.getUser();
}, _ = () => {
  const { anno: t } = l(i), [e, n] = v([]);
  return m(() => {
    if (t) {
      const { store: c, viewport: a } = t.state;
      if (!a)
        return;
      let o;
      const u = a.subscribe((r) => {
        o && c.unobserve(o);
        const h = r.map((s) => c.getAnnotation(s));
        n(h), o = (s) => {
          const { updated: S } = s.changes;
          n((b) => b.map((d) => {
            const f = S.find((A) => A.oldValue.id === d.id);
            return f ? f.newValue : d;
          }));
        }, c.observe(o, { annotations: r });
      });
      return () => {
        u();
      };
    }
  }, [t]), e;
}, B = (t) => {
  const e = _();
  return H(e, t);
}, Y = (t) => t ? B(t) : _();
export {
  L as Annotorious,
  i as AnnotoriousContext,
  z as useAnnotation,
  Q as useAnnotationSelectAction,
  k as useAnnotationStore,
  N as useAnnotations,
  M as useAnnotator,
  X as useAnnotatorUser,
  W as useHover,
  T as useSelection,
  Y as useViewportState
};
//# sourceMappingURL=annotorious-react.es2.js.map
