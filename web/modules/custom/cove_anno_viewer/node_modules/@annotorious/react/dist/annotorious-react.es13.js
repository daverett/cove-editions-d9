import * as o from "react";
import { useLayoutEffect as q, useEffect as Q } from "react";
import { getComputedStyle as Z, isElement as I } from "./annotorious-react.es21.js";
import { getOverflowAncestors as Re } from "./annotorious-react.es21.js";
import "react-dom";
import { useFloating as z } from "./annotorious-react.es15.js";
import { arrow as xe, flip as Ee, inline as we, offset as Ce, shift as Se } from "./annotorious-react.es15.js";
const $ = {
  ...o
}, G = $.useInsertionEffect, J = G || ((t) => t());
function K(t) {
  const n = o.useRef(() => {
    if (process.env.NODE_ENV !== "production")
      throw new Error("Cannot call an event handler while rendering.");
  });
  return J(() => {
    n.current = t;
  }), o.useCallback(function() {
    for (var s = arguments.length, e = new Array(s), r = 0; r < s; r++)
      e[r] = arguments[r];
    return n.current == null ? void 0 : n.current(...e);
  }, []);
}
var b = typeof document < "u" ? q : Q;
function D() {
  return D = Object.assign ? Object.assign.bind() : function(t) {
    for (var n = 1; n < arguments.length; n++) {
      var s = arguments[n];
      for (var e in s)
        Object.prototype.hasOwnProperty.call(s, e) && (t[e] = s[e]);
    }
    return t;
  }, D.apply(this, arguments);
}
let V = !1, k = 0;
const W = () => (
  // Ensure the id is unique with multiple independent versions of Floating UI
  // on <React 18
  "floating-ui-" + Math.random().toString(36).slice(2, 6) + k++
);
function _() {
  const [t, n] = o.useState(() => V ? W() : void 0);
  return b(() => {
    t == null && n(W());
  }, []), o.useEffect(() => {
    V = !0;
  }, []), t;
}
const ee = $.useId, B = ee || _;
let P;
process.env.NODE_ENV !== "production" && (P = /* @__PURE__ */ new Set());
function te() {
  for (var t, n = arguments.length, s = new Array(n), e = 0; e < n; e++)
    s[e] = arguments[e];
  const r = "Floating UI: " + s.join(" ");
  if (!((t = P) != null && t.has(r))) {
    var l;
    (l = P) == null || l.add(r), console.warn(r);
  }
}
function ne() {
  for (var t, n = arguments.length, s = new Array(n), e = 0; e < n; e++)
    s[e] = arguments[e];
  const r = "Floating UI: " + s.join(" ");
  if (!((t = P) != null && t.has(r))) {
    var l;
    (l = P) == null || l.add(r), console.error(r);
  }
}
const me = /* @__PURE__ */ o.forwardRef(function(n, s) {
  const {
    context: {
      placement: e,
      elements: {
        floating: r
      },
      middlewareData: {
        arrow: l,
        shift: u
      }
    },
    width: i = 14,
    height: a = 7,
    tipRadius: O = 0,
    strokeWidth: d = 0,
    staticOffset: g,
    stroke: h,
    d: c,
    style: {
      transform: p,
      ...R
    } = {},
    ...v
  } = n;
  process.env.NODE_ENV !== "production" && (s || te("The `ref` prop is required for `FloatingArrow`."));
  const x = B(), [C, f] = o.useState(!1);
  if (b(() => {
    if (!r) return;
    Z(r).direction === "rtl" && f(!0);
  }, [r]), !r)
    return null;
  const [m, F] = e.split("-"), M = m === "top" || m === "bottom";
  let S = g;
  (M && u != null && u.x || !M && u != null && u.y) && (S = null);
  const E = d * 2, N = E / 2, A = i / 2 * (O / -8 + 1), T = a / 2 * O / 4, w = !!c, U = S && F === "end" ? "bottom" : "top";
  let j = S && F === "end" ? "right" : "left";
  S && C && (j = F === "end" ? "left" : "right");
  const H = (l == null ? void 0 : l.x) != null ? S || l.x : "", X = (l == null ? void 0 : l.y) != null ? S || l.y : "", y = c || "M0,0" + (" H" + i) + (" L" + (i - A) + "," + (a - T)) + (" Q" + i / 2 + "," + a + " " + A + "," + (a - T)) + " Z", Y = {
    top: w ? "rotate(180deg)" : "",
    left: w ? "rotate(90deg)" : "rotate(-90deg)",
    bottom: w ? "" : "rotate(180deg)",
    right: w ? "rotate(-90deg)" : "rotate(90deg)"
  }[m];
  return /* @__PURE__ */ o.createElement("svg", D({}, v, {
    "aria-hidden": !0,
    ref: s,
    width: w ? i : i + E,
    height: i,
    viewBox: "0 0 " + i + " " + (a > i ? a : i),
    style: {
      position: "absolute",
      pointerEvents: "none",
      [j]: H,
      [U]: X,
      [m]: M || w ? "100%" : "calc(100% - " + E / 2 + "px)",
      transform: [Y, p].filter((L) => !!L).join(" "),
      ...R
    }
  }), E > 0 && /* @__PURE__ */ o.createElement("path", {
    clipPath: "url(#" + x + ")",
    fill: "none",
    stroke: h,
    strokeWidth: E + (c ? 0 : 1),
    d: y
  }), /* @__PURE__ */ o.createElement("path", {
    stroke: E && !c ? v.fill : "none",
    d: y
  }), /* @__PURE__ */ o.createElement("clipPath", {
    id: x
  }, /* @__PURE__ */ o.createElement("rect", {
    x: -N,
    y: N * (w ? -1 : 1),
    width: i + E,
    height: i
  })));
});
function oe() {
  const t = /* @__PURE__ */ new Map();
  return {
    emit(n, s) {
      var e;
      (e = t.get(n)) == null || e.forEach((r) => r(s));
    },
    on(n, s) {
      t.set(n, [...t.get(n) || [], s]);
    },
    off(n, s) {
      var e;
      t.set(n, ((e = t.get(n)) == null ? void 0 : e.filter((r) => r !== s)) || []);
    }
  };
}
const re = /* @__PURE__ */ o.createContext(null), se = /* @__PURE__ */ o.createContext(null), ce = () => {
  var t;
  return ((t = o.useContext(re)) == null ? void 0 : t.id) || null;
}, le = () => o.useContext(se);
function ie(t) {
  const {
    open: n = !1,
    onOpenChange: s,
    elements: e
  } = t, r = B(), l = o.useRef({}), [u] = o.useState(() => oe()), i = ce() != null;
  if (process.env.NODE_ENV !== "production") {
    const c = e.reference;
    c && !I(c) && ne("Cannot pass a virtual element to the `elements.reference` option,", "as it must be a real DOM element. Use `refs.setPositionReference()`", "instead.");
  }
  const [a, O] = o.useState(e.reference), d = K((c, p, R) => {
    l.current.openEvent = c ? p : void 0, u.emit("openchange", {
      open: c,
      event: p,
      reason: R,
      nested: i
    }), s == null || s(c, p, R);
  }), g = o.useMemo(() => ({
    setPositionReference: O
  }), []), h = o.useMemo(() => ({
    reference: a || e.reference || null,
    floating: e.floating || null,
    domReference: e.reference
  }), [a, e.reference, e.floating]);
  return o.useMemo(() => ({
    dataRef: l,
    open: n,
    onOpenChange: d,
    elements: h,
    events: u,
    floatingId: r,
    refs: g
  }), [n, d, h, u, r, g]);
}
function ge(t) {
  t === void 0 && (t = {});
  const {
    nodeId: n
  } = t, s = ie({
    ...t,
    elements: {
      reference: null,
      floating: null,
      ...t.elements
    }
  }), e = t.rootContext || s, r = e.elements, [l, u] = o.useState(null), [i, a] = o.useState(null), d = (r == null ? void 0 : r.domReference) || l, g = o.useRef(null), h = le();
  b(() => {
    d && (g.current = d);
  }, [d]);
  const c = z({
    ...t,
    elements: {
      ...r,
      ...i && {
        reference: i
      }
    }
  }), p = o.useCallback((f) => {
    const m = I(f) ? {
      getBoundingClientRect: () => f.getBoundingClientRect(),
      contextElement: f
    } : f;
    a(m), c.refs.setReference(m);
  }, [c.refs]), R = o.useCallback((f) => {
    (I(f) || f === null) && (g.current = f, u(f)), (I(c.refs.reference.current) || c.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    f !== null && !I(f)) && c.refs.setReference(f);
  }, [c.refs]), v = o.useMemo(() => ({
    ...c.refs,
    setReference: R,
    setPositionReference: p,
    domReference: g
  }), [c.refs, R, p]), x = o.useMemo(() => ({
    ...c.elements,
    domReference: d
  }), [c.elements, d]), C = o.useMemo(() => ({
    ...c,
    ...e,
    refs: v,
    elements: x,
    nodeId: n
  }), [c, v, x, n, e]);
  return b(() => {
    e.dataRef.current.floatingContext = C;
    const f = h == null ? void 0 : h.nodesRef.current.find((m) => m.id === n);
    f && (f.context = C);
  }), o.useMemo(() => ({
    ...c,
    context: C,
    refs: v,
    elements: x
  }), [c, v, x, C]);
}
export {
  me as FloatingArrow,
  xe as arrow,
  Ee as flip,
  Re as getOverflowAncestors,
  we as inline,
  Ce as offset,
  Se as shift,
  ge as useFloating,
  ce as useFloatingParentNodeId,
  ie as useFloatingRootContext,
  le as useFloatingTree,
  B as useId
};
//# sourceMappingURL=annotorious-react.es13.js.map
